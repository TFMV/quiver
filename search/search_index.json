{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#welcome-to-quiver","title":"Welcome to Quiver! \ud83c\udff9","text":"<ul> <li> <p> Blazing Fast   Search through millions of vectors in microseconds</p> </li> <li> <p> Rich Metadata   Combine vector search with powerful SQL filtering</p> </li> <li> <p> Production Ready   Built for reliability, scalability, and performance</p> </li> <li> <p> Secure &amp; Robust   Encryption, backups, and comprehensive monitoring</p> </li> </ul>"},{"location":"#what-is-quiver","title":"What is Quiver?","text":"<p>Quiver is a high-performance vector database built in Go. It's designed to make similarity search on high-dimensional vectors not just fast, but ridiculously fast. Whether you're building a recommendation system, semantic search, or AI-powered application, Quiver gives you the tools to find what you're looking for in microseconds.</p> <pre><code>// Initialize Quiver\nidx, _ := quiver.New(quiver.Config{\n    Dimension: 128,\n    StoragePath: \"data.db\",\n}, logger)\n\n// Add vectors with metadata\nidx.Add(1, vector, map[string]interface{}{\n    \"category\": \"science\",\n    \"name\": \"black hole\",\n})\n\n// Search for similar vectors\nresults, _ := idx.Search(queryVector, 10)\n</code></pre>"},{"location":"#why-quiver","title":"Why Quiver?","text":""},{"location":"#speed-that-makes-you-go-whoa","title":"Speed That Makes You Go \"Whoa!\" \ud83e\udd2f","text":"<p>Quiver is built on the HNSW algorithm, one of the fastest approximate nearest neighbor search methods available. But we didn't stop there - we've optimized every aspect of the system to deliver search results in microseconds, even with millions of vectors.</p>"},{"location":"#not-just-vectors-but-context","title":"Not Just Vectors, But Context \ud83e\udde9","text":"<p>Unlike many vector databases that only store vectors, Quiver integrates with DuckDB to provide rich metadata storage and querying. This means you can combine vector similarity with traditional SQL filtering for powerful hybrid searches.</p> <pre><code>// Find similar vectors that match specific metadata criteria\nresults, _ := idx.SearchWithFilter(queryVector, 10, \n    \"category = 'science' AND tags LIKE '%physics%'\")\n</code></pre>"},{"location":"#built-for-the-real-world","title":"Built for the Real World \ud83c\udf0d","text":"<p>Quiver isn't just a research project - it's built for production use. With features like:</p> <ul> <li>Automatic persistence and recovery</li> <li>Scheduled backups with rotation</li> <li>Encryption for data at rest</li> <li>Comprehensive monitoring and metrics</li> <li>HTTP API for easy integration</li> </ul>"},{"location":"#getting-started","title":"Getting Started","text":"<p>Ready to give Quiver a shot? Check out our Quick Start Guide or dive into the Installation Instructions.</p>"},{"location":"#performance","title":"Performance","text":"<p>Quiver is fast. Here are some benchmarks on an M2 Pro CPU:</p> Operation Throughput Latency Memory/Op Search 16.9K ops/sec 59\u03bcs 24.2 KB Add 6.4K ops/sec 156\u03bcs 20.9 KB Hybrid Search 4.8K ops/sec 208\u03bcs 80.6 KB"},{"location":"#community-support","title":"Community &amp; Support","text":"<ul> <li>GitHub Issues - Bug reports and feature requests</li> <li>GitHub Discussions - Questions and community discussions</li> <li>Contributing Guide - How to contribute to Quiver</li> </ul>"},{"location":"api-reference/","title":"API Reference","text":"<p>Welcome to the Quiver API reference! Here you'll find detailed documentation for all the functions, methods, and types in Quiver. Whether you're using the Go library directly or interacting with the HTTP API, this guide has you covered. Let's dive in! \ud83d\udcda</p>"},{"location":"api-reference/#go-library-api","title":"Go Library API","text":""},{"location":"api-reference/#core-types","title":"Core Types","text":""},{"location":"api-reference/#config","title":"Config","text":"<p>The <code>Config</code> struct controls the behavior of the Quiver index:</p> <pre><code>type Config struct {\n    Dimension       int            // Vector dimension\n    StoragePath     string         // Path to store index files\n    Distance        DistanceMetric // Distance metric (Cosine or L2)\n    MaxElements     uint64         // Maximum number of vectors (0 = unlimited)\n    HNSWM           int            // HNSW hyperparameter M (default: 16)\n    HNSWEfConstruct int            // HNSW hyperparameter efConstruction (default: 200)\n    HNSWEfSearch    int            // HNSW hyperparameter efSearch (default: 100)\n    BatchSize       int            // Number of vectors to batch before insertion (default: 1000)\n\n    // Persistence configuration\n    PersistInterval time.Duration  // How often to persist index to disk (default: 5m)\n\n    // Backup configuration\n    BackupInterval    time.Duration // How often to create backups (default: 1h)\n    BackupPath        string        // Path to store backups (default: StoragePath/backups)\n    BackupCompression bool          // Whether to compress backups (default: true)\n    MaxBackups        int           // Maximum number of backups to keep (default: 5)\n\n    // Security configuration\n    EncryptionEnabled bool   // Whether to encrypt data at rest\n    EncryptionKey     string // Key for encrypting data at rest (min 32 bytes)\n}\n</code></pre>"},{"location":"api-reference/#distancemetric","title":"DistanceMetric","text":"<p>The <code>DistanceMetric</code> type defines the similarity metrics:</p> <pre><code>type DistanceMetric int\n\nconst (\n    Cosine DistanceMetric = iota // Cosine distance (1 - cosine similarity)\n    L2                           // Euclidean (L2) distance\n)\n</code></pre>"},{"location":"api-reference/#searchresult","title":"SearchResult","text":"<p>The <code>SearchResult</code> struct represents a single search result:</p> <pre><code>type SearchResult struct {\n    ID       uint64                 // Vector ID\n    Distance float32                // Distance from query vector\n    Metadata map[string]interface{} // Associated metadata\n}\n</code></pre>"},{"location":"api-reference/#index-creation-and-management","title":"Index Creation and Management","text":""},{"location":"api-reference/#new","title":"New","text":"<p>Creates a new Quiver index:</p> <pre><code>func New(config Config, logger *zap.Logger) (*Index, error)\n</code></pre> <p>Example:</p> <pre><code>logger, _ := zap.NewProduction()\nconfig := quiver.Config{\n    Dimension:   128,\n    StoragePath: \"/path/to/storage.db\",\n    Distance:    quiver.Cosine,\n    HNSWM:       16,\n    BatchSize:   1000,\n}\nidx, err := quiver.New(config, logger)\nif err != nil {\n    log.Fatalf(\"Failed to create index: %v\", err)\n}\ndefer idx.Close()\n</code></pre>"},{"location":"api-reference/#load","title":"Load","text":"<p>Loads an existing Quiver index from disk:</p> <pre><code>func Load(config Config, logger *zap.Logger) (*Index, error)\n</code></pre> <p>Example:</p> <pre><code>logger, _ := zap.NewProduction()\nconfig := quiver.Config{\n    StoragePath: \"/path/to/storage.db\",\n}\nidx, err := quiver.Load(config, logger)\nif err != nil {\n    log.Fatalf(\"Failed to load index: %v\", err)\n}\ndefer idx.Close()\n</code></pre>"},{"location":"api-reference/#close","title":"Close","text":"<p>Closes the index and releases resources:</p> <pre><code>func (idx *Index) Close() error\n</code></pre> <p>Example:</p> <pre><code>err := idx.Close()\nif err != nil {\n    log.Fatalf(\"Failed to close index: %v\", err)\n}\n</code></pre>"},{"location":"api-reference/#vector-operations","title":"Vector Operations","text":""},{"location":"api-reference/#add","title":"Add","text":"<p>Adds a vector to the index:</p> <pre><code>func (idx *Index) Add(id uint64, vector []float32, meta map[string]interface{}) error\n</code></pre> <p>Example:</p> <pre><code>id := uint64(1)\nvector := []float32{0.1, 0.2, 0.3, ...} // 128-dimensional vector\nmetadata := map[string]interface{}{\n    \"name\": \"example\",\n    \"category\": \"test\",\n    \"tags\": []string{\"tag1\", \"tag2\"},\n}\nerr := idx.Add(id, vector, metadata)\nif err != nil {\n    log.Fatalf(\"Failed to add vector: %v\", err)\n}\n</code></pre>"},{"location":"api-reference/#batchadd","title":"BatchAdd","text":"<p>Adds multiple vectors to the index in a single batch:</p> <pre><code>func (idx *Index) BatchAdd(ids []uint64, vectors [][]float32, metadata []map[string]interface{}) error\n</code></pre> <p>Example:</p> <pre><code>ids := []uint64{1, 2, 3}\nvectors := [][]float32{\n    {0.1, 0.2, 0.3, ...}, // Vector 1\n    {0.4, 0.5, 0.6, ...}, // Vector 2\n    {0.7, 0.8, 0.9, ...}, // Vector 3\n}\nmetadata := []map[string]interface{}{\n    {\"name\": \"vector1\", \"category\": \"A\"},\n    {\"name\": \"vector2\", \"category\": \"B\"},\n    {\"name\": \"vector3\", \"category\": \"C\"},\n}\nerr := idx.BatchAdd(ids, vectors, metadata)\nif err != nil {\n    log.Fatalf(\"Failed to batch add vectors: %v\", err)\n}\n</code></pre>"},{"location":"api-reference/#appendfromarrow","title":"AppendFromArrow","text":"<p>Adds vectors from an Arrow record:</p> <pre><code>func (idx *Index) AppendFromArrow(rec arrow.Record) error\n</code></pre> <p>Example:</p> <pre><code>// Create Arrow record with vectors and metadata\nbuilder := array.NewRecordBuilder(memory.DefaultAllocator, quiver.NewVectorSchema(128))\n// ... populate the builder ...\nrecord := builder.NewRecord()\n\n// Add all vectors from the Arrow record\nerr := idx.AppendFromArrow(record)\nif err != nil {\n    log.Fatalf(\"Failed to append from Arrow: %v\", err)\n}\n</code></pre>"},{"location":"api-reference/#search-operations","title":"Search Operations","text":""},{"location":"api-reference/#search","title":"Search","text":"<p>Searches for similar vectors:</p> <pre><code>func (idx *Index) Search(query []float32, k, page, pageSize int) ([]SearchResult, error)\n</code></pre> <p>Parameters:</p> <ul> <li><code>query</code>: Query vector</li> <li><code>k</code>: Number of nearest neighbors to find</li> <li><code>page</code>: Page number (1-indexed)</li> <li><code>pageSize</code>: Number of results per page</li> </ul> <p>Example:</p> <pre><code>query := []float32{0.1, 0.2, 0.3, ...} // 128-dimensional vector\nresults, err := idx.Search(query, 10, 1, 10) // Find 10 nearest neighbors, first page, 10 results per page\nif err != nil {\n    log.Fatalf(\"Failed to search: %v\", err)\n}\n\nfor i, result := range results {\n    fmt.Printf(\"Result %d: ID=%d, Distance=%f, Metadata=%v\\n\", i, result.ID, result.Distance, result.Metadata)\n}\n</code></pre>"},{"location":"api-reference/#searchwithfilter","title":"SearchWithFilter","text":"<p>Searches for similar vectors with metadata filtering:</p> <pre><code>func (idx *Index) SearchWithFilter(query []float32, k int, filter string) ([]SearchResult, error)\n</code></pre> <p>Parameters:</p> <ul> <li><code>query</code>: Query vector</li> <li><code>k</code>: Number of nearest neighbors to find</li> <li><code>filter</code>: SQL WHERE clause for filtering metadata</li> </ul> <p>Example:</p> <pre><code>query := []float32{0.1, 0.2, 0.3, ...} // 128-dimensional vector\nfilter := \"category = 'test' AND score &gt; 0.5\"\nresults, err := idx.SearchWithFilter(query, 10, filter) // Find 10 nearest neighbors matching the filter\nif err != nil {\n    log.Fatalf(\"Failed to search with filter: %v\", err)\n}\n\nfor i, result := range results {\n    fmt.Printf(\"Result %d: ID=%d, Distance=%f, Metadata=%v\\n\", i, result.ID, result.Distance, result.Metadata)\n}\n</code></pre>"},{"location":"api-reference/#searchwithnegatives","title":"SearchWithNegatives","text":"<p>Searches for similar vectors with negative examples:</p> <pre><code>func (idx *Index) SearchWithNegatives(positiveQuery []float32, negativeQueries [][]float32, k, page, pageSize int) ([]SearchResult, error)\n</code></pre> <p>Parameters:</p> <ul> <li><code>positiveQuery</code>: Query vector to find similar vectors to</li> <li><code>negativeQueries</code>: Query vectors to find dissimilar vectors from</li> <li><code>k</code>: Number of nearest neighbors to find</li> <li><code>page</code>: Page number (1-indexed)</li> <li><code>pageSize</code>: Number of results per page</li> </ul> <p>Example:</p> <pre><code>positiveQuery := []float32{0.1, 0.2, 0.3, ...} // 128-dimensional vector\nnegativeQueries := [][]float32{\n    {0.9, 0.8, 0.7, ...}, // Negative example 1\n    {0.6, 0.5, 0.4, ...}, // Negative example 2\n}\nresults, err := idx.SearchWithNegatives(positiveQuery, negativeQueries, 10, 1, 10)\nif err != nil {\n    log.Fatalf(\"Failed to search with negatives: %v\", err)\n}\n\nfor i, result := range results {\n    fmt.Printf(\"Result %d: ID=%d, Distance=%f, Metadata=%v\\n\", i, result.ID, result.Distance, result.Metadata)\n}\n</code></pre>"},{"location":"api-reference/#facetedsearch","title":"FacetedSearch","text":"<p>Searches for similar vectors with faceted filtering:</p> <pre><code>func (idx *Index) FacetedSearch(query []float32, k int, facets map[string]string) ([]SearchResult, error)\n</code></pre> <p>Parameters:</p> <ul> <li><code>query</code>: Query vector</li> <li><code>k</code>: Number of nearest neighbors to find</li> <li><code>facets</code>: Map of facet field names to values</li> </ul> <p>Example:</p> <pre><code>query := []float32{0.1, 0.2, 0.3, ...} // 128-dimensional vector\nfacets := map[string]string{\n    \"category\": \"electronics\",\n    \"brand\": \"apple\",\n}\nresults, err := idx.FacetedSearch(query, 10, facets)\nif err != nil {\n    log.Fatalf(\"Failed to perform faceted search: %v\", err)\n}\n\nfor i, result := range results {\n    fmt.Printf(\"Result %d: ID=%d, Distance=%f, Metadata=%v\\n\", i, result.ID, result.Distance, result.Metadata)\n}\n</code></pre>"},{"location":"api-reference/#multivectorsearch","title":"MultiVectorSearch","text":"<p>Searches for multiple query vectors in a single call:</p> <pre><code>func (idx *Index) MultiVectorSearch(queries [][]float32, k int) ([][]SearchResult, error)\n</code></pre> <p>Parameters:</p> <ul> <li><code>queries</code>: Array of query vectors</li> <li><code>k</code>: Number of nearest neighbors to find for each query</li> </ul> <p>Example:</p> <pre><code>queries := [][]float32{\n    {0.1, 0.2, 0.3, ...}, // Query 1\n    {0.4, 0.5, 0.6, ...}, // Query 2\n}\nresults, err := idx.MultiVectorSearch(queries, 10)\nif err != nil {\n    log.Fatalf(\"Failed to perform multi-vector search: %v\", err)\n}\n\nfor i, queryResults := range results {\n    fmt.Printf(\"Results for query %d:\\n\", i)\n    for j, result := range queryResults {\n        fmt.Printf(\"  Result %d: ID=%d, Distance=%f\\n\", j, result.ID, result.Distance)\n    }\n}\n</code></pre>"},{"location":"api-reference/#metadata-operations","title":"Metadata Operations","text":""},{"location":"api-reference/#querymetadata","title":"QueryMetadata","text":"<p>Queries metadata using SQL:</p> <pre><code>func (idx *Index) QueryMetadata(query string) ([]map[string]interface{}, error)\n</code></pre> <p>Example:</p> <pre><code>query := \"SELECT * FROM metadata WHERE category = 'test' ORDER BY score DESC LIMIT 10\"\nresults, err := idx.QueryMetadata(query)\nif err != nil {\n    log.Fatalf(\"Failed to query metadata: %v\", err)\n}\n\nfor i, result := range results {\n    fmt.Printf(\"Result %d: %v\\n\", i, result)\n}\n</code></pre>"},{"location":"api-reference/#persistence-and-backup","title":"Persistence and Backup","text":""},{"location":"api-reference/#save","title":"Save","text":"<p>Saves the index to disk:</p> <pre><code>func (idx *Index) Save(saveDir string) error\n</code></pre> <p>Example:</p> <pre><code>err := idx.Save(\"/path/to/save/directory\")\nif err != nil {\n    log.Fatalf(\"Failed to save index: %v\", err)\n}\n</code></pre>"},{"location":"api-reference/#backup","title":"Backup","text":"<p>Creates a backup of the index:</p> <pre><code>func (idx *Index) Backup(path string, incremental bool, compress bool) error\n</code></pre> <p>Parameters:</p> <ul> <li><code>path</code>: Path to store the backup</li> <li><code>incremental</code>: Whether to create an incremental backup</li> <li><code>compress</code>: Whether to compress the backup</li> </ul> <p>Example:</p> <pre><code>err := idx.Backup(\"/path/to/backup\", false, true) // Full backup with compression\nif err != nil {\n    log.Fatalf(\"Failed to create backup: %v\", err)\n}\n</code></pre>"},{"location":"api-reference/#restore","title":"Restore","text":"<p>Restores the index from a backup:</p> <pre><code>func (idx *Index) Restore(backupPath string) error\n</code></pre> <p>Example:</p> <pre><code>err := idx.Restore(\"/path/to/backup.zip\")\nif err != nil {\n    log.Fatalf(\"Failed to restore from backup: %v\", err)\n}\n</code></pre>"},{"location":"api-reference/#utility-functions","title":"Utility Functions","text":""},{"location":"api-reference/#healthcheck","title":"HealthCheck","text":"<p>Checks the health of the index:</p> <pre><code>func (idx *Index) HealthCheck() error\n</code></pre> <p>Example:</p> <pre><code>err := idx.HealthCheck()\nif err != nil {\n    log.Fatalf(\"Health check failed: %v\", err)\n}\n</code></pre>"},{"location":"api-reference/#collectmetrics","title":"CollectMetrics","text":"<p>Collects performance metrics:</p> <pre><code>func (idx *Index) CollectMetrics() map[string]interface{}\n</code></pre> <p>Example:</p> <pre><code>metrics := idx.CollectMetrics()\nfmt.Printf(\"Vector count: %d\\n\", metrics[\"vector_count\"])\nfmt.Printf(\"Memory usage: %.2f MB\\n\", metrics[\"memory_usage_mb\"])\n</code></pre>"},{"location":"api-reference/#http-api","title":"HTTP API","text":"<p>Quiver provides a RESTful HTTP API for remote access. All endpoints return JSON responses.</p>"},{"location":"api-reference/#authentication","title":"Authentication","text":"<p>All API endpoints (except <code>/health</code>) require authentication using an API key:</p> <pre><code>Authorization: Bearer your-api-key\n</code></pre>"},{"location":"api-reference/#endpoints","title":"Endpoints","text":""},{"location":"api-reference/#health-check","title":"Health Check","text":"<pre><code>GET /health\n</code></pre> <p>Checks if the server is running.</p> <p>Response:</p> <pre><code>{\n  \"status\": \"ok\"\n}\n</code></pre>"},{"location":"api-reference/#add-vector","title":"Add Vector","text":"<pre><code>POST /vectors\n</code></pre> <p>Adds a vector to the index.</p> <p>Request Body:</p> <pre><code>{\n  \"id\": 1,\n  \"vector\": [0.1, 0.2, 0.3, ...],\n  \"metadata\": {\n    \"name\": \"example\",\n    \"category\": \"test\",\n    \"tags\": [\"tag1\", \"tag2\"]\n  }\n}\n</code></pre> <p>Response:</p> <pre><code>{\n  \"success\": true,\n  \"id\": 1\n}\n</code></pre>"},{"location":"api-reference/#batch-add-vectors","title":"Batch Add Vectors","text":"<pre><code>POST /vectors/batch\n</code></pre> <p>Adds multiple vectors to the index.</p> <p>Request Body:</p> <pre><code>{\n  \"vectors\": [\n    {\n      \"id\": 1,\n      \"vector\": [0.1, 0.2, 0.3, ...],\n      \"metadata\": {\n        \"name\": \"vector1\",\n        \"category\": \"A\"\n      }\n    },\n    {\n      \"id\": 2,\n      \"vector\": [0.4, 0.5, 0.6, ...],\n      \"metadata\": {\n        \"name\": \"vector2\",\n        \"category\": \"B\"\n      }\n    }\n  ]\n}\n</code></pre> <p>Response:</p> <pre><code>{\n  \"success\": true,\n  \"count\": 2\n}\n</code></pre>"},{"location":"api-reference/#search_1","title":"Search","text":"<pre><code>POST /search\n</code></pre> <p>Searches for similar vectors.</p> <p>Request Body:</p> <pre><code>{\n  \"vector\": [0.1, 0.2, 0.3, ...],\n  \"k\": 10,\n  \"page\": 1,\n  \"page_size\": 10\n}\n</code></pre> <p>Response:</p> <pre><code>{\n  \"results\": [\n    {\n      \"id\": 1,\n      \"distance\": 0.1234,\n      \"metadata\": {\n        \"name\": \"example\",\n        \"category\": \"test\"\n      }\n    },\n    // More results...\n  ]\n}\n</code></pre>"},{"location":"api-reference/#hybrid-search","title":"Hybrid Search","text":"<pre><code>POST /search/hybrid\n</code></pre> <p>Searches for similar vectors with metadata filtering.</p> <p>Request Body:</p> <pre><code>{\n  \"vector\": [0.1, 0.2, 0.3, ...],\n  \"k\": 10,\n  \"filter\": \"category = 'test' AND score &gt; 0.5\"\n}\n</code></pre> <p>Response:</p> <pre><code>{\n  \"results\": [\n    {\n      \"id\": 1,\n      \"distance\": 0.1234,\n      \"metadata\": {\n        \"name\": \"example\",\n        \"category\": \"test\",\n        \"score\": 0.75\n      }\n    },\n    // More results...\n  ]\n}\n</code></pre>"},{"location":"api-reference/#search-with-negatives","title":"Search with Negatives","text":"<pre><code>POST /search/negatives\n</code></pre> <p>Searches for similar vectors with negative examples.</p> <p>Request Body:</p> <pre><code>{\n  \"positive_vector\": [0.1, 0.2, 0.3, ...],\n  \"negative_vectors\": [\n    [0.9, 0.8, 0.7, ...],\n    [0.6, 0.5, 0.4, ...]\n  ],\n  \"k\": 10,\n  \"page\": 1,\n  \"page_size\": 10\n}\n</code></pre> <p>Response:</p> <pre><code>{\n  \"results\": [\n    {\n      \"id\": 1,\n      \"distance\": 0.1234,\n      \"metadata\": {\n        \"name\": \"example\",\n        \"category\": \"test\"\n      }\n    },\n    // More results...\n  ]\n}\n</code></pre>"},{"location":"api-reference/#faceted-search","title":"Faceted Search","text":"<pre><code>POST /search/faceted\n</code></pre> <p>Searches for similar vectors with faceted filtering.</p> <p>Request Body:</p> <pre><code>{\n  \"vector\": [0.1, 0.2, 0.3, ...],\n  \"k\": 10,\n  \"facets\": {\n    \"category\": \"electronics\",\n    \"brand\": \"apple\"\n  }\n}\n</code></pre> <p>Response:</p> <pre><code>{\n  \"results\": [\n    {\n      \"id\": 1,\n      \"distance\": 0.1234,\n      \"metadata\": {\n        \"name\": \"iPhone\",\n        \"category\": \"electronics\",\n        \"brand\": \"apple\"\n      }\n    },\n    // More results...\n  ]\n}\n</code></pre>"},{"location":"api-reference/#query-metadata","title":"Query Metadata","text":"<pre><code>POST /metadata/query\n</code></pre> <p>Queries metadata using SQL.</p> <p>Request Body:</p> <pre><code>{\n  \"query\": \"SELECT * FROM metadata WHERE category = 'test' ORDER BY score DESC LIMIT 10\"\n}\n</code></pre> <p>Response:</p> <pre><code>{\n  \"results\": [\n    {\n      \"id\": 1,\n      \"name\": \"example\",\n      \"category\": \"test\",\n      \"score\": 0.95\n    },\n    // More results...\n  ]\n}\n</code></pre>"},{"location":"api-reference/#backup_1","title":"Backup","text":"<pre><code>POST /admin/backup\n</code></pre> <p>Creates a backup of the index.</p> <p>Request Body:</p> <pre><code>{\n  \"path\": \"/path/to/backup\",\n  \"incremental\": false,\n  \"compress\": true\n}\n</code></pre> <p>Response:</p> <pre><code>{\n  \"success\": true,\n  \"path\": \"/path/to/backup.zip\",\n  \"size_bytes\": 1024000,\n  \"timestamp\": \"2023-06-15T14:30:00Z\"\n}\n</code></pre>"},{"location":"api-reference/#restore_1","title":"Restore","text":"<pre><code>POST /admin/restore\n</code></pre> <p>Restores the index from a backup.</p> <p>Request Body:</p> <pre><code>{\n  \"path\": \"/path/to/backup.zip\"\n}\n</code></pre> <p>Response:</p> <pre><code>{\n  \"success\": true,\n  \"vector_count\": 10000,\n  \"timestamp\": \"2023-06-15T14:35:00Z\"\n}\n</code></pre>"},{"location":"api-reference/#get-metrics","title":"Get Metrics","text":"<pre><code>GET /admin/metrics\n</code></pre> <p>Gets performance metrics.</p> <p>Response:</p> <pre><code>{\n  \"vector_count\": 10000,\n  \"memory_usage_mb\": 256.5,\n  \"uptime_seconds\": 3600,\n  \"search_latency_ms\": 5.2,\n  \"add_latency_ms\": 2.1\n}\n</code></pre>"},{"location":"api-reference/#python-client-api","title":"Python Client API","text":"<p>Quiver provides a Python client for easy integration with Python applications.</p>"},{"location":"api-reference/#installation","title":"Installation","text":"<pre><code>pip install quiver-db\n</code></pre>"},{"location":"api-reference/#client-initialization","title":"Client Initialization","text":"<pre><code>from quiver import Client\n\n# Connect to a local Quiver server\nclient = Client(\"http://localhost:8080\", api_key=\"your-api-key\")\n\n# Connect to a remote Quiver server\nclient = Client(\"https://quiver.example.com\", api_key=\"your-api-key\")\n</code></pre>"},{"location":"api-reference/#vector-operations_1","title":"Vector Operations","text":""},{"location":"api-reference/#add-vector_1","title":"Add Vector","text":"<pre><code># Add a single vector\nclient.add(\n    id=1,\n    vector=[0.1, 0.2, 0.3, ...],  # 128-dimensional vector\n    metadata={\n        \"name\": \"example\",\n        \"category\": \"test\",\n        \"tags\": [\"tag1\", \"tag2\"]\n    }\n)\n</code></pre>"},{"location":"api-reference/#batch-add-vectors_1","title":"Batch Add Vectors","text":"<pre><code># Add multiple vectors\nvectors = [\n    {\n        \"id\": 1,\n        \"vector\": [0.1, 0.2, 0.3, ...],\n        \"metadata\": {\"name\": \"vector1\", \"category\": \"A\"}\n    },\n    {\n        \"id\": 2,\n        \"vector\": [0.4, 0.5, 0.6, ...],\n        \"metadata\": {\"name\": \"vector2\", \"category\": \"B\"}\n    }\n]\nclient.batch_add(vectors)\n</code></pre>"},{"location":"api-reference/#search-operations_1","title":"Search Operations","text":""},{"location":"api-reference/#search_2","title":"Search","text":"<pre><code># Search for similar vectors\nresults = client.search(\n    vector=[0.1, 0.2, 0.3, ...],\n    k=10,\n    page=1,\n    page_size=10\n)\n\nfor result in results:\n    print(f\"ID: {result['id']}, Distance: {result['distance']}, Metadata: {result['metadata']}\")\n</code></pre>"},{"location":"api-reference/#hybrid-search_1","title":"Hybrid Search","text":"<pre><code># Search with metadata filtering\nresults = client.hybrid_search(\n    vector=[0.1, 0.2, 0.3, ...],\n    k=10,\n    filter=\"category = 'test' AND score &gt; 0.5\"\n)\n\nfor result in results:\n    print(f\"ID: {result['id']}, Distance: {result['distance']}, Metadata: {result['metadata']}\")\n</code></pre>"},{"location":"api-reference/#search-with-negatives_1","title":"Search with Negatives","text":"<pre><code># Search with negative examples\nresults = client.search_with_negatives(\n    positive_vector=[0.1, 0.2, 0.3, ...],\n    negative_vectors=[\n        [0.9, 0.8, 0.7, ...],\n        [0.6, 0.5, 0.4, ...]\n    ],\n    k=10,\n    page=1,\n    page_size=10\n)\n\nfor result in results:\n    print(f\"ID: {result['id']}, Distance: {result['distance']}, Metadata: {result['metadata']}\")\n</code></pre>"},{"location":"api-reference/#faceted-search_1","title":"Faceted Search","text":"<pre><code># Search with faceted filtering\nresults = client.faceted_search(\n    vector=[0.1, 0.2, 0.3, ...],\n    k=10,\n    facets={\n        \"category\": \"electronics\",\n        \"brand\": \"apple\"\n    }\n)\n\nfor result in results:\n    print(f\"ID: {result['id']}, Distance: {result['distance']}, Metadata: {result['metadata']}\")\n</code></pre>"},{"location":"api-reference/#metadata-operations_1","title":"Metadata Operations","text":""},{"location":"api-reference/#query-metadata_1","title":"Query Metadata","text":"<pre><code># Query metadata using SQL\nresults = client.query_metadata(\n    \"SELECT * FROM metadata WHERE category = 'test' ORDER BY score DESC LIMIT 10\"\n)\n\nfor result in results:\n    print(result)\n</code></pre>"},{"location":"api-reference/#administration","title":"Administration","text":""},{"location":"api-reference/#backup_2","title":"Backup","text":"<pre><code># Create a backup\nbackup_info = client.backup(\n    path=\"/path/to/backup\",\n    incremental=False,\n    compress=True\n)\n\nprint(f\"Backup created at {backup_info['path']}, size: {backup_info['size_bytes']} bytes\")\n</code></pre>"},{"location":"api-reference/#restore_2","title":"Restore","text":"<pre><code># Restore from a backup\nrestore_info = client.restore(\"/path/to/backup.zip\")\n\nprint(f\"Restored {restore_info['vector_count']} vectors\")\n</code></pre>"},{"location":"api-reference/#get-metrics_1","title":"Get Metrics","text":"<pre><code># Get performance metrics\nmetrics = client.metrics()\n\nprint(f\"Vector count: {metrics['vector_count']}\")\nprint(f\"Memory usage: {metrics['memory_usage_mb']} MB\")\nprint(f\"Search latency: {metrics['search_latency_ms']} ms\")\n</code></pre>"},{"location":"api-reference/#error-handling","title":"Error Handling","text":"<p>All API functions return errors that should be handled appropriately:</p>"},{"location":"api-reference/#go-library","title":"Go Library","text":"<pre><code>result, err := idx.Search(query, 10, 1, 10)\nif err != nil {\n    if errors.Is(err, quiver.ErrDimensionMismatch) {\n        // Handle dimension mismatch\n    } else if errors.Is(err, quiver.ErrInvalidID) {\n        // Handle invalid ID\n    } else {\n        // Handle other errors\n    }\n}\n</code></pre>"},{"location":"api-reference/#http-api_1","title":"HTTP API","text":"<p>HTTP API errors are returned with appropriate status codes and error messages:</p> <pre><code>{\n  \"error\": {\n    \"code\": \"dimension_mismatch\",\n    \"message\": \"Vector dimension mismatch: expected 128, got 64\"\n  }\n}\n</code></pre>"},{"location":"api-reference/#python-client","title":"Python Client","text":"<pre><code>try:\n    results = client.search(vector, k=10)\nexcept quiver.DimensionMismatchError:\n    # Handle dimension mismatch\nexcept quiver.InvalidIDError:\n    # Handle invalid ID\nexcept quiver.QuiverError as e:\n    # Handle other errors\n    print(f\"Error: {e}\")\n</code></pre>"},{"location":"api-reference/#next-steps","title":"Next Steps","text":"<p>Now that you're familiar with the Quiver API, check out:</p> <ul> <li>Quick Start - Get started with Quiver</li> <li>Examples - See practical examples of using Quiver</li> <li>Performance Tuning - Optimize Quiver for your needs</li> </ul>"},{"location":"api-reference/#quiver-class","title":"Quiver Class","text":""},{"location":"api-reference/#constructor","title":"Constructor","text":"<pre><code>Quiver(\n    dimension: int,\n    storage_path: str = \":memory:\",\n    distance: str = \"cosine\",\n    max_elements: int = 1000000,\n    hnsw_m: int = 16,\n    hnsw_ef_construct: int = 200,\n    hnsw_ef_search: int = 100,\n    batch_size: int = 1000,\n    persist_interval: str = \"5m\",\n    backup_interval: str = \"1h\",\n    backup_path: str = None,\n    backup_compression: bool = True,\n    max_backups: int = 5,\n    encryption_enabled: bool = False,\n    encryption_key: str = \"\",\n    enable_dim_reduction: bool = False,\n    dim_reduction_method: str = \"PCA\",\n    dim_reduction_target: int = None,\n    dim_reduction_adaptive: bool = False,\n    dim_reduction_min_variance: float = 0.95,\n)\n</code></pre> <p>Creates a new Quiver instance.</p> <p>Parameters:</p> <ul> <li><code>dimension</code> (int): Dimension of the vectors.</li> <li><code>storage_path</code> (str, optional): Path to store the index files. Defaults to \":memory:\".</li> <li><code>distance</code> (str, optional): Distance metric to use. Either \"cosine\" or \"l2\". Defaults to \"cosine\".</li> <li><code>max_elements</code> (int, optional): Maximum number of vectors to store. Defaults to 1000000.</li> <li><code>hnsw_m</code> (int, optional): HNSW hyperparameter M. Defaults to 16.</li> <li><code>hnsw_ef_construct</code> (int, optional): HNSW hyperparameter efConstruction. Defaults to 200.</li> <li><code>hnsw_ef_search</code> (int, optional): HNSW hyperparameter ef used during queries. Defaults to 100.</li> <li><code>batch_size</code> (int, optional): Number of vectors to batch before insertion. Defaults to 1000.</li> <li><code>persist_interval</code> (str, optional): How often to persist index to disk. Defaults to \"5m\".</li> <li><code>backup_interval</code> (str, optional): How often to create backups. Defaults to \"1h\".</li> <li><code>backup_path</code> (str, optional): Path to store backups. Defaults to None.</li> <li><code>backup_compression</code> (bool, optional): Whether to compress backups. Defaults to True.</li> <li><code>max_backups</code> (int, optional): Maximum number of backups to keep. Defaults to 5.</li> <li><code>encryption_enabled</code> (bool, optional): Whether to encrypt data at rest. Defaults to False.</li> <li><code>encryption_key</code> (str, optional): Key for encrypting data at rest. Defaults to \"\".</li> <li><code>enable_dim_reduction</code> (bool, optional): Whether to enable dimensionality reduction. Defaults to False.</li> <li><code>dim_reduction_method</code> (str, optional): Method to use for dimensionality reduction. Either \"PCA\", \"TSNE\", or \"UMAP\". Defaults to \"PCA\".</li> <li><code>dim_reduction_target</code> (int, optional): Target dimension for reduction. Defaults to dimension/2.</li> <li><code>dim_reduction_adaptive</code> (bool, optional): Whether to use adaptive dimensionality reduction. Defaults to False.</li> <li><code>dim_reduction_min_variance</code> (float, optional): Minimum variance to explain (0.0-1.0) for adaptive reduction. Defaults to 0.95.</li> </ul> <p>Returns:</p> <ul> <li>A new Quiver instance.</li> </ul> <p>Example:</p> <pre><code>from quiver import Quiver\n\n# Create a new Quiver instance with dimensionality reduction\nindex = Quiver(\n    dimension=1536,\n    storage_path=\"path/to/index\",\n    distance=\"cosine\",\n    enable_dim_reduction=True,\n    dim_reduction_method=\"PCA\",\n    dim_reduction_target=768,\n)\n</code></pre>"},{"location":"api-reference/#methods","title":"Methods","text":""},{"location":"api-reference/#add_1","title":"add","text":"<pre><code>add(\n    id: int,\n    vector: List[float],\n    metadata: Dict[str, Any] = None\n) -&gt; None\n</code></pre> <p>Adds a vector to the index.</p> <p>Parameters:</p> <ul> <li><code>id</code> (int): Unique identifier for the vector.</li> <li><code>vector</code> (List[float]): Vector to add. If dimensionality reduction is enabled, this will be automatically reduced.</li> <li><code>metadata</code> (Dict[str, Any], optional): Metadata to associate with the vector. Defaults to None.</li> </ul> <p>Returns:</p> <ul> <li>None</li> </ul> <p>Example:</p> <pre><code># Add a vector to the index\nindex.add(\n    id=1,\n    vector=[0.1, 0.2, 0.3, ...],\n    metadata={\"text\": \"Example document\", \"category\": \"news\"}\n)\n</code></pre>"},{"location":"api-reference/#reduce_vectors","title":"reduce_vectors","text":"<pre><code>reduce_vectors(\n    vectors: List[List[float]]\n) -&gt; List[List[float]]\n</code></pre> <p>Reduces the dimensionality of vectors without adding them to the index.</p> <p>Parameters:</p> <ul> <li><code>vectors</code> (List[List[float]]): Vectors to reduce.</li> </ul> <p>Returns:</p> <ul> <li>List[List[float]]: Reduced vectors.</li> </ul> <p>Example:</p> <pre><code># Reduce vectors without adding them to the index\noriginal_vectors = [\n    [0.1, 0.2, 0.3, ...],  # 1536-dimensional vectors\n    [0.4, 0.5, 0.6, ...],\n]\nreduced_vectors = index.reduce_vectors(original_vectors)\n# reduced_vectors will be lower-dimensional\n</code></pre> <p>Note:</p> <ul> <li>This method is only available if dimensionality reduction is enabled.</li> <li>The reduction uses the same method and parameters as configured for the index.</li> </ul>"},{"location":"changelog/","title":"Changelog","text":"<p>All notable changes to Quiver will be documented in this file. The format is based on Keep a Changelog, and this project adheres to Semantic Versioning.</p>"},{"location":"changelog/#unreleased","title":"[Unreleased]","text":""},{"location":"changelog/#added","title":"Added","text":"<ul> <li>Support for custom distance functions</li> <li>Improved error handling for DuckDB operations</li> <li>Additional benchmarks for hybrid search</li> </ul>"},{"location":"changelog/#fixed","title":"Fixed","text":"<ul> <li>Memory leak in batch processing</li> <li>Race condition in concurrent searches</li> </ul>"},{"location":"changelog/#100-2025-01-15","title":"[1.0.0] - 2025-01-15","text":""},{"location":"changelog/#added_1","title":"Added","text":"<ul> <li>Initial release of Quiver! \ud83c\udf89</li> <li>HNSW-based vector search</li> <li>DuckDB integration for metadata storage</li> <li>Hybrid search (vector + metadata)</li> <li>Search with negative examples</li> <li>Faceted search</li> <li>Multi-vector search</li> <li>Batch processing for vector additions</li> <li>Persistence and recovery</li> <li>Backup and restore functionality</li> <li>Encryption for data at rest</li> <li>HTTP API with Fiber</li> <li>Comprehensive documentation</li> <li>Benchmarks</li> </ul>"},{"location":"changelog/#090-2024-12-10","title":"[0.9.0] - 2024-12-10","text":""},{"location":"changelog/#added_2","title":"Added","text":"<ul> <li>Beta release for early adopters</li> <li>All core functionality implemented</li> <li>Performance optimizations</li> <li>Comprehensive test suite</li> </ul>"},{"location":"changelog/#known-issues","title":"Known Issues","text":"<ul> <li>Some edge cases in hybrid search not fully handled</li> <li>Documentation needs improvement</li> </ul>"},{"location":"changelog/#080-2024-11-15","title":"[0.8.0] - 2024-11-15","text":""},{"location":"changelog/#added_3","title":"Added","text":"<ul> <li>Alpha release for internal testing</li> <li>Basic vector search functionality</li> <li>Simple metadata storage</li> <li>Preliminary API</li> </ul>"},{"location":"changelog/#how-to-upgrade","title":"How to Upgrade","text":""},{"location":"changelog/#upgrading-from-09x-to-100","title":"Upgrading from 0.9.x to 1.0.0","text":"<ol> <li>Update your Go dependencies:</li> </ol> <pre><code>go get -u github.com/TFMV/quiver@v1.0.0\n</code></pre> <ol> <li>Update your code to use the new API:</li> </ol> <pre><code>// Old API\nidx, err := quiver.New(config)\n\n// New API\nlogger, _ := zap.NewDevelopment()\nidx, err := quiver.New(config, logger)\n</code></pre> <ol> <li>Migrate your data:</li> </ol> <pre><code>// Load from old format\noldIdx, _ := quiver.LoadLegacy(\"./old_data\")\n\n// Save in new format\noldIdx.Save(\"./new_data\")\n\n// Load with new API\nnewIdx, _ := quiver.Load(config, logger)\n</code></pre>"},{"location":"changelog/#upgrading-from-08x-to-090","title":"Upgrading from 0.8.x to 0.9.0","text":"<ol> <li>Update your Go dependencies:</li> </ol> <pre><code>go get -u github.com/TFMV/quiver@v0.9.0\n</code></pre> <ol> <li>Rebuild your index (data format changed):</li> </ol> <pre><code>// No automatic migration available\n// You'll need to rebuild your index\n</code></pre>"},{"location":"changelog/#release-schedule","title":"Release Schedule","text":"Version Expected Date Focus 1.1.0 2025-03-15 Performance improvements, additional distance metrics 1.2.0 2025-05-15 Enhanced backup strategies, cloud storage integration 1.3.0 2025-07-15 Distributed search, sharding capabilities 2.0.0 2025-10-15 Major architecture improvements, new search algorithms"},{"location":"configuration/","title":"Configuration","text":"<p>Time to fine-tune your vector database! This guide will walk you through all the configuration options available in Quiver, helping you optimize for your specific use case. Let's make those vectors sing! \ud83c\udfb5</p>"},{"location":"configuration/#configuration-overview","title":"Configuration Overview","text":"<p>Quiver offers a wide range of configuration options to customize its behavior. These options control everything from basic settings like vector dimensions to advanced features like encryption and backup strategies.</p>"},{"location":"configuration/#configuration-options","title":"Configuration Options","text":"<p>Quiver provides a variety of configuration options to customize the behavior of the vector database.</p>"},{"location":"configuration/#basic-configuration","title":"Basic Configuration","text":"Option Description Default <code>dimension</code> Dimension of the vectors Required <code>storage_path</code> Path to store the index files Required <code>distance</code> Distance metric to use (<code>cosine</code> or <code>l2</code>) <code>cosine</code> <code>max_elements</code> Maximum number of vectors to store <code>1000000</code> <code>hnsw_m</code> HNSW hyperparameter M (number of connections per node) <code>16</code> <code>hnsw_ef_construct</code> HNSW hyperparameter efConstruction (size of the dynamic candidate list during construction) <code>200</code> <code>hnsw_ef_search</code> HNSW hyperparameter ef (size of the dynamic candidate list during search) <code>100</code> <code>batch_size</code> Number of vectors to batch before insertion <code>1000</code>"},{"location":"configuration/#persistence-configuration","title":"Persistence Configuration","text":"Option Description Default <code>persist_interval</code> How often to persist index to disk <code>5m</code>"},{"location":"configuration/#backup-configuration","title":"Backup Configuration","text":"Option Description Default <code>backup_interval</code> How often to create backups <code>1h</code> <code>backup_path</code> Path to store backups <code>{storage_path}/backups</code> <code>backup_compression</code> Whether to compress backups <code>true</code> <code>max_backups</code> Maximum number of backups to keep <code>5</code>"},{"location":"configuration/#security-configuration","title":"Security Configuration","text":"Option Description Default <code>encryption_enabled</code> Whether to encrypt data at rest <code>false</code> <code>encryption_key</code> Key for encrypting data at rest (min 32 bytes) <code>\"\"</code>"},{"location":"configuration/#dimensionality-reduction-configuration","title":"Dimensionality Reduction Configuration","text":"Option Description Default <code>enable_dim_reduction</code> Whether to enable dimensionality reduction <code>false</code> <code>dim_reduction_method</code> Method to use for dimensionality reduction (<code>PCA</code>, <code>TSNE</code>, <code>UMAP</code>) <code>PCA</code> <code>dim_reduction_target</code> Target dimension for reduction <code>dimension / 2</code> <code>dim_reduction_adaptive</code> Whether to use adaptive dimensionality reduction <code>false</code> <code>dim_reduction_min_variance</code> Minimum variance to explain (0.0-1.0) for adaptive reduction <code>0.95</code>"},{"location":"configuration/#configuration-examples","title":"Configuration Examples","text":""},{"location":"configuration/#minimal-configuration","title":"Minimal Configuration","text":"<p>The simplest configuration with just the required parameters:</p> <pre><code>config := quiver.Config{\n    Dimension: 128,\n    StoragePath: \"/path/to/quiver.db\",\n}\n</code></pre>"},{"location":"configuration/#in-memory-configuration","title":"In-Memory Configuration","text":"<p>For maximum performance with no persistence:</p> <pre><code>config := quiver.Config{\n    Dimension: 128,\n    StoragePath: \":memory:\",\n    HNSWM: 16,\n    HNSWEfSearch: 100,\n}\n</code></pre>"},{"location":"configuration/#high-throughput-configuration","title":"High-Throughput Configuration","text":"<p>Optimized for adding vectors quickly:</p> <pre><code>config := quiver.Config{\n    Dimension: 128,\n    StoragePath: \"/path/to/quiver.db\",\n    BatchSize: 5000,\n    PersistInterval: 10 * time.Minute,\n}\n</code></pre>"},{"location":"configuration/#high-accuracy-configuration","title":"High-Accuracy Configuration","text":"<p>Optimized for search accuracy:</p> <pre><code>config := quiver.Config{\n    Dimension: 128,\n    StoragePath: \"/path/to/quiver.db\",\n    HNSWM: 32,\n    HNSWEfConstruct: 300,\n    HNSWEfSearch: 200,\n}\n</code></pre>"},{"location":"configuration/#production-ready-configuration","title":"Production-Ready Configuration","text":"<p>A balanced configuration for production use:</p> <pre><code>config := quiver.Config{\n    Dimension: 128,\n    StoragePath: \"/path/to/quiver.db\",\n    Distance: quiver.Cosine,\n    MaxElements: 10000000,\n    HNSWM: 16,\n    HNSWEfConstruct: 200,\n    HNSWEfSearch: 100,\n    BatchSize: 1000,\n    PersistInterval: 5 * time.Minute,\n    BackupInterval: 1 * time.Hour,\n    BackupPath: \"/path/to/backups\",\n    BackupCompression: true,\n    MaxBackups: 7,\n    EncryptionEnabled: true,\n    EncryptionKey: \"your-32-byte-encryption-key-here\",\n}\n</code></pre>"},{"location":"configuration/#environment-variables","title":"Environment Variables","text":"<p>When using the HTTP server, you can configure Quiver using environment variables:</p> Environment Variable Corresponding Config Example <code>QUIVER_DIMENSION</code> <code>Dimension</code> <code>QUIVER_DIMENSION=128</code> <code>QUIVER_STORAGE_PATH</code> <code>StoragePath</code> <code>QUIVER_STORAGE_PATH=/data/quiver.db</code> <code>QUIVER_DISTANCE</code> <code>Distance</code> <code>QUIVER_DISTANCE=cosine</code> <code>QUIVER_MAX_ELEMENTS</code> <code>MaxElements</code> <code>QUIVER_MAX_ELEMENTS=1000000</code> <code>QUIVER_HNSW_M</code> <code>HNSWM</code> <code>QUIVER_HNSW_M=16</code> <code>QUIVER_HNSW_EF_CONSTRUCT</code> <code>HNSWEfConstruct</code> <code>QUIVER_HNSW_EF_CONSTRUCT=200</code> <code>QUIVER_HNSW_EF_SEARCH</code> <code>HNSWEfSearch</code> <code>QUIVER_HNSW_EF_SEARCH=100</code> <code>QUIVER_BATCH_SIZE</code> <code>BatchSize</code> <code>QUIVER_BATCH_SIZE=1000</code> <code>QUIVER_PERSIST_INTERVAL</code> <code>PersistInterval</code> <code>QUIVER_PERSIST_INTERVAL=5m</code> <code>QUIVER_BACKUP_INTERVAL</code> <code>BackupInterval</code> <code>QUIVER_BACKUP_INTERVAL=1h</code> <code>QUIVER_BACKUP_PATH</code> <code>BackupPath</code> <code>QUIVER_BACKUP_PATH=/backups</code> <code>QUIVER_BACKUP_COMPRESSION</code> <code>BackupCompression</code> <code>QUIVER_BACKUP_COMPRESSION=true</code> <code>QUIVER_MAX_BACKUPS</code> <code>MaxBackups</code> <code>QUIVER_MAX_BACKUPS=5</code> <code>QUIVER_ENCRYPTION_ENABLED</code> <code>EncryptionEnabled</code> <code>QUIVER_ENCRYPTION_ENABLED=true</code> <code>QUIVER_ENCRYPTION_KEY</code> <code>EncryptionKey</code> <code>QUIVER_ENCRYPTION_KEY=your-key</code> <code>QUIVER_API_KEY</code> Server API key <code>QUIVER_API_KEY=your-api-key</code> <code>QUIVER_PORT</code> Server port <code>QUIVER_PORT=8080</code>"},{"location":"configuration/#docker-configuration","title":"Docker Configuration","text":"<p>When using the Docker image, you can configure Quiver using environment variables:</p> <pre><code>docker run -p 8080:8080 \\\n  -v /path/to/data:/data \\\n  -e QUIVER_DIMENSION=128 \\\n  -e QUIVER_STORAGE_PATH=/data/quiver.db \\\n  -e QUIVER_API_KEY=your-secret-key \\\n  weaviate/quiver:latest\n</code></pre>"},{"location":"configuration/#configuration-file","title":"Configuration File","text":"<p>You can also load configuration from a JSON file:</p> <pre><code>{\n  \"dimension\": 128,\n  \"storage_path\": \"/path/to/quiver.db\",\n  \"distance\": \"cosine\",\n  \"max_elements\": 1000000,\n  \"hnsw_m\": 16,\n  \"hnsw_ef_construct\": 200,\n  \"hnsw_ef_search\": 100,\n  \"batch_size\": 1000,\n  \"persist_interval\": \"5m\",\n  \"backup_interval\": \"1h\",\n  \"backup_path\": \"/path/to/backups\",\n  \"backup_compression\": true,\n  \"max_backups\": 5,\n  \"encryption_enabled\": true,\n  \"encryption_key\": \"your-32-byte-encryption-key-here\",\n  \"enable_dim_reduction\": true,\n  \"dim_reduction_method\": \"PCA\",\n  \"dim_reduction_target\": 64,\n  \"dim_reduction_adaptive\": true,\n  \"dim_reduction_min_variance\": 0.95\n}\n</code></pre> <p>Load the configuration file in Go:</p> <pre><code>configBytes, err := os.ReadFile(\"config.json\")\nif err != nil {\n    log.Fatalf(\"Failed to read config file: %v\", err)\n}\n\nvar config quiver.Config\nif err := json.Unmarshal(configBytes, &amp;config); err != nil {\n    log.Fatalf(\"Failed to parse config: %v\", err)\n}\n\nidx, err := quiver.New(config, logger)\nif err != nil {\n    log.Fatalf(\"Failed to create index: %v\", err)\n}\n</code></pre>"},{"location":"configuration/#python-client-configuration","title":"Python Client Configuration","text":"<p>When using the Python client, you can configure the connection:</p> <pre><code>from quiver import Client\n\n# Connect to a local Quiver server\nclient = Client(\n    url=\"http://localhost:8080\",\n    api_key=\"your-api-key\",\n    timeout=30,  # Request timeout in seconds\n    retries=3    # Number of retries for failed requests\n)\n</code></pre>"},{"location":"configuration/#next-steps","title":"Next Steps","text":"<p>Now that you've configured Quiver, check out:</p> <ul> <li>Quick Start - Start using Quiver</li> <li>Performance Tuning - Fine-tune Quiver's performance</li> <li>Benchmarking - Measure Quiver's performance</li> </ul>"},{"location":"contributing/","title":"Contributing to Quiver","text":"<p>Want to help make Quiver even better? We'd love your contributions! This guide will help you get started with the development process. \ud83d\ude80</p>"},{"location":"contributing/#getting-started","title":"Getting Started","text":""},{"location":"contributing/#prerequisites","title":"Prerequisites","text":"<p>Before you begin, make sure you have:</p> <ul> <li>Go 1.18 or later</li> <li>Git</li> <li>A C compiler (for DuckDB integration)</li> <li>Your favorite code editor</li> </ul>"},{"location":"contributing/#setting-up-the-development-environment","title":"Setting Up the Development Environment","text":"<ol> <li>Fork the repository on GitHub</li> <li>Clone your fork:</li> </ol> <pre><code>git clone https://github.com/TFMV/quiver.git\ncd quiver\n</code></pre> <ol> <li>Add the upstream repository:</li> </ol> <pre><code>git remote add upstream https://github.com/TFMV/quiver.git\n</code></pre> <ol> <li>Install dependencies:</li> </ol> <pre><code>go mod download\n</code></pre>"},{"location":"contributing/#development-workflow","title":"Development Workflow","text":""},{"location":"contributing/#creating-a-branch","title":"Creating a Branch","text":"<p>Create a new branch for your feature or bugfix:</p> <pre><code>git checkout -b feature/your-feature-name\n</code></pre> <p>Use a descriptive name that reflects what you're working on.</p>"},{"location":"contributing/#making-changes","title":"Making Changes","text":"<ol> <li>Make your changes to the codebase</li> <li>Write or update tests for your changes</li> <li>Run the tests to make sure everything passes:</li> </ol> <pre><code>go test ./...\n</code></pre> <ol> <li>Run the benchmarks to ensure performance is maintained:</li> </ol> <pre><code>go test -bench=. -benchmem ./...\n</code></pre>"},{"location":"contributing/#coding-standards","title":"Coding Standards","text":"<p>We follow standard Go coding conventions:</p> <ul> <li>Use <code>gofmt</code> to format your code</li> <li>Follow the Go Code Review Comments</li> <li>Write clear, concise comments</li> <li>Add documentation for public functions</li> </ul>"},{"location":"contributing/#commit-messages","title":"Commit Messages","text":"<p>Write clear, concise commit messages that explain your changes:</p> <pre><code>feat: Add support for custom distance functions\n\nThis commit adds the ability for users to define and use custom\ndistance functions for vector similarity calculations.\n</code></pre> <p>We follow the Conventional Commits format:</p> <ul> <li><code>feat:</code> for new features</li> <li><code>fix:</code> for bug fixes</li> <li><code>docs:</code> for documentation changes</li> <li><code>test:</code> for changes to tests</li> <li><code>perf:</code> for performance improvements</li> <li><code>refactor:</code> for code refactoring</li> <li><code>chore:</code> for changes to the build process or auxiliary tools</li> </ul>"},{"location":"contributing/#submitting-a-pull-request","title":"Submitting a Pull Request","text":"<ol> <li>Push your branch to your fork:</li> </ol> <pre><code>git push origin feature/your-feature-name\n</code></pre> <ol> <li>Go to the Quiver repository and create a new pull request</li> <li>Provide a clear description of your changes</li> <li>Link any related issues</li> </ol>"},{"location":"contributing/#testing","title":"Testing","text":""},{"location":"contributing/#running-tests","title":"Running Tests","text":"<p>Run the full test suite:</p> <pre><code>go test ./...\n</code></pre> <p>Run tests with verbose output:</p> <pre><code>go test -v ./...\n</code></pre> <p>Run a specific test:</p> <pre><code>go test -v -run TestSearchWithFilter ./...\n</code></pre>"},{"location":"contributing/#running-benchmarks","title":"Running Benchmarks","text":"<p>Run all benchmarks:</p> <pre><code>go test -bench=. -benchmem ./...\n</code></pre> <p>Run a specific benchmark:</p> <pre><code>go test -bench=BenchmarkSearch -benchmem ./...\n</code></pre> <p>Compare benchmark results before and after your changes:</p> <pre><code># Before changes\ngo test -bench=. -benchmem ./... &gt; before.txt\n# After changes\ngo test -bench=. -benchmem ./... &gt; after.txt\n# Compare\nbenchstat before.txt after.txt\n</code></pre>"},{"location":"contributing/#documentation","title":"Documentation","text":""},{"location":"contributing/#updating-documentation","title":"Updating Documentation","text":"<p>If you're adding new features or changing existing ones, please update the documentation:</p> <ol> <li>Update the relevant markdown files in the <code>docs/</code> directory</li> <li>Update code comments, especially for exported functions</li> <li>Add examples if appropriate</li> </ol>"},{"location":"contributing/#building-the-documentation","title":"Building the Documentation","text":"<p>Build the documentation site:</p> <pre><code>cd docs\nmkdocs build\n</code></pre> <p>Preview the documentation locally:</p> <pre><code>cd docs\nmkdocs serve\n</code></pre> <p>Then open http://localhost:8000 in your browser.</p>"},{"location":"contributing/#getting-help","title":"Getting Help","text":"<p>If you need help or have questions:</p> <ul> <li>Open an issue on GitHub</li> <li>Join our community discussions</li> <li>Reach out to the maintainers</li> </ul>"},{"location":"contributing/#code-of-conduct","title":"Code of Conduct","text":"<p>Please note that this project is released with a Contributor Code of Conduct. By participating in this project you agree to abide by its terms.</p>"},{"location":"contributing/#license","title":"License","text":"<p>By contributing to Quiver, you agree that your contributions will be licensed under the project's MIT License.</p>"},{"location":"contributing/#thank-you","title":"Thank You","text":"<p>Your contributions make Quiver better for everyone. We appreciate your time and effort! \ud83d\ude4f</p>"},{"location":"advanced/architecture/","title":"Architecture","text":"<p>Ever wonder what makes Quiver tick? Let's pop the hood and take a look at the inner workings of this blazing-fast vector database! This guide will walk you through Quiver's architecture, components, and design decisions. Time to get technical! \ud83d\udd27</p>"},{"location":"advanced/architecture/#high-level-overview","title":"High-Level Overview","text":"<p>Quiver is designed with a focus on performance, simplicity, and reliability. Here's a bird's-eye view of the architecture:</p> <p></p>"},{"location":"advanced/architecture/#core-components","title":"Core Components","text":""},{"location":"advanced/architecture/#hnsw-graph","title":"HNSW Graph","text":"<p>The heart of Quiver is the Hierarchical Navigable Small World (HNSW) graph, which enables lightning-fast approximate nearest neighbor search:</p> <ul> <li>Implementation: Quiver uses a highly optimized HNSW implementation</li> <li>Parameters: Configurable <code>M</code> (max connections), <code>efConstruction</code> (build quality), and <code>efSearch</code> (search quality)</li> <li>Distance Metrics: Supports Cosine and L2 (Euclidean) distance</li> </ul> <pre><code>type Index struct {\n    // ...\n    hnsw *hnsw.Graph[uint64]\n    // ...\n}\n</code></pre>"},{"location":"advanced/architecture/#vector-storage","title":"Vector Storage","text":"<p>Vectors are stored in memory for fast access during search operations:</p> <ul> <li>In-memory Map: Vectors are stored in a map with vector IDs as keys</li> <li>Float32 Precision: Vectors use 32-bit floats for a good balance of precision and memory usage</li> <li>Concurrent Access: Protected by read-write locks for thread safety</li> </ul> <pre><code>type Index struct {\n    // ...\n    vectors map[uint64][]float32\n    // ...\n}\n</code></pre>"},{"location":"advanced/architecture/#metadata-store","title":"Metadata Store","text":"<p>Metadata is stored in DuckDB, a fast analytical database:</p> <ul> <li>SQL Interface: Enables complex filtering and aggregation</li> <li>Arrow Integration: Efficient data transfer with Apache Arrow</li> <li>Schema Flexibility: Supports various data types for metadata fields</li> </ul> <pre><code>type Index struct {\n    // ...\n    duckdb *DuckDB\n    dbConn *DuckDBConn\n    // ...\n}\n</code></pre>"},{"location":"advanced/architecture/#persistence-backup","title":"Persistence &amp; Backup","text":"<p>Quiver ensures data durability through:</p> <ul> <li>Periodic Persistence: Configurable intervals for writing to disk</li> <li>Incremental Backups: Only changed data is backed up</li> <li>Compression: Optional compression for backups</li> <li>Encryption: Optional encryption for sensitive data</li> </ul> <pre><code>type Index struct {\n    // ...\n    persistInterval time.Duration\n    persistTicker   *time.Ticker\n    persistDone     chan struct{}\n    // ...\n}\n</code></pre>"},{"location":"advanced/architecture/#dimensionality-reduction","title":"Dimensionality Reduction","text":"<p>Quiver includes built-in dimensionality reduction capabilities to optimize storage and search performance:</p> <ul> <li>PCA Implementation: Principal Component Analysis for efficient dimension reduction</li> <li>Adaptive Reduction: Automatically determines optimal dimensions based on data variance</li> <li>Inline Processing: Reduction happens during insertion and query operations</li> <li>Explicit API: Allows reducing vectors without adding them to the index</li> </ul> <pre><code>type Index struct {\n    // ...\n    dimReduction         bool\n    dimReductionMethod   string\n    dimReductionTarget   int\n    dimReductionAdaptive bool\n    dimReductionVariance float64\n    // ...\n}\n</code></pre>"},{"location":"advanced/architecture/#semantic-routing","title":"Semantic Routing","text":"<p>Semantic routing enables intelligent query routing to the most relevant sub-indices:</p> <ul> <li>Multi-Index Support: Route queries to the most appropriate indices</li> <li>Routing Models: Uses lightweight models to determine query destinations</li> <li>Parallel Search: Execute searches in parallel across multiple indices</li> <li>Result Aggregation: Combine and rank results from multiple indices</li> </ul> <pre><code>type Router struct {\n    // ...\n    indices      map[string]*Index\n    routingModel *RoutingModel\n    // ...\n}\n</code></pre>"},{"location":"advanced/architecture/#data-flow","title":"Data Flow","text":""},{"location":"advanced/architecture/#adding-vectors","title":"Adding Vectors","text":"<p>When you add a vector to Quiver, here's what happens:</p> <p>```mermaid sequenceDiagram     participant Client     participant Index     participant DimReduction     participant BatchBuffer     participant HNSW     participant DuckDB</p> <pre><code>Client-&gt;&gt;Index: Add(id, vector, metadata)\nNote over Index: Validate dimensions\n\nalt Dimensionality Reduction Enabled\n    Index-&gt;&gt;DimReduction: Reduce vector dimensions\n    DimReduction--&gt;&gt;Index: Return reduced vector\nend\n\nIndex-&gt;&gt;BatchBuffer: Add to batch\n\nalt Batch is full\n    BatchBuffer-&gt;&gt;HNSW: Add vectors to graph\n    BatchBuffer-&gt;&gt;DuckDB: Store metadata\n    Note over Index: Reset batch buffer\nend\n\nNote over Index: Periodic persistence\n</code></pre> <p>```</p> <ol> <li>Validation: Vector dimension and metadata are validated</li> <li>Dimensionality Reduction: If enabled, vector dimensions are reduced using the configured method</li> <li>Batching: Vector is added to a batch buffer</li> <li>HNSW Insertion: When the batch is full, vectors are added to the HNSW graph</li> <li>Metadata Storage: Metadata is stored in DuckDB</li> <li>Persistence: Data is periodically persisted to disk</li> </ol> <pre><code>func (idx *Index) Add(id uint64, vector []float32, meta map[string]interface{}) error {\n    // Validation\n    if len(vector) != idx.config.Dimension {\n        return fmt.Errorf(\"vector dimension mismatch: expected %d, got %d\", idx.config.Dimension, len(vector))\n    }\n\n    // Dimensionality reduction if enabled\n    if idx.config.EnableDimReduction {\n        vector = idx.reduceVector(vector)\n    }\n\n    // Add to batch buffer\n    idx.batchLock.Lock()\n    idx.batchBuffer = append(idx.batchBuffer, vectorMeta{id, vector, meta})\n    idx.batchLock.Unlock()\n\n    // Flush if batch is full\n    if len(idx.batchBuffer) &gt;= idx.config.BatchSize {\n        return idx.flushBatch()\n    }\n\n    return nil\n}\n</code></pre>"},{"location":"advanced/architecture/#searching-vectors","title":"Searching Vectors","text":"<p>When you search for similar vectors:</p> <p>```mermaid sequenceDiagram     participant Client     participant Index     participant DimReduction     participant HNSW     participant DuckDB</p> <pre><code>Client-&gt;&gt;Index: Search(query, k, page, pageSize)\nNote over Index: Validate query\n\nalt Dimensionality Reduction Enabled\n    Index-&gt;&gt;DimReduction: Reduce query dimensions\n    DimReduction--&gt;&gt;Index: Return reduced query\nend\n\nIndex-&gt;&gt;HNSW: Find nearest neighbors\nHNSW--&gt;&gt;Index: Return neighbor IDs and distances\n\nloop For each result\n    Index-&gt;&gt;DuckDB: Get metadata for ID\n    DuckDB--&gt;&gt;Index: Return metadata\nend\n\nIndex--&gt;&gt;Client: Return search results\n</code></pre> <p>```</p> <ol> <li>Query Preparation: Query vector is validated</li> <li>Dimensionality Reduction: If enabled, query dimensions are reduced using the same method as during insertion</li> <li>HNSW Search: HNSW graph is traversed to find nearest neighbors</li> <li>Distance Calculation: Distances are calculated using the configured metric</li> <li>Metadata Retrieval: Metadata for result vectors is retrieved from DuckDB</li> <li>Result Formatting: Results are formatted and returned</li> </ol> <pre><code>func (idx *Index) Search(query []float32, k, page, pageSize int) ([]SearchResult, error) {\n    // Validation\n    if len(query) != idx.config.Dimension {\n        return nil, fmt.Errorf(\"query dimension mismatch: expected %d, got %d\", idx.config.Dimension, len(query))\n    }\n\n    // Dimensionality reduction if enabled\n    if idx.config.EnableDimReduction {\n        query = idx.reduceVector(query)\n    }\n\n    // HNSW search\n    idx.lock.RLock()\n    neighbors, err := idx.hnsw.Search(query, k, idx.config.HNSWEfSearch)\n    idx.lock.RUnlock()\n\n    // Format results\n    results := make([]SearchResult, len(neighbors))\n    for i, n := range neighbors {\n        results[i] = SearchResult{\n            ID:       n.ID,\n            Distance: n.Distance,\n            Metadata: idx.getMetadata(n.ID),\n        }\n    }\n\n    return results, nil\n}\n</code></pre>"},{"location":"advanced/architecture/#hybrid-search","title":"Hybrid Search","text":"<p>Quiver's hybrid search combines vector similarity with metadata filtering:</p> <p>```mermaid flowchart TD     Start([Start]) \u2192 QueryValidation[Validate query vector]     QueryValidation \u2192 StrategySelection{Select strategy}</p> <pre><code>StrategySelection --&gt;|Filter-then-search| FilterFirst[Execute SQL filter]\nStrategySelection --&gt;|Search-then-filter| SearchFirst[Perform vector search]\n\nFilterFirst --&gt; GetFilteredIDs[Get filtered vector IDs]\nGetFilteredIDs --&gt; SearchSubset[Search among filtered vectors]\n\nSearchFirst --&gt; ApplyFilter[Apply filter to results]\n\nSearchSubset --&gt; FormatResults[Format results]\nApplyFilter --&gt; FormatResults\n\nFormatResults --&gt; End([Return results])\n\nclassDef process fill:#7E57C2,stroke:#4527A0,color:white\nclassDef decision fill:#FFA000,stroke:#FF6F00,color:white\nclassDef io fill:#26A69A,stroke:#00897B,color:white\n\nclass Start,End io\nclass StrategySelection decision\nclass QueryValidation,FilterFirst,GetFilteredIDs,SearchSubset,SearchFirst,ApplyFilter,FormatResults process\n</code></pre> <p>```</p> <ol> <li>Strategy Selection: Choose between filter-then-search or search-then-filter</li> <li>SQL Query: Execute SQL query to filter metadata</li> <li>Vector Search: Search for similar vectors among filtered results</li> <li>Result Combination: Combine vector similarity with metadata filtering</li> </ol> <pre><code>func (idx *Index) SearchWithFilter(query []float32, k int, filter string) ([]SearchResult, error) {\n    // Execute SQL query to get filtered IDs\n    sql := fmt.Sprintf(\"SELECT id FROM metadata WHERE %s\", filter)\n    reader, stmt, _, err := idx.dbConn.Query(context.Background(), sql)\n\n    // Get filtered IDs\n    filteredIDs := make([]uint64, 0)\n    // ... process results ...\n\n    // Search among filtered IDs\n    results, err := idx.searchSubset(query, k, filteredIDs)\n\n    return results, nil\n}\n</code></pre>"},{"location":"advanced/architecture/#semantic-routing-flow","title":"Semantic Routing Flow","text":"<p>When using semantic routing for search across multiple indices:</p> <p>```mermaid sequenceDiagram     participant Client     participant Router     participant RoutingModel     participant IndexA     participant IndexB     participant IndexC</p> <pre><code>Client-&gt;&gt;Router: Search(query, k, options)\nRouter-&gt;&gt;RoutingModel: DetermineTargetIndices(query)\nRoutingModel--&gt;&gt;Router: Return target indices [A, C]\n\npar Search in parallel\n    Router-&gt;&gt;IndexA: Search(query, k)\n    IndexA--&gt;&gt;Router: Return results from A\nand\n    Router-&gt;&gt;IndexC: Search(query, k)\n    IndexC--&gt;&gt;Router: Return results from C\nend\n\nNote over Router: Merge and rank results\nRouter--&gt;&gt;Client: Return combined results\n</code></pre> <p>```</p> <ol> <li>Query Routing: The routing model determines which indices are most relevant for the query</li> <li>Parallel Search: Searches are executed in parallel across the selected indices</li> <li>Result Aggregation: Results from all indices are combined and ranked</li> <li>Response: The final ranked results are returned to the client</li> </ol> <pre><code>func (router *Router) Search(query []float32, k int, options SearchOptions) ([]SearchResult, error) {\n    // Determine target indices\n    targetIndices := router.routingModel.DetermineTargetIndices(query)\n\n    // Execute parallel searches\n    var wg sync.WaitGroup\n    resultChan := make(chan []SearchResult, len(targetIndices))\n    errorChan := make(chan error, len(targetIndices))\n\n    for _, indexName := range targetIndices {\n        wg.Add(1)\n        go func(name string) {\n            defer wg.Done()\n            idx := router.indices[name]\n            results, err := idx.Search(query, k, options)\n            if err != nil {\n                errorChan &lt;- err\n                return\n            }\n            resultChan &lt;- results\n        }(indexName)\n    }\n\n    // Wait for all searches to complete\n    wg.Wait()\n    close(resultChan)\n    close(errorChan)\n\n    // Check for errors\n    if len(errorChan) &gt; 0 {\n        return nil, &lt;-errorChan\n    }\n\n    // Combine and rank results\n    allResults := make([]SearchResult, 0)\n    for results := range resultChan {\n        allResults = append(allResults, results...)\n    }\n\n    // Sort by distance\n    sort.Slice(allResults, func(i, j int) bool {\n        return allResults[i].Distance &lt; allResults[j].Distance\n    })\n\n    // Limit to k results\n    if len(allResults) &gt; k {\n        allResults = allResults[:k]\n    }\n\n    return allResults, nil\n}\n</code></pre>"},{"location":"advanced/architecture/#concurrency-model","title":"Concurrency Model","text":"<p>Quiver uses a combination of locks and channels to manage concurrency:</p> <p>```mermaid classDiagram     class Index {         +lock: sync.RWMutex         +batchLock: sync.Mutex         +cache: sync.Map         +batchTicker: *time.Ticker         +batchDone: chan struct{}         +persistTicker: *time.Ticker         +persistDone: chan struct{}         +backupTicker: *time.Ticker         +backupDone: chan struct{}         +bgWG: sync.WaitGroup     }</p> <pre><code>class BackgroundWorkers {\n    +batchProcessor()\n    +persistenceWorker()\n    +backupWorker()\n}\n\nclass Operations {\n    +Add()\n    +Search()\n    +SearchWithFilter()\n    +Close()\n}\n\nIndex --&gt; BackgroundWorkers : starts\nOperations --&gt; Index : uses\n</code></pre> <p>```</p> <ul> <li>Read-Write Locks: Protect shared data structures during concurrent operations</li> <li>Batch Processing: Asynchronous batch processing for vector additions</li> <li>Background Workers: Separate goroutines for persistence and backup</li> <li>Connection Pool: Managed connections to DuckDB</li> </ul> <pre><code>type Index struct {\n    // ...\n    lock            sync.RWMutex\n    batchLock       sync.Mutex\n    cache           sync.Map\n    batchTicker     *time.Ticker\n    batchDone       chan struct{}\n    persistTicker   *time.Ticker\n    persistDone     chan struct{}\n    backupTicker    *time.Ticker\n    backupDone      chan struct{}\n    bgWG            sync.WaitGroup\n    // ...\n}\n</code></pre>"},{"location":"advanced/architecture/#duckdb-integration","title":"DuckDB Integration","text":"<p>Quiver uses DuckDB for metadata storage and querying:</p> <ul> <li>ADBC Interface: Uses Apache Arrow Database Connectivity for communication</li> <li>Connection Management: Maintains a pool of connections</li> <li>Arrow Record Batches: Efficient data transfer with Arrow record batches</li> <li>SQL Queries: Executes SQL queries for metadata filtering</li> </ul> <pre><code>type DuckDB struct {\n    mu     sync.Mutex\n    db     adbc.Database\n    driver adbc.Driver\n    opts   DuckDBOptions\n    conns  []*DuckDBConn\n}\n\ntype DuckDBConn struct {\n    parent *DuckDB\n    conn   adbc.Connection\n}\n</code></pre>"},{"location":"advanced/architecture/#http-api","title":"HTTP API","text":"<p>Quiver provides a RESTful HTTP API for remote access:</p> <ul> <li>Fiber Framework: Uses the high-performance Fiber web framework</li> <li>JSON Interface: Standard JSON request/response format</li> <li>Authentication: API key authentication for security</li> <li>Middleware: Logging, error handling, and rate limiting middleware</li> <li>Health Checks: Endpoints for monitoring and health checks</li> </ul> <pre><code>type Server struct {\n    app   *fiber.App\n    log   *zap.Logger\n    port  string\n    index *quiver.Index\n}\n</code></pre>"},{"location":"advanced/architecture/#performance-optimizations","title":"Performance Optimizations","text":"<p>Quiver includes several optimizations for maximum performance:</p> <ul> <li>Batch Processing: Vectors are added in batches for better throughput</li> <li>Metadata Caching: Frequently accessed metadata is cached in memory</li> <li>Connection Pooling: DuckDB connections are pooled and reused</li> <li>Concurrent Reads: Multiple read operations can execute in parallel</li> <li>SIMD Instructions: Distance calculations use SIMD instructions when available</li> <li>Memory Mapping: Efficient memory mapping for large indices</li> <li>Dimensionality Reduction: Reduces vector dimensions to improve search speed and memory usage</li> <li>Adaptive Reduction: Automatically determines optimal dimensions based on data variance</li> <li>Semantic Routing: Routes queries to the most relevant indices to reduce search space</li> <li>Parallel Search: Executes searches in parallel across multiple indices</li> </ul>"},{"location":"advanced/architecture/#security-features","title":"Security Features","text":"<p>Quiver includes several security features:</p> <ul> <li>API Key Authentication: Secure access to the HTTP API</li> <li>Encryption at Rest: Optional encryption for stored data</li> <li>TLS Support: HTTPS support for secure communication</li> <li>Input Validation: Thorough validation of all inputs</li> <li>Error Handling: Secure error handling that doesn't leak sensitive information</li> </ul>"},{"location":"advanced/architecture/#configuration-system","title":"Configuration System","text":"<p>Quiver's behavior is controlled through a comprehensive configuration system:</p> <pre><code>type Config struct {\n    Dimension           int\n    StoragePath         string\n    Distance            DistanceMetric\n    MaxElements         uint64\n    HNSWM               int\n    HNSWEfConstruct     int\n    HNSWEfSearch        int\n    BatchSize           int\n    PersistInterval     time.Duration\n    BackupInterval      time.Duration\n    BackupPath          string\n    BackupCompression   bool\n    MaxBackups          int\n    EncryptionEnabled   bool\n    EncryptionKey       string\n    EnableDimReduction  bool\n    DimReductionMethod  string\n    DimReductionTarget  int\n    DimReductionAdaptive bool\n    DimReductionVariance float64\n    EnableSemanticRouting bool\n    RoutingModel        string\n    RoutingThreshold    float64\n}\n</code></pre>"},{"location":"advanced/architecture/#logging-and-monitoring","title":"Logging and Monitoring","text":"<p>Quiver uses structured logging and exposes metrics for monitoring:</p> <ul> <li>Zap Logger: High-performance structured logging</li> <li>Metrics Collection: Collects and exposes performance metrics</li> <li>Query Logging: Optional logging of queries for debugging</li> <li>Health Checks: Endpoints for monitoring system health</li> </ul> <pre><code>func (idx *Index) CollectMetrics() map[string]interface{} {\n    metrics := make(map[string]interface{})\n    metrics[\"vector_count\"] = len(idx.vectors)\n    metrics[\"metadata_count\"] = len(idx.metadata)\n    metrics[\"cache_size\"] = idx.cacheSize()\n    // ... more metrics ...\n    return metrics\n}\n</code></pre>"},{"location":"advanced/architecture/#design-decisions","title":"Design Decisions","text":""},{"location":"advanced/architecture/#why-hnsw","title":"Why HNSW?","text":"<p>HNSW was chosen for Quiver because:</p> <ol> <li>Performance: One of the fastest ANN algorithms available</li> <li>Memory Efficiency: Good balance of memory usage and search speed</li> <li>Quality: High recall even with approximate search</li> <li>Incremental Updates: Supports adding vectors without rebuilding the index</li> </ol>"},{"location":"advanced/architecture/#why-duckdb","title":"Why DuckDB?","text":"<p>DuckDB was chosen for metadata storage because:</p> <ol> <li>Performance: Extremely fast analytical database</li> <li>Embedded: No separate server process required</li> <li>SQL Interface: Familiar and powerful query language</li> <li>Arrow Integration: Efficient data transfer with Arrow</li> </ol>"},{"location":"advanced/architecture/#why-go","title":"Why Go?","text":"<p>Go was chosen as the implementation language because:</p> <ol> <li>Performance: Compiled language with good performance</li> <li>Concurrency: Excellent support for concurrent programming</li> <li>Simplicity: Clean and straightforward language design</li> <li>Tooling: Great tooling for testing, profiling, and deployment</li> </ol>"},{"location":"advanced/architecture/#why-pca-for-dimensionality-reduction","title":"Why PCA for Dimensionality Reduction?","text":"<p>PCA was chosen as the initial dimensionality reduction method because:</p> <ol> <li>Efficiency: Computationally efficient compared to other methods</li> <li>Deterministic: Produces consistent results for the same input</li> <li>Variance Preservation: Maximizes the variance retained in the reduced dimensions</li> <li>Simplicity: Conceptually simple and well-understood algorithm</li> <li>Adaptability: Works well with the adaptive dimensionality approach</li> </ol>"},{"location":"advanced/architecture/#why-semantic-routing","title":"Why Semantic Routing?","text":"<p>Semantic routing was implemented to address the challenges of scaling vector search:</p> <ol> <li>Scalability: Enables efficient search across multiple indices</li> <li>Performance: Reduces the search space by targeting only relevant indices</li> <li>Flexibility: Allows for specialized indices for different types of data</li> <li>Resource Efficiency: Optimizes resource usage by avoiding unnecessary searches</li> </ol>"},{"location":"advanced/architecture/#next-steps","title":"Next Steps","text":"<p>Now that you understand Quiver's architecture, check out:</p> <ul> <li>HNSW Algorithm - Learn more about how HNSW works</li> <li>DuckDB Integration - Understand how Quiver uses DuckDB</li> <li>Performance Tuning - Optimize Quiver for your needs</li> <li>Dimensionality Reduction - Learn about reducing vector dimensions</li> <li>Semantic Routing - Understand how query routing works</li> </ul>"},{"location":"advanced/benchmarking/","title":"Benchmarking","text":"<p>Want to know exactly how fast Quiver can go? Let's dive into benchmarking! This guide will show you how to measure Quiver's performance and compare different configurations. Time to put those vectors to the test! \u23f1\ufe0f</p>"},{"location":"advanced/benchmarking/#why-benchmark","title":"Why Benchmark?","text":"<p>Benchmarking helps you:</p> <ol> <li>Understand Quiver's performance characteristics</li> <li>Compare different configurations</li> <li>Identify bottlenecks</li> <li>Set realistic expectations for production use</li> <li>Track performance improvements over time</li> </ol>"},{"location":"advanced/benchmarking/#built-in-benchmarks","title":"Built-in Benchmarks","text":"<p>Quiver comes with a comprehensive suite of benchmarks that measure various aspects of performance:</p> <pre><code># Run all benchmarks\ngo test -bench=. -benchmem ./...\n\n# Run a specific benchmark\ngo test -bench=BenchmarkSearch -benchmem ./...\n</code></pre>"},{"location":"advanced/benchmarking/#understanding-benchmark-output","title":"Understanding Benchmark Output","text":"<p>Here's an example benchmark output:</p> <pre><code>BenchmarkSearch-10                 20054             59194 ns/op           24193 B/op         439 allocs/op\n</code></pre> <p>This tells you:</p> <ul> <li><code>BenchmarkSearch-10</code>: The benchmark name and number of CPU cores used</li> <li><code>20054</code>: Number of iterations run</li> <li><code>59194 ns/op</code>: Average time per operation (59.2 microseconds)</li> <li><code>24193 B/op</code>: Average memory allocated per operation (24.2 KB)</li> <li><code>439 allocs/op</code>: Average number of allocations per operation</li> </ul>"},{"location":"advanced/benchmarking/#available-benchmarks","title":"Available Benchmarks","text":"<p>Quiver includes the following benchmarks:</p> Benchmark Description <code>BenchmarkAdd</code> Measures vector addition performance <code>BenchmarkSearch</code> Measures basic vector search performance <code>BenchmarkHybridSearch</code> Measures hybrid search (vector + metadata) performance <code>BenchmarkSearchWithNegatives</code> Measures search with negative examples performance <code>BenchmarkBatchAdd</code> Measures batch addition performance with different batch sizes <code>BenchmarkSearchWithDifferentK</code> Measures search performance with different K values <code>BenchmarkSearchWithDifferentDimensions</code> Measures search performance with different vector dimensions"},{"location":"advanced/benchmarking/#running-custom-benchmarks","title":"Running Custom Benchmarks","text":""},{"location":"advanced/benchmarking/#creating-a-benchmark","title":"Creating a Benchmark","text":"<p>You can create custom benchmarks to test specific scenarios:</p> <pre><code>// Example custom benchmark\nfunc BenchmarkCustomSearch(b *testing.B) {\n    // Setup\n    logger, _ := zap.NewNop() // Use a no-op logger for benchmarks\n    idx, _ := quiver.New(quiver.Config{\n        Dimension:   128,\n        StoragePath: \":memory:\",\n        HNSWM:       16,\n        BatchSize:   1000,\n    }, logger)\n    defer idx.Close()\n\n    // Add test vectors\n    for i := 0; i &lt; 10000; i++ {\n        vector := generateRandomVector(128)\n        metadata := map[string]interface{}{\n            \"category\": \"test\",\n            \"id\": i,\n        }\n        idx.Add(uint64(i), vector, metadata)\n    }\n\n    // Create query vector\n    queryVector := generateRandomVector(128)\n\n    // Reset timer before the actual benchmark\n    b.ResetTimer()\n\n    // Run the benchmark\n    for i := 0; i &lt; b.N; i++ {\n        idx.Search(queryVector, 10, 1, 10)\n    }\n}\n</code></pre>"},{"location":"advanced/benchmarking/#benchmark-parameters","title":"Benchmark Parameters","text":"<p>You can customize benchmark parameters:</p> <pre><code># Run for at least 5 seconds per benchmark\ngo test -bench=. -benchtime=5s -benchmem ./...\n\n# Run with a specific number of CPU cores\ngo test -bench=. -cpu=1,4,8 -benchmem ./...\n\n# Run with verbose output\ngo test -bench=. -v -benchmem ./...\n</code></pre>"},{"location":"advanced/benchmarking/#benchmark-scenarios","title":"Benchmark Scenarios","text":""},{"location":"advanced/benchmarking/#vector-addition","title":"Vector Addition","text":"<p>Benchmark vector addition with different batch sizes:</p> <pre><code>func BenchmarkAddWithDifferentBatchSizes(b *testing.B) {\n    batchSizes := []int{100, 1000, 10000}\n\n    for _, batchSize := range batchSizes {\n        b.Run(fmt.Sprintf(\"BatchSize-%d\", batchSize), func(b *testing.B) {\n            // Setup with specific batch size\n            logger, _ := zap.NewNop()\n            idx, _ := quiver.New(quiver.Config{\n                Dimension: 128,\n                StoragePath: \":memory:\",\n                BatchSize: batchSize,\n            }, logger)\n            defer idx.Close()\n\n            // Reset timer\n            b.ResetTimer()\n\n            // Run benchmark\n            for i := 0; i &lt; b.N; i++ {\n                vector := generateRandomVector(128)\n                metadata := map[string]interface{}{\n                    \"category\": \"test\",\n                    \"id\": i,\n                }\n                idx.Add(uint64(i), vector, metadata)\n            }\n        })\n    }\n}\n</code></pre>"},{"location":"advanced/benchmarking/#search-performance","title":"Search Performance","text":"<p>Benchmark search with different HNSW parameters:</p> <pre><code>func BenchmarkSearchWithDifferentEfSearch(b *testing.B) {\n    efValues := []int{50, 100, 200, 400}\n\n    for _, ef := range efValues {\n        b.Run(fmt.Sprintf(\"Ef-%d\", ef), func(b *testing.B) {\n            // Setup with specific efSearch\n            logger, _ := zap.NewNop()\n            idx, _ := quiver.New(quiver.Config{\n                Dimension: 128,\n                StoragePath: \":memory:\",\n                HNSWEfSearch: ef,\n            }, logger)\n            defer idx.Close()\n\n            // Add test vectors\n            for i := 0; i &lt; 10000; i++ {\n                vector := generateRandomVector(128)\n                metadata := map[string]interface{}{\n                    \"category\": \"test\",\n                    \"id\": i,\n                }\n                idx.Add(uint64(i), vector, metadata)\n            }\n\n            // Create query vector\n            queryVector := generateRandomVector(128)\n\n            // Reset timer\n            b.ResetTimer()\n\n            // Run benchmark\n            for i := 0; i &lt; b.N; i++ {\n                idx.Search(queryVector, 10, 1, 10)\n            }\n        })\n    }\n}\n</code></pre>"},{"location":"advanced/benchmarking/#hybrid-search","title":"Hybrid Search","text":"<p>Benchmark hybrid search with different filter selectivity:</p> <pre><code>func BenchmarkHybridSearchWithDifferentFilters(b *testing.B) {\n    filters := []struct{\n        name string\n        filter string\n        selectivity string\n    }{\n        {\"HighlySelective\", \"id &lt; 100\", \"1%\"},\n        {\"MediumSelective\", \"id &lt; 1000\", \"10%\"},\n        {\"LowSelective\", \"id &lt; 5000\", \"50%\"},\n    }\n\n    for _, f := range filters {\n        b.Run(fmt.Sprintf(\"%s-%s\", f.name, f.selectivity), func(b *testing.B) {\n            // Setup\n            logger, _ := zap.NewNop()\n            idx, _ := quiver.New(quiver.Config{\n                Dimension: 128,\n                StoragePath: \":memory:\",\n            }, logger)\n            defer idx.Close()\n\n            // Add test vectors\n            for i := 0; i &lt; 10000; i++ {\n                vector := generateRandomVector(128)\n                metadata := map[string]interface{}{\n                    \"category\": \"test\",\n                    \"id\": i,\n                }\n                idx.Add(uint64(i), vector, metadata)\n            }\n\n            // Create query vector\n            queryVector := generateRandomVector(128)\n\n            // Reset timer\n            b.ResetTimer()\n\n            // Run benchmark\n            for i := 0; i &lt; b.N; i++ {\n                idx.SearchWithFilter(queryVector, 10, f.filter)\n            }\n        })\n    }\n}\n</code></pre>"},{"location":"advanced/benchmarking/#comparing-results","title":"Comparing Results","text":""},{"location":"advanced/benchmarking/#using-benchstat","title":"Using benchstat","text":"<p>The <code>benchstat</code> tool helps compare benchmark results:</p> <pre><code># Install benchstat\ngo install golang.org/x/perf/cmd/benchstat@latest\n\n# Run benchmarks before changes\ngo test -bench=. -benchmem ./... &gt; before.txt\n\n# Run benchmarks after changes\ngo test -bench=. -benchmem ./... &gt; after.txt\n\n# Compare results\nbenchstat before.txt after.txt\n</code></pre> <p>Example output:</p> <pre><code>name                old time/op    new time/op    delta\nSearch-10             59.2\u00b5s \u00b1 2%    52.1\u00b5s \u00b1 3%  -12.00%  (p=0.000 n=10+10)\nHybridSearch-10       208\u00b5s \u00b1 5%     187\u00b5s \u00b1 4%   -10.10%  (p=0.000 n=10+10)\n\nname                old alloc/op   new alloc/op   delta\nSearch-10             24.2kB \u00b1 0%    22.1kB \u00b1 0%   -8.68%  (p=0.000 n=10+10)\nHybridSearch-10       80.6kB \u00b1 0%    75.2kB \u00b1 0%   -6.70%  (p=0.000 n=10+10)\n\nname                old allocs/op  new allocs/op  delta\nSearch-10               439 \u00b1 0%       412 \u00b1 0%    -6.15%  (p=0.000 n=10+10)\nHybridSearch-10         822 \u00b1 0%       798 \u00b1 0%    -2.92%  (p=0.000 n=10+10)\n</code></pre> <p>This shows the performance change between the old and new versions.</p>"},{"location":"advanced/benchmarking/#visualizing-results","title":"Visualizing Results","text":"<p>You can visualize benchmark results using tools like:</p> <ul> <li>benchviz</li> <li>benchgraph</li> <li>Custom plotting with Python/matplotlib</li> </ul> <p>Example Python script for plotting:</p> <pre><code>import matplotlib.pyplot as plt\nimport pandas as pd\nimport re\n\n# Parse benchmark output\ndef parse_benchmark(filename):\n    data = []\n    with open(filename, 'r') as f:\n        for line in f:\n            if line.startswith('Benchmark'):\n                parts = re.split(r'\\s+', line.strip())\n                name = parts[0]\n                ops = int(parts[1])\n                ns_per_op = float(parts[2])\n                mb_per_op = float(parts[3]) / 1024 / 1024\n                allocs_per_op = int(parts[4])\n                data.append({\n                    'name': name,\n                    'ops': ops,\n                    'ns_per_op': ns_per_op,\n                    'mb_per_op': mb_per_op,\n                    'allocs_per_op': allocs_per_op\n                })\n    return pd.DataFrame(data)\n\n# Load data\ndf = parse_benchmark('benchmark_results.txt')\n\n# Plot\nplt.figure(figsize=(12, 6))\nplt.bar(df['name'], df['ns_per_op'] / 1000)  # Convert to microseconds\nplt.ylabel('Time per operation (\u00b5s)')\nplt.xticks(rotation=45, ha='right')\nplt.title('Quiver Benchmark Performance')\nplt.tight_layout()\nplt.savefig('benchmark_performance.png')\n</code></pre>"},{"location":"advanced/benchmarking/#real-world-benchmarks","title":"Real-world Benchmarks","text":"<p>Here are some real-world benchmark results from Quiver running on an M2 Pro CPU:</p>"},{"location":"advanced/benchmarking/#basic-operations","title":"Basic Operations","text":"Operation Throughput Latency Memory/Op Allocs/Op Add 6.4K ops/sec 156\u00b5s 20.9 KB 370 Search 16.9K ops/sec 59\u00b5s 24.2 KB 439 Hybrid Search 4.8K ops/sec 208\u00b5s 80.6 KB 822 Search with Negatives 7.9K ops/sec 126\u00b5s 32.5 KB 491"},{"location":"advanced/benchmarking/#batch-performance","title":"Batch Performance","text":"Batch Size Throughput Latency Memory/Op Allocs/Op 100 63 batches/sec 15.8ms 2.0 MB 35.8K 1000 6.6 batches/sec 152ms 19.0 MB 331K 10000 0.64 batches/sec 1.57s 208 MB 3.7M"},{"location":"advanced/benchmarking/#search-with-different-k-values","title":"Search with Different K Values","text":"K Value Throughput Latency Memory/Op Allocs/Op 10 16.5K ops/sec 61\u00b5s 23.8 KB 441 50 2.1K ops/sec 480\u00b5s 190 KB 2.9K 100 1.9K ops/sec 516\u00b5s 317 KB 2.9K"},{"location":"advanced/benchmarking/#search-with-different-dimensions","title":"Search with Different Dimensions","text":"Dimension Throughput Latency Memory/Op Allocs/Op 32 27.6K ops/sec 36\u00b5s 23.3 KB 429 128 16.0K ops/sec 63\u00b5s 25.6 KB 457 512 7.0K ops/sec 143\u00b5s 24.2 KB 455"},{"location":"advanced/benchmarking/#performance-tuning-based-on-benchmarks","title":"Performance Tuning Based on Benchmarks","text":"<p>Based on benchmark results, here are some tuning recommendations:</p>"},{"location":"advanced/benchmarking/#for-high-throughput-addition","title":"For High-Throughput Addition","text":"<ul> <li>Increase batch size (1000-5000)</li> <li>Use Arrow integration for bulk loading</li> <li>Consider parallel additions with multiple goroutines</li> </ul>"},{"location":"advanced/benchmarking/#for-low-latency-search","title":"For Low-Latency Search","text":"<ul> <li>Reduce <code>efSearch</code> (50-80)</li> <li>Use smaller vector dimensions if possible</li> <li>Keep index size manageable</li> <li>Consider in-memory storage</li> </ul>"},{"location":"advanced/benchmarking/#for-high-accuracy-search","title":"For High-Accuracy Search","text":"<ul> <li>Increase <code>M</code> (32-64)</li> <li>Increase <code>efConstruction</code> (300-500)</li> <li>Increase <code>efSearch</code> (200-400)</li> </ul>"},{"location":"advanced/benchmarking/#next-steps","title":"Next Steps","text":"<p>Now that you've benchmarked Quiver's performance, check out:</p> <ul> <li>Performance Tuning - Optimize Quiver for your needs</li> <li>HNSW Algorithm - Learn more about how HNSW works</li> <li>DuckDB Integration - Understand how Quiver uses DuckDB</li> </ul>"},{"location":"advanced/deployment/","title":"Deployment","text":"<p>Ready to take Quiver to production? Let's get those vectors flying in the real world! This guide will walk you through deploying Quiver in various environments, from simple setups to complex distributed systems. Buckle up! \ud83d\ude80</p>"},{"location":"advanced/deployment/#deployment-considerations","title":"Deployment Considerations","text":"<p>Before deploying Quiver, consider these key factors:</p> <ol> <li>Scale: How many vectors will you store? How many queries per second?</li> <li>Availability: What's your uptime requirement?</li> <li>Latency: What's your maximum acceptable query latency?</li> <li>Consistency: Do you need strong consistency or is eventual consistency acceptable?</li> <li>Resource constraints: CPU, memory, disk space, network bandwidth</li> <li>Security: Authentication, authorization, encryption requirements</li> <li>Monitoring: How will you track performance and detect issues?</li> </ol>"},{"location":"advanced/deployment/#deployment-options","title":"Deployment Options","text":""},{"location":"advanced/deployment/#standalone-server","title":"Standalone Server","text":"<p>The simplest deployment option is a standalone Quiver server.</p>"},{"location":"advanced/deployment/#docker-deployment","title":"Docker Deployment","text":"<pre><code># Pull the Quiver Docker image\ndocker pull weaviate/quiver:latest\n\n# Run Quiver with Docker\ndocker run -p 8080:8080 \\\n  -v $(pwd)/data:/data \\\n  -e QUIVER_DIMENSION=1536 \\\n  -e QUIVER_MAX_ELEMENTS=1000000 \\\n  weaviate/quiver:latest\n</code></pre>"},{"location":"advanced/deployment/#kubernetes-deployment","title":"Kubernetes Deployment","text":"<p>For production environments, we recommend deploying Quiver on Kubernetes for better scalability, high availability, and easier management.</p> <p>See our detailed Kubernetes Deployment Guide for step-by-step instructions on deploying Quiver on Kubernetes, including:</p> <ul> <li>Setting up persistent storage</li> <li>Configuring resource limits</li> <li>Implementing auto-scaling</li> <li>Monitoring with Prometheus</li> <li>Security best practices</li> </ul>"},{"location":"advanced/deployment/#cloud-deployment","title":"Cloud Deployment","text":""},{"location":"advanced/deployment/#aws-deployment","title":"AWS Deployment","text":"<p>Deploy Quiver on AWS using EC2 or ECS:</p>"},{"location":"advanced/deployment/#ec2-deployment","title":"EC2 Deployment","text":"<ol> <li>Launch an EC2 instance with sufficient resources</li> <li>Install Docker and run Quiver container</li> <li>Use EBS volumes for persistent storage</li> <li>Set up an Application Load Balancer for distribution</li> <li>Use Auto Scaling Groups for high availability</li> </ol>"},{"location":"advanced/deployment/#ecs-deployment","title":"ECS Deployment","text":"<pre><code># Create an ECS task definition\naws ecs register-task-definition --cli-input-json file://quiver-task.json\n\n# Create an ECS service\naws ecs create-service --cluster your-cluster --service-name quiver \\\n  --task-definition quiver:1 --desired-count 1 \\\n  --launch-type FARGATE --network-configuration \"awsvpcConfiguration={subnets=[subnet-12345],securityGroups=[sg-12345],assignPublicIp=ENABLED}\"\n</code></pre>"},{"location":"advanced/deployment/#google-cloud-deployment","title":"Google Cloud Deployment","text":"<p>Deploy Quiver on Google Cloud using GKE:</p> <pre><code># Create a GKE cluster\ngcloud container clusters create quiver-cluster \\\n  --num-nodes=3 --machine-type=e2-standard-4\n\n# Deploy Quiver to GKE\nkubectl apply -f quiver-deployment.yaml\n</code></pre>"},{"location":"advanced/deployment/#azure-deployment","title":"Azure Deployment","text":"<p>Deploy Quiver on Azure using AKS:</p> <pre><code># Create an AKS cluster\naz aks create --resource-group myResourceGroup \\\n  --name quiver-cluster --node-count 3 --enable-addons monitoring\n\n# Get credentials\naz aks get-credentials --resource-group myResourceGroup --name quiver-cluster\n\n# Deploy Quiver to AKS\nkubectl apply -f quiver-deployment.yaml\n</code></pre>"},{"location":"advanced/deployment/#performance-optimization","title":"Performance Optimization","text":""},{"location":"advanced/deployment/#network-optimization","title":"Network Optimization","text":"<ol> <li>Co-location: Place Quiver close to your application servers</li> <li>CDN: Use a CDN for static assets if serving a web interface</li> <li>Connection pooling: Reuse connections to reduce overhead</li> <li>Compression: Enable gzip compression for HTTP responses</li> </ol>"},{"location":"advanced/deployment/#storage-optimization","title":"Storage Optimization","text":"<ol> <li>SSD: Use SSDs for faster I/O</li> <li>RAID: Consider RAID configurations for better performance and reliability</li> <li>File system: Use a file system optimized for database workloads (ext4, XFS)</li> <li>Backup strategy: Regular backups with minimal impact on performance</li> </ol>"},{"location":"advanced/deployment/#security-considerations","title":"Security Considerations","text":""},{"location":"advanced/deployment/#network-security","title":"Network Security","text":"<ol> <li>Firewall: Restrict access to the Quiver server</li> <li>VPC: Deploy within a private network</li> <li>TLS: Enable HTTPS for all communications</li> <li>Rate limiting: Protect against DoS attacks</li> </ol>"},{"location":"advanced/deployment/#authentication-and-authorization","title":"Authentication and Authorization","text":"<ol> <li>API keys: Use strong API keys</li> <li>JWT: Consider JWT for more complex authentication</li> <li>Role-based access: Implement different access levels if needed</li> </ol>"},{"location":"advanced/deployment/#data-security","title":"Data Security","text":"<ol> <li>Encryption at rest: Encrypt the database file</li> <li>Encryption in transit: Use TLS for all communications</li> <li>Regular security audits: Check for vulnerabilities</li> </ol>"},{"location":"advanced/deployment/#monitoring-and-maintenance","title":"Monitoring and Maintenance","text":""},{"location":"advanced/deployment/#monitoring","title":"Monitoring","text":"<p>Set up monitoring for:</p> <ol> <li>System metrics: CPU, memory, disk usage, network</li> <li>Application metrics: Query latency, throughput, error rate</li> <li>Logs: Error logs, access logs</li> <li>Alerts: Set up alerts for critical issues</li> </ol> <p>Example Prometheus metrics configuration:</p> <pre><code>global:\n  scrape_interval: 15s\n\nscrape_configs:\n  - job_name: 'quiver'\n    static_configs:\n      - targets: ['quiver:8080']\n</code></pre>"},{"location":"advanced/deployment/#logging","title":"Logging","text":"<p>Configure comprehensive logging:</p> <pre><code>// Create a production logger with structured logging\nlogger, _ := zap.NewProduction()\n\n// Pass the logger to Quiver\nidx, err := quiver.New(quiver.Config{\n    // Your config here\n}, logger)\n</code></pre>"},{"location":"advanced/deployment/#backup-and-recovery","title":"Backup and Recovery","text":"<p>Implement a robust backup strategy:</p> <ol> <li>Regular backups: Schedule frequent backups</li> <li>Backup verification: Regularly test restoring from backups</li> <li>Off-site storage: Store backups in a different location</li> <li>Backup rotation: Keep multiple backup generations</li> </ol> <p>Example backup script:</p> <pre><code>#!/bin/bash\n# Backup Quiver database\n\nDATE=$(date +%Y%m%d-%H%M%S)\nBACKUP_DIR=\"/backups\"\nDB_PATH=\"/data/quiver.db\"\n\n# Create backup directory if it doesn't exist\nmkdir -p $BACKUP_DIR\n\n# Stop Quiver or use the backup API if available\n# ...\n\n# Create backup\ncp $DB_PATH $BACKUP_DIR/quiver-$DATE.db\n\n# Compress backup\ngzip $BACKUP_DIR/quiver-$DATE.db\n\n# Restart Quiver\n# ...\n\n# Clean up old backups (keep last 7 days)\nfind $BACKUP_DIR -name \"quiver-*.db.gz\" -type f -mtime +7 -delete\n</code></pre>"},{"location":"advanced/deployment/#deployment-checklist","title":"Deployment Checklist","text":"<p>Before going live, check these items:</p> <ul> <li> Performance testing completed</li> <li> Security measures implemented</li> <li> Monitoring and alerting set up</li> <li> Backup and recovery procedures tested</li> <li> Scaling strategy defined</li> <li> Documentation updated</li> <li> Rollback plan prepared</li> </ul>"},{"location":"advanced/deployment/#real-world-deployment-examples","title":"Real-world Deployment Examples","text":""},{"location":"advanced/deployment/#e-commerce-product-search","title":"E-commerce Product Search","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  Web Server \u2502     \u2502 API Gateway \u2502     \u2502 Load Balancer\u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n       \u2502                   \u2502                   \u2502\n       \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                           \u2502\n                    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                    \u2502  Quiver     \u2502\n                    \u2502  Cluster    \u2502\n                    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                           \u2502\n                    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                    \u2502  Persistent \u2502\n                    \u2502  Storage    \u2502\n                    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Configuration:</p> <ul> <li>10 million product vectors</li> <li>100 dimensions per vector</li> <li>1000 queries per second at peak</li> <li>99.99% uptime requirement</li> <li>&lt;50ms query latency</li> </ul>"},{"location":"advanced/deployment/#ai-assistant-knowledge-base","title":"AI Assistant Knowledge Base","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  AI Model   \u2502     \u2502 User Queries \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n       \u2502                   \u2502\n       \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                \u2502\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 Query Router  \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                \u2502\n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    \u2502           \u2502           \u2502\n\u250c\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2510   \u250c\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2510   \u250c\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2510\n\u2502Shard 1\u2502   \u2502Shard 2\u2502   \u2502Shard 3\u2502\n\u2502(Docs) \u2502   \u2502(Code) \u2502   \u2502(QA)   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Configuration:</p> <ul> <li>100 million knowledge base vectors</li> <li>1536 dimensions per vector</li> <li>Sharded by content type</li> <li>Read-heavy workload</li> <li>Hybrid search with metadata filtering</li> </ul>"},{"location":"advanced/deployment/#next-steps","title":"Next Steps","text":"<p>Now that you've deployed Quiver, check out:</p> <ul> <li>Performance Tuning - Optimize your deployment</li> <li>Benchmarking - Measure your deployment's performance</li> <li>Troubleshooting - Solve common deployment issues</li> </ul>"},{"location":"advanced/duckdb-integration/","title":"DuckDB Integration","text":"<p>One of Quiver's superpowers is its seamless integration with DuckDB for metadata storage and querying. This integration enables powerful SQL-based filtering and hybrid search capabilities. Let's dive into how Quiver leverages DuckDB to enhance vector search! \ud83e\udd86</p>"},{"location":"advanced/duckdb-integration/#what-is-duckdb","title":"What is DuckDB?","text":"<p>DuckDB is an in-process SQL OLAP database management system designed for analytical queries. It's often described as \"SQLite for analytics\" and offers several advantages:</p> <ul> <li>Extremely fast analytical queries</li> <li>Columnar storage format</li> <li>In-process operation (no client-server architecture)</li> <li>Rich SQL support</li> <li>JSON functions</li> <li>Low memory footprint</li> </ul> <p>These characteristics make DuckDB an ideal companion for vector search, allowing Quiver to provide rich metadata filtering capabilities alongside vector similarity search.</p>"},{"location":"advanced/duckdb-integration/#how-quiver-uses-duckdb","title":"How Quiver Uses DuckDB","text":"<p>Quiver uses DuckDB for several key functions:</p>"},{"location":"advanced/duckdb-integration/#metadata-storage","title":"Metadata Storage","text":"<p>When you add vectors to Quiver with metadata:</p> <pre><code>idx.Add(1, vector, map[string]interface{}{\n    \"category\": \"document\",\n    \"title\": \"Introduction to Vector Databases\",\n    \"tags\": []string{\"database\", \"vector\", \"tutorial\"},\n    \"created_at\": time.Now().Unix(),\n})\n</code></pre> <p>Quiver stores this metadata in DuckDB with a simple schema:</p> <pre><code>CREATE TABLE metadata (\n    id BIGINT PRIMARY KEY,\n    json JSON\n)\n</code></pre> <p>The <code>id</code> column matches the vector ID, and the <code>json</code> column stores the metadata as a JSON object.</p>"},{"location":"advanced/duckdb-integration/#sql-filtering","title":"SQL Filtering","text":"<p>DuckDB's SQL capabilities enable powerful filtering in hybrid searches:</p> <pre><code>// Search for vectors similar to queryVector that match specific metadata criteria\nresults, err := idx.SearchWithFilter(queryVector, 10, \n    \"json_extract(json, '$.category') = 'document' AND json_array_contains(json_extract(json, '$.tags'), 'vector')\")\n</code></pre> <p>This allows you to combine vector similarity with precise metadata filtering, enabling use cases like:</p> <ul> <li>Finding similar products within a specific price range</li> <li>Searching for documents in a particular category</li> <li>Filtering images by specific attributes</li> </ul>"},{"location":"advanced/duckdb-integration/#json-functions","title":"JSON Functions","text":"<p>DuckDB provides rich JSON functions that Quiver exposes for metadata queries:</p> <pre><code>// Extract nested JSON properties\n\"json_extract(json, '$.user.preferences.theme') = 'dark'\"\n\n// Check if an array contains a value\n\"json_array_contains(json_extract(json, '$.tags'), 'important')\"\n\n// Get array length\n\"json_array_length(json_extract(json, '$.references')) &gt; 5\"\n</code></pre> <p>These functions make it easy to work with complex nested metadata structures.</p>"},{"location":"advanced/duckdb-integration/#implementation-details","title":"Implementation Details","text":""},{"location":"advanced/duckdb-integration/#connection-management","title":"Connection Management","text":"<p>Quiver manages DuckDB connections efficiently:</p> <pre><code>type DuckDB struct {\n    mu     sync.Mutex\n    db     adbc.Database\n    driver adbc.Driver\n    opts   DuckDBOptions\n\n    conns []*DuckDBConn // track open connections\n}\n\ntype DuckDBConn struct {\n    parent *DuckDB\n    conn   adbc.Connection\n}\n</code></pre> <p>Connections are pooled and reused to minimize overhead.</p>"},{"location":"advanced/duckdb-integration/#adbc-interface","title":"ADBC Interface","text":"<p>Quiver uses the Arrow Database Connectivity (ADBC) interface to communicate with DuckDB, which provides:</p> <ul> <li>Efficient data transfer using Apache Arrow</li> <li>Reduced serialization overhead</li> <li>Better type safety</li> </ul> <pre><code>// Execute a SQL query\nfunc (c *DuckDBConn) Query(ctx context.Context, sql string) (array.RecordReader, adbc.Statement, int64, error) {\n    stmt, err := c.conn.NewStatement()\n    if err != nil {\n        return nil, nil, 0, fmt.Errorf(\"failed to create statement: %w\", err)\n    }\n\n    if err := stmt.SetSqlQuery(sql); err != nil {\n        stmt.Close()\n        return nil, nil, 0, fmt.Errorf(\"failed to set SQL query: %w\", err)\n    }\n\n    reader, err := stmt.ExecuteQuery(ctx)\n    if err != nil {\n        stmt.Close()\n        return nil, nil, 0, fmt.Errorf(\"failed to execute query: %w\", err)\n    }\n\n    return reader, stmt, 0, nil\n}\n</code></pre>"},{"location":"advanced/duckdb-integration/#metadata-caching","title":"Metadata Caching","text":"<p>To improve performance, Quiver caches metadata in memory:</p> <pre><code>// Get metadata for a vector\nfunc (idx *Index) getMetadata(id uint64) map[string]interface{} {\n    // Check cache first\n    if meta, ok := idx.cache.Load(id); ok {\n        return meta.(map[string]interface{})\n    }\n\n    // If not in cache, query DuckDB\n    query := fmt.Sprintf(\"SELECT json FROM metadata WHERE id = %d\", id)\n    results, err := idx.QueryMetadata(query)\n    if err != nil || len(results) == 0 {\n        return nil\n    }\n\n    // Store in cache for future use\n    idx.cache.Store(id, results[0])\n\n    return results[0]\n}\n</code></pre> <p>This caching strategy reduces database load for frequently accessed metadata.</p>"},{"location":"advanced/duckdb-integration/#hybrid-search-strategies","title":"Hybrid Search Strategies","text":"<p>Quiver's DuckDB integration enables several hybrid search strategies:</p>"},{"location":"advanced/duckdb-integration/#filter-then-search","title":"Filter-Then-Search","text":"<p>For highly selective filters, Quiver can:</p> <ol> <li>First query DuckDB to find matching IDs</li> <li>Then perform vector search only on those IDs</li> </ol> <pre><code>// Example implementation of filter-then-search\nfunc filterThenSearch(idx *Index, query []float32, filter string, k int) ([]SearchResult, error) {\n    // Step 1: Get IDs matching the filter\n    sql := fmt.Sprintf(\"SELECT id FROM metadata WHERE %s\", filter)\n    metaResults, err := idx.QueryMetadata(sql)\n    if err != nil {\n        return nil, err\n    }\n\n    // Extract IDs\n    ids := make([]uint64, len(metaResults))\n    for i, result := range metaResults {\n        ids[i] = result[\"id\"].(uint64)\n    }\n\n    // Step 2: Search only those IDs\n    return idx.SearchSubset(query, ids, k)\n}\n</code></pre> <p>This approach is efficient when the filter is highly selective (returns few results).</p>"},{"location":"advanced/duckdb-integration/#search-then-filter","title":"Search-Then-Filter","text":"<p>For less selective filters, Quiver can:</p> <ol> <li>First perform vector search to find similar vectors</li> <li>Then filter the results by metadata</li> </ol> <pre><code>// Example implementation of search-then-filter\nfunc searchThenFilter(idx *Index, query []float32, filter string, k int) ([]SearchResult, error) {\n    // Step 1: Perform vector search\n    // Get more results than needed to account for filtering\n    results, err := idx.Search(query, k*10, 1, k*10)\n    if err != nil {\n        return nil, err\n    }\n\n    // Step 2: Filter results\n    filtered := make([]SearchResult, 0, k)\n\n    // Extract IDs\n    ids := make([]uint64, len(results))\n    for i, result := range results {\n        ids[i] = result.ID\n    }\n\n    // Query metadata for these IDs\n    sql := fmt.Sprintf(\"SELECT id FROM metadata WHERE id IN (%s) AND %s\",\n        joinUint64(ids, \",\"), filter)\n    metaResults, err := idx.QueryMetadata(sql)\n    if err != nil {\n        return nil, err\n    }\n\n    // Create a set of matching IDs\n    matchingIDs := make(map[uint64]bool)\n    for _, result := range metaResults {\n        matchingIDs[result[\"id\"].(uint64)] = true\n    }\n\n    // Filter the search results\n    for _, result := range results {\n        if matchingIDs[result.ID] {\n            filtered = append(filtered, result)\n            if len(filtered) &gt;= k {\n                break\n            }\n        }\n    }\n\n    return filtered, nil\n}\n</code></pre> <p>This approach is efficient when the filter is less selective (returns many results).</p>"},{"location":"advanced/duckdb-integration/#adaptive-hybrid-search","title":"Adaptive Hybrid Search","text":"<p>Quiver automatically chooses the most efficient strategy based on the filter:</p> <pre><code>// Simplified version of Quiver's hybrid search\nfunc (idx *Index) SearchWithFilter(query []float32, k int, filter string) ([]SearchResult, error) {\n    // Estimate the selectivity of the filter\n    countSQL := fmt.Sprintf(\"SELECT COUNT(*) FROM metadata WHERE %s\", filter)\n    count, err := idx.estimateFilterCount(countSQL)\n    if err != nil {\n        return nil, err\n    }\n\n    // Choose strategy based on selectivity\n    if count &lt; 1000 {\n        // Filter is selective, use filter-then-search\n        return idx.filterThenSearch(query, filter, k)\n    } else {\n        // Filter is not selective, use search-then-filter\n        return idx.searchThenFilter(query, filter, k)\n    }\n}\n</code></pre> <p>This adaptive approach ensures optimal performance for different types of queries.</p>"},{"location":"advanced/duckdb-integration/#performance-considerations","title":"Performance Considerations","text":""},{"location":"advanced/duckdb-integration/#query-optimization","title":"Query Optimization","text":"<p>DuckDB is already highly optimized for analytical queries, but there are still some best practices:</p> <ul> <li>Be specific in your filters to reduce the result set</li> <li>Use appropriate JSON functions for nested data</li> <li>Avoid complex joins or subqueries if possible</li> </ul>"},{"location":"advanced/duckdb-integration/#memory-usage","title":"Memory Usage","text":"<p>DuckDB operates in-process, so it shares memory with Quiver:</p> <pre><code>config := quiver.Config{\n    // ... other settings ...\n    StoragePath: \"./data/vectors.db\", // Path to DuckDB file\n}\n</code></pre> <p>For large datasets, consider:</p> <ul> <li>Using a file-based DuckDB database instead of in-memory</li> <li>Monitoring memory usage</li> <li>Adjusting cache sizes if needed</li> </ul>"},{"location":"advanced/duckdb-integration/#persistence","title":"Persistence","text":"<p>Quiver automatically persists metadata to DuckDB:</p> <pre><code>// Persist metadata to DuckDB\nfunc (idx *Index) persistMetadata() error {\n    // Begin transaction\n    _, err := idx.dbConn.Exec(context.Background(), \"BEGIN TRANSACTION\")\n    if err != nil {\n        return err\n    }\n\n    // Insert or update metadata\n    for id, meta := range idx.metadataToUpdate {\n        jsonData, _ := json.Marshal(meta)\n        sql := fmt.Sprintf(\"INSERT OR REPLACE INTO metadata (id, json) VALUES (%d, '%s')\",\n            id, string(jsonData))\n        _, err := idx.dbConn.Exec(context.Background(), sql)\n        if err != nil {\n            idx.dbConn.Exec(context.Background(), \"ROLLBACK\")\n            return err\n        }\n    }\n\n    // Commit transaction\n    _, err = idx.dbConn.Exec(context.Background(), \"COMMIT\")\n    return err\n}\n</code></pre> <p>This ensures that metadata is safely stored on disk and can be recovered after a restart.</p>"},{"location":"advanced/duckdb-integration/#example-queries","title":"Example Queries","text":"<p>Here are some example metadata queries you can use with Quiver:</p>"},{"location":"advanced/duckdb-integration/#basic-filtering","title":"Basic Filtering","text":"<pre><code>// Find documents in the \"science\" category\nresults, _ := idx.SearchWithFilter(queryVector, 10, \"category = 'science'\")\n\n// Find products in a price range\nresults, _ := idx.SearchWithFilter(queryVector, 10, \"price &gt;= 10.0 AND price &lt;= 50.0\")\n\n// Find items created in the last week\nresults, _ := idx.SearchWithFilter(queryVector, 10, \n    fmt.Sprintf(\"created_at &gt;= %d\", time.Now().AddDate(0, 0, -7).Unix()))\n</code></pre>"},{"location":"advanced/duckdb-integration/#working-with-arrays","title":"Working with Arrays","text":"<pre><code>// Find items with specific tag\nresults, _ := idx.SearchWithFilter(queryVector, 10, \n    \"json_array_contains(tags, 'important')\")\n\n// Find items with at least 3 tags\nresults, _ := idx.SearchWithFilter(queryVector, 10, \n    \"json_array_length(tags) &gt;= 3\")\n</code></pre>"},{"location":"advanced/duckdb-integration/#nested-properties","title":"Nested Properties","text":"<pre><code>// Find items with specific nested property\nresults, _ := idx.SearchWithFilter(queryVector, 10, \n    \"json_extract(json, '$.details.publisher') = 'Nature'\")\n\n// Find items with high rating\nresults, _ := idx.SearchWithFilter(queryVector, 10, \n    \"CAST(json_extract(json, '$.ratings.average') AS FLOAT) &gt;= 4.5\")\n</code></pre>"},{"location":"advanced/duckdb-integration/#next-steps","title":"Next Steps","text":"<p>Now that you understand how Quiver integrates with DuckDB, check out:</p> <ul> <li>Performance Tuning - Optimize Quiver for your needs</li> <li>Benchmarking - Measure Quiver's performance</li> <li>Metadata &amp; Filtering - Learn more about metadata and filtering</li> </ul>"},{"location":"advanced/hnsw-algorithm/","title":"HNSW Algorithm","text":"<p>Quiver's blazing-fast search capabilities are powered by the Hierarchical Navigable Small World (HNSW) algorithm. Let's dive into how this algorithm works and why it's so effective for vector similarity search! \ud83d\udd0d</p>"},{"location":"advanced/hnsw-algorithm/#what-is-hnsw","title":"What is HNSW?","text":"<p>HNSW (Hierarchical Navigable Small World) is a graph-based algorithm for approximate nearest neighbor search. It was introduced in 2016 by Yury Malkov and Dmitry Yashunin in their paper \"Efficient and Robust Approximate Nearest Neighbor Search Using Hierarchical Navigable Small World Graphs\".</p> <p>The algorithm creates a multi-layered graph structure that allows for extremely fast navigation through the vector space, achieving logarithmic search complexity.</p>"},{"location":"advanced/hnsw-algorithm/#how-hnsw-works","title":"How HNSW Works","text":""},{"location":"advanced/hnsw-algorithm/#the-basic-idea","title":"The Basic Idea","text":"<p>HNSW builds a multi-layered graph where:</p> <ol> <li>Each vector is represented as a node in the graph</li> <li>Nodes are connected to their \"neighbors\" (similar vectors)</li> <li>The graph has multiple layers, with fewer nodes in higher layers</li> <li>Higher layers act as \"highways\" for faster navigation</li> </ol> <p>This hierarchical structure allows the algorithm to quickly narrow down the search space, making it incredibly efficient even with millions of vectors.</p>"},{"location":"advanced/hnsw-algorithm/#graph-construction","title":"Graph Construction","text":"<p>When you add a vector to Quiver, the HNSW algorithm:</p> <ol> <li>Randomly assigns the vector to a maximum layer level</li> <li>Inserts the vector into all layers from 0 up to its maximum level</li> <li>For each layer, connects the vector to its nearest neighbors</li> <li>Maintains a maximum number of connections per node (the <code>M</code> parameter)</li> </ol> <p>The construction process ensures that the graph has good navigational properties, allowing for efficient search.</p> <pre><code>// Simplified pseudocode for HNSW insertion\nfunc (hnsw *Graph) Insert(vector []float32, id uint64) {\n    // Randomly select maximum level for this vector\n    maxLevel := randomLevel()\n\n    // Start from the top layer of the existing graph\n    currentNode := hnsw.entryPoint\n\n    // For each layer from top to the vector's max level\n    for level := hnsw.maxLevel; level &gt; maxLevel; level-- {\n        // Find the closest node to the vector at this level\n        currentNode = findClosestNeighbor(vector, currentNode, level)\n    }\n\n    // For each layer from the vector's max level to bottom\n    for level := maxLevel; level &gt;= 0; level-- {\n        // Find nearest neighbors at this level\n        neighbors := findNearestNeighbors(vector, currentNode, level, hnsw.M)\n\n        // Connect the vector to its neighbors\n        hnsw.connect(id, neighbors, level)\n\n        // Update the entry point if needed\n        if level == hnsw.maxLevel {\n            hnsw.entryPoint = id\n        }\n\n        // Use these neighbors as starting points for the next layer\n        currentNode = findClosestNeighbor(vector, neighbors, level)\n    }\n}\n</code></pre>"},{"location":"advanced/hnsw-algorithm/#search-process","title":"Search Process","text":"<p>When you search for similar vectors, the HNSW algorithm:</p> <ol> <li>Starts at the entry point in the top layer</li> <li>Greedily moves to the nearest neighbor of the query vector</li> <li>When no closer neighbors are found, descends to the next layer</li> <li>Repeats until reaching the bottom layer</li> <li>Performs a more thorough search at the bottom layer</li> </ol> <p>This approach allows for logarithmic search complexity, making it extremely fast even with large datasets.</p> <pre><code>// Simplified pseudocode for HNSW search\nfunc (hnsw *Graph) Search(query []float32, k int) []SearchResult {\n    // Start from the top layer of the graph\n    currentNode := hnsw.entryPoint\n\n    // For each layer from top to bottom\n    for level := hnsw.maxLevel; level &gt; 0; level-- {\n        // Greedy search at this layer\n        currentNode = greedySearch(query, currentNode, level)\n    }\n\n    // More thorough search at the bottom layer\n    candidates := beamSearch(query, currentNode, 0, hnsw.efSearch)\n\n    // Return the k closest candidates\n    return getTopK(candidates, k)\n}\n</code></pre>"},{"location":"advanced/hnsw-algorithm/#key-parameters","title":"Key Parameters","text":"<p>Quiver exposes several HNSW parameters that you can tune:</p>"},{"location":"advanced/hnsw-algorithm/#m-hnswm","title":"M (HNSWM)","text":"<p>The <code>M</code> parameter controls the maximum number of connections per node:</p> <pre><code>config := quiver.Config{\n    // ... other settings ...\n    HNSWM: 16, // Default is 16\n}\n</code></pre> <p>Higher values of <code>M</code>:</p> <ul> <li>Improve search accuracy</li> <li>Increase memory usage</li> <li>Slow down construction time</li> </ul> <p>Lower values of <code>M</code>:</p> <ul> <li>Reduce memory usage</li> <li>Speed up construction</li> <li>May reduce search accuracy</li> </ul> <p>Recommended Values</p> <p>Values between 12-64 work well for most applications. Start with 16 and adjust if needed.</p>"},{"location":"advanced/hnsw-algorithm/#efconstruction-hnswefconstruct","title":"efConstruction (HNSWEfConstruct)","text":"<p>The <code>efConstruction</code> parameter controls the quality of graph construction:</p> <pre><code>config := quiver.Config{\n    // ... other settings ...\n    HNSWEfConstruct: 200, // Default is 200\n}\n</code></pre> <p>Higher values of <code>efConstruction</code>:</p> <ul> <li>Create a better quality graph</li> <li>Improve search accuracy</li> <li>Slow down construction time</li> </ul> <p>Lower values of <code>efConstruction</code>:</p> <ul> <li>Speed up construction</li> <li>May reduce search accuracy</li> </ul> <p>Recommended Values</p> <p>Values between 100-500 work well for most applications. Use higher values for better accuracy.</p>"},{"location":"advanced/hnsw-algorithm/#efsearch-hnswefsearch","title":"efSearch (HNSWEfSearch)","text":"<p>The <code>efSearch</code> parameter controls the quality of search:</p> <pre><code>config := quiver.Config{\n    // ... other settings ...\n    HNSWEfSearch: 100, // Default is 100\n}\n</code></pre> <p>Higher values of <code>efSearch</code>:</p> <ul> <li>Improve search accuracy</li> <li>Slow down search speed</li> </ul> <p>Lower values of <code>efSearch</code>:</p> <ul> <li>Speed up search</li> <li>May reduce search accuracy</li> </ul> <p>Recommended Values</p> <p>Values between 50-200 provide a good balance. If you need more precision, increase this value.</p>"},{"location":"advanced/hnsw-algorithm/#performance-characteristics","title":"Performance Characteristics","text":"<p>HNSW offers several key performance advantages:</p>"},{"location":"advanced/hnsw-algorithm/#search-complexity","title":"Search Complexity","text":"<ul> <li>Time complexity: O(log N), where N is the number of vectors</li> <li>This is much better than the O(N) complexity of brute force search</li> </ul>"},{"location":"advanced/hnsw-algorithm/#memory-usage","title":"Memory Usage","text":"<ul> <li>Memory usage: O(M * N), where M is the HNSWM parameter</li> <li>Each vector requires storage for its connections</li> </ul>"},{"location":"advanced/hnsw-algorithm/#construction-time","title":"Construction Time","text":"<ul> <li>Construction time: O(M log N N)</li> <li>Construction is slower than search, but still efficient</li> </ul>"},{"location":"advanced/hnsw-algorithm/#quivers-implementation","title":"Quiver's Implementation","text":"<p>Quiver's implementation of HNSW includes several optimizations:</p>"},{"location":"advanced/hnsw-algorithm/#simd-acceleration","title":"SIMD Acceleration","text":"<p>Quiver uses SIMD (Single Instruction, Multiple Data) instructions to accelerate distance calculations, making both construction and search faster.</p>"},{"location":"advanced/hnsw-algorithm/#batch-processing","title":"Batch Processing","text":"<p>Quiver batches vector additions to improve throughput:</p> <pre><code>config := quiver.Config{\n    // ... other settings ...\n    BatchSize: 1000, // Default is 1000\n}\n</code></pre>"},{"location":"advanced/hnsw-algorithm/#concurrent-access","title":"Concurrent Access","text":"<p>Quiver's implementation is thread-safe, allowing for concurrent reads and writes.</p>"},{"location":"advanced/hnsw-algorithm/#comparison-with-other-algorithms","title":"Comparison with Other Algorithms","text":"<p>HNSW outperforms many other approximate nearest neighbor search algorithms:</p> Algorithm Search Time Build Time Memory Usage Accuracy HNSW Very Fast Moderate Moderate High Annoy Fast Fast Low Moderate FAISS Fast Fast Moderate High Brute Force Very Slow None Low Perfect <p>HNSW provides an excellent balance of speed, memory usage, and accuracy, making it ideal for most vector search applications.</p>"},{"location":"advanced/hnsw-algorithm/#visualizing-hnsw","title":"Visualizing HNSW","text":"<p>To help understand how HNSW works, here's a simplified visualization of the multi-layered graph structure:</p> <p>```mermaid graph TD     subgraph \"Layer 2 (Top)\"         A2[Node A]         B2[Node B]         A2 --- B2     end</p> <pre><code>subgraph \"Layer 1 (Middle)\"\n    A1[Node A]\n    B1[Node B]\n    C1[Node C]\n    D1[Node D]\n    A1 --- B1\n    B1 --- C1\n    C1 --- D1\n    D1 --- A1\nend\n\nsubgraph \"Layer 0 (Bottom)\"\n    A0[Node A]\n    B0[Node B]\n    C0[Node C]\n    D0[Node D]\n    E0[Node E]\n    F0[Node F]\n    G0[Node G]\n    H0[Node H]\n    A0 --- B0\n    B0 --- C0\n    C0 --- D0\n    D0 --- E0\n    E0 --- F0\n    F0 --- G0\n    G0 --- H0\n    H0 --- A0\n    A0 --- C0\n    B0 --- D0\n    C0 --- E0\n    D0 --- F0\n    E0 --- G0\n    F0 --- H0\nend\n\nA2 -.-&gt; A1\nB2 -.-&gt; B1\nA1 -.-&gt; A0\nB1 -.-&gt; B0\nC1 -.-&gt; C0\nD1 -.-&gt; D0\n</code></pre> <p>```</p> <p>In this visualization:</p> <ul> <li>The top layer has fewer nodes and acts as a \"highway\"</li> <li>The bottom layer contains all nodes with more connections</li> <li>Search starts at the top layer and descends to lower layers</li> </ul>"},{"location":"advanced/hnsw-algorithm/#further-reading","title":"Further Reading","text":"<p>If you're interested in learning more about HNSW, check out these resources:</p> <ul> <li>Original HNSW Paper</li> <li>Understanding HNSW Algorithm</li> <li>Efficient Similarity Search in High Dimensions</li> </ul>"},{"location":"advanced/hnsw-algorithm/#next-steps","title":"Next Steps","text":"<p>Now that you understand how HNSW powers Quiver's vector search, check out:</p> <ul> <li>DuckDB Integration - Learn how Quiver uses DuckDB for metadata</li> <li>Performance Tuning - Optimize Quiver for your needs</li> <li>Benchmarking - Measure Quiver's performance</li> </ul>"},{"location":"advanced/kubernetes-deployment/","title":"Deploying Quiver on Kubernetes","text":"<p>This guide explains how to deploy Quiver on Kubernetes, providing both basic deployment instructions and advanced configuration options.</p>"},{"location":"advanced/kubernetes-deployment/#overview","title":"Overview","text":"<p>Deploying Quiver on Kubernetes offers several advantages:</p> <ul> <li>Scalability: Easily scale your vector database based on demand</li> <li>High Availability: Run multiple replicas for fault tolerance</li> <li>Resource Management: Define precise CPU and memory limits</li> <li>Automated Operations: Leverage Kubernetes for rolling updates, health checks, and auto-scaling</li> <li>Monitoring Integration: Built-in Prometheus metrics support</li> </ul>"},{"location":"advanced/kubernetes-deployment/#architecture-diagram","title":"Architecture Diagram","text":"<p><code>mermaid graph TD     subgraph \"Kubernetes Cluster\"         subgraph \"Quiver Namespace\"             ing[Ingress] --&gt; svc[Service]             svc --&gt; dep[Deployment]             dep --&gt; pod1[Quiver Pod 1]             dep --&gt; pod2[Quiver Pod 2]             dep --&gt; pod3[Quiver Pod 3]             pod1 --&gt; pvc[Persistent Volume Claim]             pod2 --&gt; pvc             pod3 --&gt; pvc             pod1 --&gt; cm[ConfigMap]             pod2 --&gt; cm             pod3 --&gt; cm             hpa[HPA] --&gt; dep         end         subgraph \"Monitoring\"             prom[Prometheus] --&gt; svc             graf[Grafana] --&gt; prom         end     end     client[Client] --&gt; ing</code></p>"},{"location":"advanced/kubernetes-deployment/#prerequisites","title":"Prerequisites","text":"<p>Before you begin, ensure you have:</p> <ul> <li>A Kubernetes cluster (v1.19+)</li> <li><code>kubectl</code> configured to communicate with your cluster</li> <li>Docker for building container images</li> <li>Helm v3 (optional, for Helm chart deployment)</li> </ul>"},{"location":"advanced/kubernetes-deployment/#quick-start","title":"Quick Start","text":""},{"location":"advanced/kubernetes-deployment/#1-build-the-docker-image","title":"1. Build the Docker Image","text":"<p>First, build and push the Quiver Docker image:</p> <pre><code># From the root of the Quiver repository\ndocker build -t your-registry/quiver:latest .\ndocker push your-registry/quiver:latest\n</code></pre>"},{"location":"advanced/kubernetes-deployment/#2-deploy-with-kubectl","title":"2. Deploy with kubectl","text":"<p>Create a namespace for Quiver:</p> <pre><code>kubectl create namespace quiver\n</code></pre> <p>Apply the Kubernetes manifests:</p> <pre><code>kubectl apply -f k8s/pvc.yaml -n quiver\nkubectl apply -f k8s/configmap.yaml -n quiver\nkubectl apply -f k8s/deployment.yaml -n quiver\nkubectl apply -f k8s/service.yaml -n quiver\n</code></pre> <p>Verify the deployment:</p> <pre><code>kubectl get pods -n quiver\nkubectl get svc -n quiver\n</code></pre>"},{"location":"advanced/kubernetes-deployment/#3-deploy-with-helm-alternative","title":"3. Deploy with Helm (Alternative)","text":"<p>If you prefer using Helm:</p> <pre><code>helm install quiver ./helm/quiver \\\n  --namespace quiver \\\n  --create-namespace \\\n  --set image.repository=your-registry/quiver \\\n  --set image.tag=latest\n</code></pre>"},{"location":"advanced/kubernetes-deployment/#configuration","title":"Configuration","text":""},{"location":"advanced/kubernetes-deployment/#environment-variables","title":"Environment Variables","text":"<p>Quiver can be configured using the following environment variables:</p> Variable Description Default <code>QUIVER_PORT</code> HTTP server port <code>8080</code> <code>QUIVER_DIMENSION</code> Vector dimension <code>1536</code> <code>QUIVER_MAX_ELEMENTS</code> Maximum number of vectors <code>1000000</code> <code>QUIVER_HNSW_M</code> HNSW hyperparameter M <code>16</code> <code>QUIVER_HNSW_EF_CONSTRUCT</code> HNSW hyperparameter efConstruction <code>200</code> <code>QUIVER_HNSW_EF_SEARCH</code> HNSW hyperparameter efSearch <code>100</code> <code>QUIVER_BATCH_SIZE</code> Number of vectors to batch before insertion <code>100</code> <code>QUIVER_PERSIST_INTERVAL</code> How often to persist index to disk <code>5m</code> <code>QUIVER_BACKUP_INTERVAL</code> How often to create backups <code>1h</code> <code>QUIVER_MAX_BACKUPS</code> Maximum number of backups to keep <code>5</code> <code>QUIVER_BACKUP_COMPRESSION</code> Whether to compress backups <code>true</code> <code>QUIVER_LOG_LEVEL</code> Logging level (debug, info, warn, error) <code>info</code>"},{"location":"advanced/kubernetes-deployment/#configmap","title":"ConfigMap","text":"<p>For more complex configurations, use a ConfigMap:</p> <pre><code>apiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: quiver-config\ndata:\n  quiver.yaml: |\n    dimension: 1536\n    distance: \"cosine\"\n    max_elements: 1000000\n    hnsw:\n      m: 16\n      ef_construction: 200\n      ef_search: 100\n    batch_size: 100\n    persistence:\n      interval: \"5m\"\n      path: \"/data/quiver\"\n    backup:\n      interval: \"1h\"\n      path: \"/data/backups\"\n      compression: true\n      max_backups: 5\n    security:\n      encryption_enabled: false\n    logging:\n      level: \"info\"\n      format: \"json\"\n</code></pre>"},{"location":"advanced/kubernetes-deployment/#persistence","title":"Persistence","text":"<p>Quiver requires persistent storage to maintain vector data across pod restarts. The default configuration uses a PersistentVolumeClaim:</p> <pre><code>apiVersion: v1\nkind: PersistentVolumeClaim\nmetadata:\n  name: quiver-pvc\nspec:\n  accessModes:\n    - ReadWriteOnce\n  resources:\n    requests:\n      storage: 10Gi\n  storageClassName: standard\n</code></pre> <p>Storage Class</p> <p>Choose an appropriate <code>storageClassName</code> for your cluster. For production, consider using SSD-backed storage for better performance.</p>"},{"location":"advanced/kubernetes-deployment/#scaling","title":"Scaling","text":""},{"location":"advanced/kubernetes-deployment/#horizontal-pod-autoscaler","title":"Horizontal Pod Autoscaler","text":"<p>Quiver can be scaled horizontally for read-heavy workloads. Use a Horizontal Pod Autoscaler (HPA) to automatically scale based on CPU and memory usage:</p> <pre><code>apiVersion: autoscaling/v2\nkind: HorizontalPodAutoscaler\nmetadata:\n  name: quiver-hpa\nspec:\n  scaleTargetRef:\n    apiVersion: apps/v1\n    kind: Deployment\n    name: quiver\n  minReplicas: 1\n  maxReplicas: 10\n  metrics:\n  - type: Resource\n    resource:\n      name: cpu\n      target:\n        type: Utilization\n        averageUtilization: 70\n  - type: Resource\n    resource:\n      name: memory\n      target:\n        type: Utilization\n        averageUtilization: 80\n</code></pre> <p>Read-Only Replicas</p> <p>When scaling Quiver horizontally, consider using read-only replicas for search operations, with a single primary instance handling writes.</p>"},{"location":"advanced/kubernetes-deployment/#resource-limits","title":"Resource Limits","text":"<p>Set appropriate resource requests and limits for your workload:</p> <pre><code>resources:\n  requests:\n    cpu: 500m\n    memory: 512Mi\n  limits:\n    cpu: 2\n    memory: 4Gi\n</code></pre> <p>Adjust these values based on your vector dimension and dataset size.</p>"},{"location":"advanced/kubernetes-deployment/#monitoring","title":"Monitoring","text":""},{"location":"advanced/kubernetes-deployment/#prometheus-metrics","title":"Prometheus Metrics","text":"<p>Quiver exposes Prometheus metrics at the <code>/metrics</code> endpoint. The following metrics are available:</p> <ul> <li><code>quiver_search_requests_total</code>: Total number of search requests</li> <li><code>quiver_search_latency_seconds</code>: Search request latency in seconds</li> <li><code>quiver_vector_count</code>: Number of vectors in the index</li> <li><code>quiver_memory_usage_bytes</code>: Memory usage in bytes</li> </ul>"},{"location":"advanced/kubernetes-deployment/#servicemonitor","title":"ServiceMonitor","text":"<p>If you're using the Prometheus Operator, you can configure a ServiceMonitor:</p> <pre><code>apiVersion: monitoring.coreos.com/v1\nkind: ServiceMonitor\nmetadata:\n  name: quiver\n  labels:\n    app: quiver\nspec:\n  selector:\n    matchLabels:\n      app: quiver\n  endpoints:\n  - port: http\n    path: /metrics\n    interval: 15s\n    scrapeTimeout: 10s\n</code></pre>"},{"location":"advanced/kubernetes-deployment/#health-checks","title":"Health Checks","text":"<p>Quiver provides health check endpoints for Kubernetes probes:</p> <pre><code>livenessProbe:\n  httpGet:\n    path: /health/live\n    port: 8080\n  initialDelaySeconds: 30\n  periodSeconds: 10\nreadinessProbe:\n  httpGet:\n    path: /health/ready\n    port: 8080\n  initialDelaySeconds: 5\n  periodSeconds: 5\n</code></pre>"},{"location":"advanced/kubernetes-deployment/#security","title":"Security","text":""},{"location":"advanced/kubernetes-deployment/#network-policies","title":"Network Policies","text":"<p>Restrict network access to your Quiver deployment with a NetworkPolicy:</p> <pre><code>apiVersion: networking.k8s.io/v1\nkind: NetworkPolicy\nmetadata:\n  name: quiver-network-policy\nspec:\n  podSelector:\n    matchLabels:\n      app: quiver\n  ingress:\n  - from:\n    - podSelector:\n        matchLabels:\n          app: client\n    ports:\n    - protocol: TCP\n      port: 8080\n</code></pre>"},{"location":"advanced/kubernetes-deployment/#secrets-management","title":"Secrets Management","text":"<p>For sensitive configuration (like encryption keys), use Kubernetes Secrets:</p> <pre><code>apiVersion: v1\nkind: Secret\nmetadata:\n  name: quiver-secrets\ntype: Opaque\ndata:\n  encryption-key: &lt;base64-encoded-key&gt;\n</code></pre> <p>Then mount the secret in your deployment:</p> <pre><code>env:\n- name: QUIVER_ENCRYPTION_KEY\n  valueFrom:\n    secretKeyRef:\n      name: quiver-secrets\n      key: encryption-key\n</code></pre>"},{"location":"advanced/kubernetes-deployment/#advanced-deployment-patterns","title":"Advanced Deployment Patterns","text":""},{"location":"advanced/kubernetes-deployment/#multi-region-deployment","title":"Multi-Region Deployment","text":"<p>For global deployments, consider running Quiver instances in multiple regions with a global load balancer:</p> <pre><code>                   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                   \u2502  Global Load    \u2502\n                   \u2502   Balancer      \u2502\n                   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                            \u2502\n              \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n              \u2502                           \u2502\n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510       \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    \u2502  Kubernetes      \u2502       \u2502  Kubernetes      \u2502\n    \u2502  Cluster (US)    \u2502       \u2502  Cluster (EU)    \u2502\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518       \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n              \u2502                           \u2502\n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510       \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    \u2502  Quiver Pods     \u2502       \u2502  Quiver Pods     \u2502\n    \u2502  (US Region)     \u2502       \u2502  (EU Region)     \u2502\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518       \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"advanced/kubernetes-deployment/#hybrid-search-architecture","title":"Hybrid Search Architecture","text":"<p>For hybrid search (combining vector and metadata filtering), consider a deployment with DuckDB integration:</p> <p><code>mermaid graph LR     subgraph \"Kubernetes Cluster\"         subgraph \"Quiver Pod\"             qv[Quiver Vector Index]             db[DuckDB Metadata]             qv &lt;--&gt; db         end         client[Client] --&gt; svc[Service]         svc --&gt; qv     end</code></p>"},{"location":"advanced/kubernetes-deployment/#troubleshooting","title":"Troubleshooting","text":""},{"location":"advanced/kubernetes-deployment/#common-issues","title":"Common Issues","text":""},{"location":"advanced/kubernetes-deployment/#pod-fails-to-start","title":"Pod Fails to Start","text":"<p>Check the pod logs:</p> <pre><code>kubectl logs -f deployment/quiver -n quiver\n</code></pre> <p>Verify resource limits are appropriate for your dataset size.</p>"},{"location":"advanced/kubernetes-deployment/#persistence-issues","title":"Persistence Issues","text":"<p>Check the PVC status:</p> <pre><code>kubectl get pvc -n quiver\nkubectl describe pvc quiver-pvc -n quiver\n</code></pre> <p>Ensure the storage class exists and has provisioner support.</p>"},{"location":"advanced/kubernetes-deployment/#performance-problems","title":"Performance Problems","text":"<ol> <li>Check resource utilization:</li> </ol> <pre><code>kubectl top pods -n quiver\n</code></pre> <ol> <li> <p>Review Prometheus metrics for bottlenecks.</p> </li> <li> <p>Adjust HNSW parameters for your specific workload.</p> </li> </ol>"},{"location":"advanced/kubernetes-deployment/#helm-chart-reference","title":"Helm Chart Reference","text":"<p>If you're using the Helm chart, here are some common configuration options:</p> <pre><code># Basic installation\nhelm install quiver ./helm/quiver --namespace quiver --create-namespace\n\n# Custom resource configuration\nhelm install quiver ./helm/quiver \\\n  --namespace quiver \\\n  --set resources.requests.memory=1Gi \\\n  --set resources.limits.memory=8Gi\n\n# Enable autoscaling\nhelm install quiver ./helm/quiver \\\n  --namespace quiver \\\n  --set autoscaling.enabled=true \\\n  --set autoscaling.minReplicas=2 \\\n  --set autoscaling.maxReplicas=10\n\n# Custom storage configuration\nhelm install quiver ./helm/quiver \\\n  --namespace quiver \\\n  --set persistence.storageClass=fast-ssd \\\n  --set persistence.size=50Gi\n\n# Enable Prometheus ServiceMonitor\nhelm install quiver ./helm/quiver \\\n  --namespace quiver \\\n  --set metrics.serviceMonitor.enabled=true\n</code></pre>"},{"location":"advanced/kubernetes-deployment/#conclusion","title":"Conclusion","text":"<p>Deploying Quiver on Kubernetes provides a robust, scalable, and manageable vector database solution. By leveraging Kubernetes features like auto-scaling, health checks, and persistent storage, you can run Quiver in production with confidence.</p> <p>For more advanced configurations and optimizations, refer to the Performance Tuning guide.</p>"},{"location":"advanced/performance-tuning/","title":"Performance Tuning","text":"<p>Want to make Quiver go even faster? You've come to the right place! This guide will help you squeeze every last drop of performance out of your vector database. Let's make those vectors fly! \ud83d\ude80</p>"},{"location":"advanced/performance-tuning/#understanding-performance-factors","title":"Understanding Performance Factors","text":"<p>Quiver's performance depends on several factors:</p> <ol> <li>Vector Dimension - Higher dimensions require more computation</li> <li>Index Size - More vectors means more data to search through</li> <li>Search Parameters - Quality vs. speed trade-offs</li> <li>Hardware - CPU, memory, and storage capabilities</li> <li>Configuration - Optimal settings for your use case</li> </ol> <p>Let's dive into how to optimize each of these factors.</p>"},{"location":"advanced/performance-tuning/#hardware-considerations","title":"Hardware Considerations","text":""},{"location":"advanced/performance-tuning/#cpu","title":"CPU","text":"<p>Quiver benefits from:</p> <ul> <li>Multiple cores for parallel processing</li> <li>Modern CPUs with SIMD support (AVX2, AVX-512)</li> <li>High clock speeds for faster distance calculations</li> </ul> <p>CPU Recommendation</p> <p>For production use, aim for at least 4 cores with AVX2 support. For large indices (&gt;10M vectors), consider 8+ cores.</p>"},{"location":"advanced/performance-tuning/#memory","title":"Memory","text":"<p>Memory requirements depend on:</p> <ul> <li>Number of vectors</li> <li>Vector dimension</li> <li>HNSW graph connectivity (M parameter)</li> <li>Metadata size and caching</li> </ul> <p>Approximate memory usage:</p> <pre><code>Memory (GB) \u2248 (Vector Count \u00d7 Vector Dimension \u00d7 4 bytes) + \n              (Vector Count \u00d7 M \u00d7 8 bytes) + \n              (Metadata Size \u00d7 Caching Factor)\n</code></pre> <p>Memory Recommendation</p> <p>For production use, allocate at least 2-4x the size of your raw vector data.</p>"},{"location":"advanced/performance-tuning/#storage","title":"Storage","text":"<p>Storage considerations:</p> <ul> <li>SSD is strongly recommended over HDD</li> <li>NVMe SSDs provide the best performance for persistence</li> <li>Network storage may introduce latency</li> </ul> <p>Storage Recommendation</p> <p>Use local NVMe SSDs for the best performance. If using network storage, ensure low latency and high throughput.</p>"},{"location":"advanced/performance-tuning/#hnsw-parameter-tuning","title":"HNSW Parameter Tuning","text":""},{"location":"advanced/performance-tuning/#m-maximum-connections","title":"M (Maximum Connections)","text":"<p>The <code>M</code> parameter controls the maximum number of connections per node:</p> <pre><code>config := quiver.Config{\n    // ... other settings ...\n    HNSWM: 16, // Default is 16\n}\n</code></pre> <p>Tuning recommendations:</p> <ul> <li>Lower values (8-12): Faster construction, less memory, lower accuracy</li> <li>Default (16): Good balance for most applications</li> <li>Higher values (32-64): Better accuracy, more memory, slower construction</li> </ul> <p>Real-world Example</p> <p>In our benchmarks with 1M vectors of 128 dimensions:</p> M Value Search Time Memory Usage Accuracy 8 40\u03bcs 1.2GB 92% 16 60\u03bcs 1.5GB 97% 32 85\u03bcs 2.1GB 99%"},{"location":"advanced/performance-tuning/#efconstruction","title":"efConstruction","text":"<p>The <code>efConstruction</code> parameter controls the quality of graph construction:</p> <pre><code>config := quiver.Config{\n    // ... other settings ...\n    HNSWEfConstruct: 200, // Default is 200\n}\n</code></pre> <p>Tuning recommendations:</p> <ul> <li>Lower values (100-150): Faster construction, lower quality graph</li> <li>Default (200): Good balance for most applications</li> <li>Higher values (300-500): Better quality graph, slower construction</li> </ul> <p>When to Increase</p> <p>Increase <code>efConstruction</code> if you need higher search accuracy and can afford longer build times.</p>"},{"location":"advanced/performance-tuning/#efsearch","title":"efSearch","text":"<p>The <code>efSearch</code> parameter controls the quality of search:</p> <pre><code>config := quiver.Config{\n    // ... other settings ...\n    HNSWEfSearch: 100, // Default is 100\n}\n</code></pre> <p>Tuning recommendations:</p> <ul> <li>Lower values (50-80): Faster search, lower accuracy</li> <li>Default (100): Good balance for most applications</li> <li>Higher values (200-400): Better accuracy, slower search</li> </ul> <p>Real-world Example</p> <p>In our benchmarks with 1M vectors of 128 dimensions:</p> efSearch Search Time Accuracy 50 35\u03bcs 95% 100 60\u03bcs 98% 200 110\u03bcs 99.5%"},{"location":"advanced/performance-tuning/#batch-processing-optimization","title":"Batch Processing Optimization","text":""},{"location":"advanced/performance-tuning/#batch-size","title":"Batch Size","text":"<p>The <code>BatchSize</code> parameter controls how many vectors are batched before insertion:</p> <pre><code>config := quiver.Config{\n    // ... other settings ...\n    BatchSize: 1000, // Default is 1000\n}\n</code></pre> <p>Tuning recommendations:</p> <ul> <li>Lower values (100-500): Less memory usage, more frequent updates</li> <li>Default (1000): Good balance for most applications</li> <li>Higher values (5000-10000): Better throughput for bulk loading, higher memory usage</li> </ul> <p>Bulk Loading</p> <p>For initial bulk loading, use a larger batch size (5000-10000) to maximize throughput.</p>"},{"location":"advanced/performance-tuning/#arrow-integration","title":"Arrow Integration","text":"<p>For maximum throughput when loading large datasets, use Arrow integration:</p> <pre><code>// Create Arrow record with vectors and metadata\nbuilder := array.NewRecordBuilder(memory.DefaultAllocator, quiver.NewVectorSchema(dimension))\n// ... populate the builder ...\nrecord := builder.NewRecord()\n\n// Add all vectors from the Arrow record\nerr := idx.AppendFromArrow(record)\n</code></pre> <p>This can be 10-100x faster than individual additions.</p>"},{"location":"advanced/performance-tuning/#duckdb-optimization","title":"DuckDB Optimization","text":""},{"location":"advanced/performance-tuning/#query-optimization","title":"Query Optimization","text":"<p>Optimize your metadata filters:</p> <ul> <li>Be specific in your filters to reduce the result set</li> <li>Use appropriate indexes for frequently queried fields</li> <li>Avoid complex joins or subqueries</li> </ul>"},{"location":"advanced/performance-tuning/#caching-strategy","title":"Caching Strategy","text":"<p>Quiver caches metadata in memory for better performance:</p> <pre><code>// Get metadata for a vector\nmeta := idx.getMetadata(id) // Uses internal caching\n</code></pre> <p>For large datasets, consider:</p> <ul> <li>Adjusting cache size based on available memory</li> <li>Preloading frequently accessed metadata</li> <li>Monitoring cache hit rates</li> </ul>"},{"location":"advanced/performance-tuning/#concurrency-tuning","title":"Concurrency Tuning","text":""},{"location":"advanced/performance-tuning/#read-concurrency","title":"Read Concurrency","text":"<p>Quiver supports concurrent reads:</p> <pre><code>// These can run concurrently\ngo func() { idx.Search(query1, 10, 1, 10) }()\ngo func() { idx.Search(query2, 10, 1, 10) }()\ngo func() { idx.Search(query3, 10, 1, 10) }()\n</code></pre> <p>For high-throughput search scenarios:</p> <ul> <li>Use a worker pool to manage concurrent searches</li> <li>Monitor CPU usage and adjust concurrency accordingly</li> <li>Consider using a load balancer for distributed setups</li> </ul>"},{"location":"advanced/performance-tuning/#write-concurrency","title":"Write Concurrency","text":"<p>Writes are serialized internally, but you can still batch them efficiently:</p> <pre><code>// Batch writes in goroutines\nfor i := 0; i &lt; 10; i++ {\n    go func(offset int) {\n        for j := 0; j &lt; 1000; j++ {\n            id := uint64(offset*1000 + j)\n            vector := generateVector(dimension)\n            metadata := generateMetadata(id)\n            idx.Add(id, vector, metadata)\n        }\n    }(i)\n}\n</code></pre>"},{"location":"advanced/performance-tuning/#hybrid-search-optimization","title":"Hybrid Search Optimization","text":""},{"location":"advanced/performance-tuning/#strategy-selection","title":"Strategy Selection","text":"<p>Quiver automatically chooses between two hybrid search strategies:</p> <ol> <li>Filter-then-search: For highly selective filters</li> <li>Search-then-filter: For less selective filters</li> </ol> <p>You can optimize this by:</p> <ul> <li>Making your filters as selective as possible</li> <li>Using appropriate indexes on metadata fields</li> <li>Monitoring query performance and adjusting as needed</li> </ul>"},{"location":"advanced/performance-tuning/#custom-hybrid-search","title":"Custom Hybrid Search","text":"<p>For advanced use cases, implement custom hybrid search logic:</p> <pre><code>// Example: Two-stage search with custom logic\nfunc customHybridSearch(idx *quiver.Index, query []float32, filter string, k int) ([]quiver.SearchResult, error) {\n    // First stage: Get candidate IDs from metadata\n    metaResults, err := idx.QueryMetadata(fmt.Sprintf(\"SELECT id FROM metadata WHERE %s\", filter))\n    if err != nil {\n        return nil, err\n    }\n\n    // If too many results, refine with vector search\n    if len(metaResults) &gt; 1000 {\n        // Use vector search first, then filter\n        return searchThenFilter(idx, query, filter, k)\n    } else {\n        // Use filter first, then vector search\n        return filterThenSearch(idx, query, metaResults, k)\n    }\n}\n</code></pre>"},{"location":"advanced/performance-tuning/#persistence-and-backup-optimization","title":"Persistence and Backup Optimization","text":""},{"location":"advanced/performance-tuning/#persistence-interval","title":"Persistence Interval","text":"<p>Adjust the persistence interval based on your write patterns:</p> <pre><code>config := quiver.Config{\n    // ... other settings ...\n    PersistInterval: 5 * time.Minute, // Default is 5 minutes\n}\n</code></pre> <ul> <li>Shorter intervals: Less data loss risk, more I/O overhead</li> <li>Longer intervals: Less I/O overhead, more data loss risk</li> </ul>"},{"location":"advanced/performance-tuning/#backup-compression","title":"Backup Compression","text":"<p>Enable backup compression to save storage space:</p> <pre><code>config := quiver.Config{\n    // ... other settings ...\n    BackupCompression: true, // Default is true\n}\n</code></pre> <p>This trades CPU usage for storage space.</p>"},{"location":"advanced/performance-tuning/#monitoring-and-profiling","title":"Monitoring and Profiling","text":""},{"location":"advanced/performance-tuning/#metrics-collection","title":"Metrics Collection","text":"<p>Collect performance metrics to identify bottlenecks:</p> <pre><code>// Get metrics\nmetrics := idx.CollectMetrics()\n\n// Log or export metrics\nfmt.Printf(\"Vector count: %d\\n\", metrics[\"vector_count\"])\nfmt.Printf(\"Search latency: %.2fms\\n\", metrics[\"search_latency_ms\"])\nfmt.Printf(\"Memory usage: %.2fMB\\n\", metrics[\"memory_usage_mb\"])\n</code></pre>"},{"location":"advanced/performance-tuning/#profiling","title":"Profiling","text":"<p>Use Go's built-in profiling tools:</p> <pre><code># CPU profiling\ngo test -bench=BenchmarkSearch -cpuprofile=cpu.prof\n\n# Memory profiling\ngo test -bench=BenchmarkSearch -memprofile=mem.prof\n\n# Analyze with pprof\ngo tool pprof cpu.prof\ngo tool pprof mem.prof\n</code></pre>"},{"location":"advanced/performance-tuning/#configuration-examples","title":"Configuration Examples","text":""},{"location":"advanced/performance-tuning/#small-dataset-100k-vectors","title":"Small Dataset (&lt;100K vectors)","text":"<pre><code>config := quiver.Config{\n    Dimension:       128,\n    StoragePath:     \"./data/small.db\",\n    Distance:        quiver.Cosine,\n    MaxElements:     100000,\n    HNSWM:           12,\n    HNSWEfConstruct: 150,\n    HNSWEfSearch:    80,\n    BatchSize:       500,\n    PersistInterval: 1 * time.Minute,\n}\n</code></pre>"},{"location":"advanced/performance-tuning/#medium-dataset-100k-1m-vectors","title":"Medium Dataset (100K-1M vectors)","text":"<pre><code>config := quiver.Config{\n    Dimension:       128,\n    StoragePath:     \"./data/medium.db\",\n    Distance:        quiver.Cosine,\n    MaxElements:     1000000,\n    HNSWM:           16,\n    HNSWEfConstruct: 200,\n    HNSWEfSearch:    100,\n    BatchSize:       1000,\n    PersistInterval: 5 * time.Minute,\n}\n</code></pre>"},{"location":"advanced/performance-tuning/#large-dataset-1m-vectors","title":"Large Dataset (&gt;1M vectors)","text":"<pre><code>config := quiver.Config{\n    Dimension:       128,\n    StoragePath:     \"./data/large.db\",\n    Distance:        quiver.Cosine,\n    MaxElements:     10000000,\n    HNSWM:           24,\n    HNSWEfConstruct: 300,\n    HNSWEfSearch:    150,\n    BatchSize:       5000,\n    PersistInterval: 10 * time.Minute,\n}\n</code></pre>"},{"location":"advanced/performance-tuning/#high-throughput-search","title":"High-Throughput Search","text":"<pre><code>config := quiver.Config{\n    Dimension:       128,\n    StoragePath:     \"./data/search_optimized.db\",\n    Distance:        quiver.Cosine,\n    MaxElements:     1000000,\n    HNSWM:           32,\n    HNSWEfConstruct: 400,\n    HNSWEfSearch:    80,  // Lower for faster search\n    BatchSize:       1000,\n    PersistInterval: 5 * time.Minute,\n}\n</code></pre>"},{"location":"advanced/performance-tuning/#high-accuracy-search","title":"High-Accuracy Search","text":"<pre><code>config := quiver.Config{\n    Dimension:       128,\n    StoragePath:     \"./data/accuracy_optimized.db\",\n    Distance:        quiver.Cosine,\n    MaxElements:     1000000,\n    HNSWM:           48,  // Higher for better graph quality\n    HNSWEfConstruct: 500, // Higher for better graph construction\n    HNSWEfSearch:    200, // Higher for more accurate search\n    BatchSize:       1000,\n    PersistInterval: 5 * time.Minute,\n}\n</code></pre>"},{"location":"advanced/performance-tuning/#next-steps","title":"Next Steps","text":"<p>Now that you've optimized Quiver's performance, check out:</p> <ul> <li>Benchmarking - Measure Quiver's performance</li> <li>HNSW Algorithm - Learn more about how HNSW works</li> <li>DuckDB Integration - Understand how Quiver uses DuckDB</li> </ul>"},{"location":"advanced/troubleshooting/","title":"Troubleshooting","text":"<p>Uh oh! Something's not quite right with your vector database? Don't worry, we've got your back! This guide will help you diagnose and fix common issues with Quiver. Let's turn those frowns upside down! \ud83d\udd0d</p>"},{"location":"advanced/troubleshooting/#common-issues","title":"Common Issues","text":""},{"location":"advanced/troubleshooting/#installation-problems","title":"Installation Problems","text":""},{"location":"advanced/troubleshooting/#go-installation-issues","title":"Go Installation Issues","text":"<p>Symptom: Error when installing Quiver with Go.</p> <pre><code>go: downloading github.com/weaviate/quiver v0.1.0\ngo get: github.com/weaviate/quiver@v0.1.0: parsing go.mod:\n module declares its path as: github.com/weaviate/quiver\n         but was required as: github.com/your-username/quiver\n</code></pre> <p>Solution: Make sure you're using the correct import path. If you've forked the repository, update your go.mod file:</p> <pre><code>go mod edit -replace github.com/weaviate/quiver=github.com/your-username/quiver@v0.1.0\n</code></pre>"},{"location":"advanced/troubleshooting/#python-installation-issues","title":"Python Installation Issues","text":"<p>Symptom: Error when installing the Python package.</p> <pre><code>ERROR: Could not build wheels for quiver which use PEP 517 and cannot be installed directly\n</code></pre> <p>Solution: Make sure you have the latest pip and build tools:</p> <pre><code>pip install --upgrade pip setuptools wheel\n</code></pre>"},{"location":"advanced/troubleshooting/#startup-issues","title":"Startup Issues","text":""},{"location":"advanced/troubleshooting/#storage-path-problems","title":"Storage Path Problems","text":"<p>Symptom: Error when starting Quiver with a storage path.</p> <pre><code>failed to open DuckDB: error creating new DuckDB database: Internal: IO Error: Could not read from file... Is a directory\n</code></pre> <p>Solution: Make sure you're providing a file path, not just a directory:</p> <pre><code>// Incorrect\nidx, err := quiver.New(quiver.Config{\n    StoragePath: \"/tmp/quiver\",\n}, logger)\n\n// Correct\nidx, err := quiver.New(quiver.Config{\n    StoragePath: \"/tmp/quiver/quiver.db\",\n}, logger)\n</code></pre>"},{"location":"advanced/troubleshooting/#permission-issues","title":"Permission Issues","text":"<p>Symptom: Permission denied errors when starting Quiver.</p> <pre><code>failed to open DuckDB: error creating new DuckDB database: Internal: IO Error: Permission denied\n</code></pre> <p>Solution: Make sure the user running Quiver has write permissions to the storage directory:</p> <pre><code># Give write permissions\nchmod 755 /path/to/storage/directory\n</code></pre>"},{"location":"advanced/troubleshooting/#vector-operations","title":"Vector Operations","text":""},{"location":"advanced/troubleshooting/#dimension-mismatch","title":"Dimension Mismatch","text":"<p>Symptom: Error when adding vectors with incorrect dimensions.</p> <pre><code>vector dimension mismatch: expected 128, got 64\n</code></pre> <p>Solution: Make sure all vectors have the same dimension as specified in the configuration:</p> <pre><code>// Make sure these match\nidx, err := quiver.New(quiver.Config{\n    Dimension: 128,\n}, logger)\n\n// Vector must have 128 dimensions\nvector := make([]float32, 128)\n</code></pre>"},{"location":"advanced/troubleshooting/#invalid-vector-ids","title":"Invalid Vector IDs","text":"<p>Symptom: Error when using invalid vector IDs.</p> <pre><code>vector ID 0 is reserved and cannot be used\n</code></pre> <p>Solution: Vector IDs must be positive integers and cannot be 0:</p> <pre><code>// Incorrect\nidx.Add(0, vector, metadata)\n\n// Correct\nidx.Add(1, vector, metadata)\n</code></pre>"},{"location":"advanced/troubleshooting/#search-issues","title":"Search Issues","text":""},{"location":"advanced/troubleshooting/#no-results-returned","title":"No Results Returned","text":"<p>Symptom: Search returns no results even though vectors are added.</p> <p>Solution: Check the following:</p> <ol> <li>Make sure you've added vectors to the index</li> <li>Check if your search parameters are too restrictive</li> <li>Verify that your query vector is normalized if your index uses cosine similarity</li> <li>If using filters, make sure they're not too restrictive</li> </ol> <pre><code>// Try increasing k\nresults, err := idx.Search(queryVector, 100, 1, 10)\n\n// Try increasing efSearch\nidx, err := quiver.New(quiver.Config{\n    HNSWEfSearch: 200, // Default is 100\n}, logger)\n</code></pre>"},{"location":"advanced/troubleshooting/#poor-search-quality","title":"Poor Search Quality","text":"<p>Symptom: Search results don't match expectations or have low similarity scores.</p> <p>Solution: Tune your HNSW parameters:</p> <pre><code>idx, err := quiver.New(quiver.Config{\n    HNSWM:           32,    // Default is 16, higher means more connections\n    HNSWEfConstruction: 200, // Default is 100, higher means better index quality\n    HNSWEfSearch:    100,   // Default is 100, higher means better search quality\n}, logger)\n</code></pre>"},{"location":"advanced/troubleshooting/#metadata-issues","title":"Metadata Issues","text":""},{"location":"advanced/troubleshooting/#sql-syntax-errors","title":"SQL Syntax Errors","text":"<p>Symptom: Error when using filters with incorrect SQL syntax.</p> <pre><code>failed to execute query: syntax error at or near \"WHERE\"\n</code></pre> <p>Solution: Make sure your SQL filter is valid:</p> <pre><code>// Incorrect\nresults, err := idx.SearchWithFilter(queryVector, 10, \"WHERE name = 'test'\")\n\n// Correct\nresults, err := idx.SearchWithFilter(queryVector, 10, \"name = 'test'\")\n</code></pre>"},{"location":"advanced/troubleshooting/#type-conversion-errors","title":"Type Conversion Errors","text":"<p>Symptom: Error when retrieving metadata with incorrect types.</p> <pre><code>cannot convert metadata field 'age' from string to int\n</code></pre> <p>Solution: Make sure you're using consistent types for metadata fields:</p> <pre><code>// When adding\nmetadata := map[string]interface{}{\n    \"age\": 30, // Use int consistently\n}\nidx.Add(1, vector, metadata)\n\n// When retrieving\nage := result.Metadata[\"age\"].(int) // Cast to int\n</code></pre>"},{"location":"advanced/troubleshooting/#performance-issues","title":"Performance Issues","text":""},{"location":"advanced/troubleshooting/#slow-addition","title":"Slow Addition","text":"<p>Symptom: Adding vectors is slower than expected.</p> <p>Solution: Use batch operations and tune batch size:</p> <pre><code>// Use batch operations\nvectors := make([][]float32, 1000)\nids := make([]uint64, 1000)\nmetadata := make([]map[string]interface{}, 1000)\n// Fill vectors, ids, and metadata...\nidx.BatchAdd(ids, vectors, metadata)\n\n// Tune batch size\nidx, err := quiver.New(quiver.Config{\n    BatchSize: 5000, // Default is 1000\n}, logger)\n</code></pre>"},{"location":"advanced/troubleshooting/#slow-search","title":"Slow Search","text":"<p>Symptom: Search operations are slower than expected.</p> <p>Solution: Tune search parameters and consider using in-memory storage:</p> <pre><code>// Use in-memory storage for faster search\nidx, err := quiver.New(quiver.Config{\n    StoragePath: \":memory:\",\n}, logger)\n\n// Reduce efSearch for faster (but potentially less accurate) search\nidx, err := quiver.New(quiver.Config{\n    HNSWEfSearch: 50, // Default is 100\n}, logger)\n</code></pre>"},{"location":"advanced/troubleshooting/#high-memory-usage","title":"High Memory Usage","text":"<p>Symptom: Quiver is using more memory than expected.</p> <p>Solution: Tune memory usage parameters:</p> <pre><code>idx, err := quiver.New(quiver.Config{\n    // Reduce batch size to lower memory usage during additions\n    BatchSize: 500, // Default is 1000\n\n    // Use disk storage instead of memory\n    StoragePath: \"/path/to/storage.db\",\n}, logger)\n</code></pre>"},{"location":"advanced/troubleshooting/#debugging-techniques","title":"Debugging Techniques","text":""},{"location":"advanced/troubleshooting/#enabling-debug-logging","title":"Enabling Debug Logging","text":"<p>To get more detailed information about what's happening inside Quiver, enable debug logging:</p> <pre><code>// Create a development logger with debug level\nconfig := zap.NewDevelopmentConfig()\nconfig.Level = zap.NewAtomicLevelAt(zap.DebugLevel)\nlogger, _ := config.Build()\n\n// Pass the logger to Quiver\nidx, err := quiver.New(quiver.Config{\n    // Your config here\n}, logger)\n</code></pre>"},{"location":"advanced/troubleshooting/#inspecting-the-index","title":"Inspecting the Index","text":"<p>You can inspect the index to verify its state:</p> <pre><code>// Get index stats\nstats, err := idx.Stats()\nfmt.Printf(\"Index stats: %+v\\n\", stats)\n\n// Check if a vector exists\nexists, err := idx.Exists(vectorID)\nfmt.Printf(\"Vector %d exists: %v\\n\", vectorID, exists)\n\n// Get a specific vector\nvector, metadata, err := idx.Get(vectorID)\nfmt.Printf(\"Vector %d: %v, Metadata: %v\\n\", vectorID, vector, metadata)\n</code></pre>"},{"location":"advanced/troubleshooting/#validating-metadata","title":"Validating Metadata","text":"<p>To validate that your metadata is stored correctly:</p> <pre><code>// Add a vector with metadata\nmetadata := map[string]interface{}{\n    \"name\": \"test\",\n    \"age\": 30,\n}\nidx.Add(1, vector, metadata)\n\n// Retrieve and validate\nvector, retrievedMetadata, err := idx.Get(1)\nfmt.Printf(\"Original metadata: %v\\n\", metadata)\nfmt.Printf(\"Retrieved metadata: %v\\n\", retrievedMetadata)\n\n// Check specific fields\nif retrievedMetadata[\"name\"] != metadata[\"name\"] {\n    fmt.Println(\"Metadata name mismatch!\")\n}\n</code></pre>"},{"location":"advanced/troubleshooting/#benchmarking","title":"Benchmarking","text":"<p>If you're experiencing performance issues, run benchmarks to identify bottlenecks:</p> <pre><code>// Simple benchmark function\nfunc benchmarkSearch(idx *quiver.Index, queryVector []float32, k int) time.Duration {\n    start := time.Now()\n    idx.Search(queryVector, k, 1, 10)\n    return time.Since(start)\n}\n\n// Run benchmark\ndurations := make([]time.Duration, 100)\nfor i := 0; i &lt; 100; i++ {\n    durations[i] = benchmarkSearch(idx, queryVector, 10)\n}\n\n// Calculate average\nvar total time.Duration\nfor _, d := range durations {\n    total += d\n}\naverage := total / time.Duration(len(durations))\nfmt.Printf(\"Average search time: %v\\n\", average)\n</code></pre> <p>For more detailed benchmarking, see the Benchmarking Guide.</p>"},{"location":"advanced/troubleshooting/#troubleshooting-http-api","title":"Troubleshooting HTTP API","text":""},{"location":"advanced/troubleshooting/#connection-issues","title":"Connection Issues","text":"<p>Symptom: Cannot connect to the HTTP API.</p> <p>Solution: Check the following:</p> <ol> <li>Verify the server is running: <code>ps aux | grep quiver</code></li> <li>Check the listening port: <code>netstat -tuln | grep 8080</code></li> <li>Ensure there are no firewall issues: <code>curl -v http://localhost:8080/health</code></li> </ol>"},{"location":"advanced/troubleshooting/#authentication-issues","title":"Authentication Issues","text":"<p>Symptom: Receiving 401 Unauthorized errors.</p> <p>Solution: Make sure you're providing the correct API key:</p> <pre><code># Incorrect\ncurl -X POST http://localhost:8080/vectors\n\n# Correct\ncurl -X POST http://localhost:8080/vectors -H \"Authorization: Bearer your-api-key\"\n</code></pre>"},{"location":"advanced/troubleshooting/#request-format-issues","title":"Request Format Issues","text":"<p>Symptom: Receiving 400 Bad Request errors.</p> <p>Solution: Validate your request format:</p> <pre><code># Use jq to validate JSON\necho '{\"id\": 1, \"vector\": [0.1, 0.2, 0.3], \"metadata\": {\"name\": \"test\"}}' | jq\n\n# Check your request with verbose output\ncurl -v -X POST http://localhost:8080/vectors \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"id\": 1, \"vector\": [0.1, 0.2, 0.3], \"metadata\": {\"name\": \"test\"}}'\n</code></pre>"},{"location":"advanced/troubleshooting/#troubleshooting-python-client","title":"Troubleshooting Python Client","text":""},{"location":"advanced/troubleshooting/#import-errors","title":"Import Errors","text":"<p>Symptom: Error when importing the Python client.</p> <pre><code>ImportError: No module named quiver\n</code></pre> <p>Solution: Make sure the package is installed and in your Python path:</p> <pre><code>pip install quiver-db\npython -c \"import quiver; print(quiver.__version__)\"\n</code></pre>"},{"location":"advanced/troubleshooting/#connection-issues_1","title":"Connection Issues","text":"<p>Symptom: Cannot connect to Quiver from Python.</p> <pre><code>ConnectionError: Failed to connect to Quiver server\n</code></pre> <p>Solution: Check the server URL and authentication:</p> <pre><code># Make sure the URL is correct\nclient = quiver.Client(\"http://localhost:8080\", api_key=\"your-api-key\")\n\n# Test the connection\ntry:\n    client.health()\n    print(\"Connection successful!\")\nexcept Exception as e:\n    print(f\"Connection failed: {e}\")\n</code></pre>"},{"location":"advanced/troubleshooting/#advanced-troubleshooting","title":"Advanced Troubleshooting","text":""},{"location":"advanced/troubleshooting/#database-corruption","title":"Database Corruption","text":"<p>Symptom: Errors indicating database corruption.</p> <pre><code>failed to open DuckDB: error opening existing DuckDB database: Internal: Database corrupted\n</code></pre> <p>Solution: Try to recover the database or create a new one:</p> <pre><code># Backup the corrupted database\ncp /path/to/quiver.db /path/to/quiver.db.bak\n\n# Create a new database\nrm /path/to/quiver.db\n</code></pre>"},{"location":"advanced/troubleshooting/#memory-leaks","title":"Memory Leaks","text":"<p>Symptom: Memory usage grows over time without releasing.</p> <p>Solution: Use Go's built-in profiling tools:</p> <pre><code>import _ \"net/http/pprof\"\n\nfunc main() {\n    // Start pprof server\n    go func() {\n        http.ListenAndServe(\"localhost:6060\", nil)\n    }()\n\n    // Your Quiver code here\n}\n</code></pre> <p>Then analyze with:</p> <pre><code>go tool pprof http://localhost:6060/debug/pprof/heap\n</code></pre>"},{"location":"advanced/troubleshooting/#deadlocks","title":"Deadlocks","text":"<p>Symptom: Operations hang indefinitely.</p> <p>Solution: Use Go's deadlock detector:</p> <pre><code># Set deadlock detection environment variable\nGODEBUG=deadlock=1 ./your-quiver-app\n</code></pre>"},{"location":"advanced/troubleshooting/#getting-help","title":"Getting Help","text":"<p>If you're still stuck after trying these troubleshooting steps, don't hesitate to reach out:</p> <ol> <li>GitHub Issues: Open an issue on the Quiver GitHub repository</li> <li>Discord: Join our community on Discord</li> <li>Stack Overflow: Ask a question with the <code>quiver</code> tag</li> </ol> <p>When asking for help, please include:</p> <ul> <li>Quiver version</li> <li>Go/Python version</li> <li>Operating system</li> <li>Minimal code example that reproduces the issue</li> <li>Error messages and logs</li> <li>Any relevant configuration</li> </ul>"},{"location":"advanced/troubleshooting/#next-steps","title":"Next Steps","text":"<p>Now that you've resolved your issues, check out:</p> <ul> <li>Performance Tuning - Optimize Quiver for your needs</li> <li>Benchmarking - Measure Quiver's performance</li> <li>Configuration Guide - Learn about all configuration options</li> </ul>"},{"location":"assets/icons/favicon-16x16.png/","title":"Favicon PNG Generation","text":"<p>This is a placeholder for the 16x16 PNG favicon.</p> <p>To generate this file from the SVG:</p> <pre><code>convert -background none -density 256x256 ../favicon.svg -resize 16x16 favicon-16x16.png\n</code></pre> <p>Or use an online SVG to PNG converter.</p>"},{"location":"assets/icons/favicon-32x32.png/","title":"Favicon PNG Generation","text":"<p>This is a placeholder for the 32x32 PNG favicon.</p> <p>To generate this file from the SVG:</p> <pre><code>convert -background none -density 256x256 ../favicon.svg -resize 32x32 favicon-32x32.png\n</code></pre> <p>Or use an online SVG to PNG converter.</p>"},{"location":"assets/icons/favicon.ico/","title":"Favicon Generation Instructions","text":"<p>To generate the favicon.ico file from the SVG, you can use the following tools:</p> <ol> <li>Using ImageMagick:</li> </ol> <pre><code>convert -background none -density 256x256 favicon.svg -define icon:auto-resize=16,32,48,64,128,256 favicon.ico\n</code></pre> <ol> <li>Using online converters:</li> <li>Upload the favicon.svg to a service like RealFaviconGenerator</li> <li> <p>Download the generated favicon.ico file</p> </li> <li> <p>Using Inkscape:</p> </li> </ol> <pre><code>inkscape favicon.svg --export-filename=favicon.png\nconvert favicon.png -define icon:auto-resize=16,32,48,64,128,256 favicon.ico\n</code></pre> <p>Place the generated favicon.ico file in this directory.</p>"},{"location":"assets/icons/favicon.ico/#recommended-favicon-set","title":"Recommended Favicon Set","text":"<p>For best compatibility across all devices, generate the following files:</p> <ul> <li>favicon.ico (16x16, 32x32, 48x48)</li> <li>favicon-16x16.png</li> <li>favicon-32x32.png</li> <li>apple-touch-icon.png (180x180)</li> <li>android-chrome-192x192.png</li> <li>android-chrome-512x512.png</li> </ul>"},{"location":"features/dimensionality-reduction/","title":"Dimensionality Reduction","text":"<p>Quiver includes built-in dimensionality reduction capabilities that can significantly improve performance and reduce storage requirements while maintaining search quality.</p>"},{"location":"features/dimensionality-reduction/#overview","title":"Overview","text":"<p>Dimensionality reduction is a technique used to reduce the number of features in a dataset while preserving as much information as possible. In the context of vector databases like Quiver, this means reducing the size of vectors without significantly impacting search quality.</p> <p>Benefits of dimensionality reduction include:</p> <ul> <li>Reduced storage requirements: Smaller vectors mean less storage space needed</li> <li>Improved search performance: Searching in lower-dimensional spaces is faster</li> <li>Reduced memory usage: Lower-dimensional vectors consume less memory</li> <li>Potential noise reduction: Removing less significant dimensions can reduce noise</li> </ul>"},{"location":"features/dimensionality-reduction/#how-it-works-in-quiver","title":"How It Works in Quiver","text":"<p>Quiver's dimensionality reduction happens at two key points:</p> <ol> <li>At insertion time: When vectors are added to the index, they are automatically reduced to the target dimension before storage.</li> <li>At query time: When searching, query vectors are reduced using the same method to ensure consistency.</li> </ol> <p>There is no separate background process - the reduction happens inline during these operations.</p>"},{"location":"features/dimensionality-reduction/#available-methods","title":"Available Methods","text":"<p>Quiver currently supports the following dimensionality reduction methods:</p> <ul> <li>PCA (Principal Component Analysis): A linear technique that identifies the directions (principal components) that maximize the variance in the data.</li> <li>t-SNE: (Coming soon) A non-linear technique that's particularly good at preserving local structure.</li> <li>UMAP: (Coming soon) A non-linear technique that can preserve both local and global structure.</li> </ul>"},{"location":"features/dimensionality-reduction/#configuration","title":"Configuration","text":"<p>To enable dimensionality reduction, you need to configure it when creating your index:</p> <pre><code>from quiver import Quiver\n\n# Create a Quiver index with dimensionality reduction\nindex = Quiver(\n    dimension=1536,  # Original dimension\n    enable_dim_reduction=True,\n    dim_reduction_method=\"PCA\",\n    dim_reduction_target=768,  # Target dimension\n)\n\n# Add vectors as usual - they'll be automatically reduced\nindex.add(id=1, vector=[...])  # 1536-dimensional vector\n</code></pre>"},{"location":"features/dimensionality-reduction/#configuration-options","title":"Configuration Options","text":"Option Description Default <code>enable_dim_reduction</code> Whether to enable dimensionality reduction <code>False</code> <code>dim_reduction_method</code> Method to use (<code>PCA</code>, <code>TSNE</code>, <code>UMAP</code>) <code>PCA</code> <code>dim_reduction_target</code> Target dimension <code>dimension / 2</code> <code>dim_reduction_adaptive</code> Whether to use adaptive dimensionality reduction <code>False</code> <code>dim_reduction_min_variance</code> Minimum variance to explain (0.0-1.0) for adaptive reduction <code>0.95</code>"},{"location":"features/dimensionality-reduction/#adaptive-dimensionality-reduction","title":"Adaptive Dimensionality Reduction","text":"<p>Quiver supports adaptive dimensionality reduction, which automatically determines the optimal number of dimensions based on the data. When enabled, Quiver will:</p> <ol> <li>Analyze the variance explained by each dimension</li> <li>Choose the minimum number of dimensions needed to explain the specified minimum variance</li> <li>Use this as the target dimension</li> </ol> <p>This is particularly useful when you don't know the optimal dimension in advance or when your data characteristics change over time.</p> <pre><code># Create a Quiver index with adaptive dimensionality reduction\nindex = Quiver(\n    dimension=1536,\n    enable_dim_reduction=True,\n    dim_reduction_method=\"PCA\",\n    dim_reduction_adaptive=True,\n    dim_reduction_min_variance=0.95,  # Preserve 95% of variance\n)\n</code></pre>"},{"location":"features/dimensionality-reduction/#explicit-reduction-api","title":"Explicit Reduction API","text":"<p>You can also use Quiver's dimensionality reduction API directly without storing vectors:</p> <pre><code># Reduce vectors explicitly\nreduced_vectors = index.reduce_vectors([\n    [0.1, 0.2, 0.3, ...],  # Original high-dimensional vectors\n    [0.4, 0.5, 0.6, ...],\n])\n</code></pre>"},{"location":"features/dimensionality-reduction/#best-practices","title":"Best Practices","text":"<ul> <li>Start with PCA: It's fast and works well for most use cases</li> <li>Use adaptive reduction when you're unsure about the optimal dimension</li> <li>Benchmark different settings: The optimal configuration depends on your specific data</li> <li>Consider the trade-off: Lower dimensions mean faster searches but potentially lower accuracy</li> <li>Test with your actual queries: Make sure the reduction doesn't negatively impact your specific use case</li> </ul>"},{"location":"features/metadata-filtering/","title":"Metadata &amp; Filtering","text":"<p>One of Quiver's superpowers is its ability to combine vector search with rich metadata filtering. Let's dive into how you can use metadata to supercharge your vector searches! \ud83d\udd0d</p>"},{"location":"features/metadata-filtering/#metadata-basics","title":"Metadata Basics","text":""},{"location":"features/metadata-filtering/#what-is-metadata","title":"What is Metadata?","text":"<p>In Quiver, metadata is structured information attached to each vector. It's stored as a map of string keys to arbitrary values:</p> <pre><code>metadata := map[string]interface{}{\n    \"category\": \"science\",\n    \"name\": \"black hole\",\n    \"tags\": []string{\"astronomy\", \"physics\"},\n    \"created_at\": time.Now().Unix(),\n    \"rating\": 4.8,\n    \"is_featured\": true,\n}\n</code></pre> <p>Metadata can include:</p> <ul> <li>Strings</li> <li>Numbers</li> <li>Booleans</li> <li>Arrays</li> <li>Nested objects</li> </ul>"},{"location":"features/metadata-filtering/#adding-metadata","title":"Adding Metadata","text":"<p>You add metadata when you add a vector:</p> <pre><code>idx.Add(1, vector, metadata)\n</code></pre> <p>Required Fields</p> <p>Quiver requires at least a <code>\"category\"</code> field in the metadata. This helps with organization and filtering.</p>"},{"location":"features/metadata-filtering/#retrieving-metadata","title":"Retrieving Metadata","text":"<p>When you search for vectors, the results include the metadata:</p> <pre><code>results, _ := idx.Search(queryVector, 10, 1, 10)\nfor _, result := range results {\n    fmt.Printf(\"ID: %d, Name: %s, Category: %s\\n\",\n        result.ID, \n        result.Metadata[\"name\"],\n        result.Metadata[\"category\"])\n}\n</code></pre>"},{"location":"features/metadata-filtering/#metadata-storage","title":"Metadata Storage","text":"<p>Behind the scenes, Quiver uses DuckDB to store and query metadata. This gives you the power of SQL for filtering and organizing your vectors.</p>"},{"location":"features/metadata-filtering/#schema","title":"Schema","text":"<p>Metadata is stored in a table with the following schema:</p> <pre><code>CREATE TABLE metadata (\n    id BIGINT PRIMARY KEY,\n    json JSON\n)\n</code></pre> <ul> <li><code>id</code>: The vector ID</li> <li><code>json</code>: The metadata as a JSON object</li> </ul> <p>This schema allows for flexible metadata while still enabling efficient queries.</p>"},{"location":"features/metadata-filtering/#filtering-with-sql","title":"Filtering with SQL","text":""},{"location":"features/metadata-filtering/#basic-filtering","title":"Basic Filtering","text":"<p>The simplest way to filter is with the <code>SearchWithFilter</code> method:</p> <pre><code>results, _ := idx.SearchWithFilter(queryVector, 10, \n    \"category = 'science'\")\n</code></pre> <p>The filter is a SQL WHERE clause that operates on the metadata.</p>"},{"location":"features/metadata-filtering/#advanced-filtering","title":"Advanced Filtering","text":"<p>You can use any SQL expression that DuckDB supports:</p> <pre><code>// Complex filter with multiple conditions\nfilter := `\n    category = 'science' \n    AND json_array_contains(tags, 'physics') \n    AND rating &gt; 4.0 \n    AND created_at &gt; 1609459200\n`\nresults, _ := idx.SearchWithFilter(queryVector, 10, filter)\n</code></pre>"},{"location":"features/metadata-filtering/#json-functions","title":"JSON Functions","text":"<p>DuckDB provides powerful JSON functions for querying nested data:</p> <pre><code>// Query nested properties\nfilter := `json_extract(json, '$.details.publisher') = 'Nature'`\nresults, _ := idx.SearchWithFilter(queryVector, 10, filter)\n</code></pre>"},{"location":"features/metadata-filtering/#array-operations","title":"Array Operations","text":"<p>You can query arrays in metadata:</p> <pre><code>// Check if an array contains a value\nfilter := `json_array_contains(tags, 'quantum')`\nresults, _ := idx.SearchWithFilter(queryVector, 10, filter)\n\n// Check array length\nfilter := `json_array_length(tags) &gt; 3`\nresults, _ := idx.SearchWithFilter(queryVector, 10, filter)\n</code></pre>"},{"location":"features/metadata-filtering/#direct-metadata-queries","title":"Direct Metadata Queries","text":""},{"location":"features/metadata-filtering/#querying-without-vectors","title":"Querying Without Vectors","text":"<p>You can query metadata directly without vector search:</p> <pre><code>// Query metadata using SQL\nresults, _ := idx.QueryMetadata(\n    \"SELECT * FROM metadata WHERE category = 'science' ORDER BY created_at DESC LIMIT 10\")\n</code></pre> <p>This returns a slice of metadata maps.</p>"},{"location":"features/metadata-filtering/#aggregations-and-analytics","title":"Aggregations and Analytics","text":"<p>You can use SQL aggregations for analytics:</p> <pre><code>// Count vectors by category\ncounts, _ := idx.QueryMetadata(\n    \"SELECT json_extract(json, '$.category') as category, COUNT(*) as count \" +\n    \"FROM metadata GROUP BY category ORDER BY count DESC\")\n</code></pre>"},{"location":"features/metadata-filtering/#hybrid-search-strategies","title":"Hybrid Search Strategies","text":""},{"location":"features/metadata-filtering/#two-stage-search","title":"Two-Stage Search","text":"<p>For large datasets, a two-stage search can be more efficient:</p> <ol> <li>First, filter the metadata to get a subset of IDs</li> <li>Then, perform vector search only on those IDs</li> </ol> <pre><code>// Step 1: Get IDs matching the filter\nidResults, _ := idx.QueryMetadata(\n    \"SELECT id FROM metadata WHERE category = 'science' AND rating &gt; 4.5\")\n\n// Extract IDs\nids := make([]uint64, len(idResults))\nfor i, result := range idResults {\n    ids[i] = result[\"id\"].(uint64)\n}\n\n// Step 2: Search only those IDs\nresults, _ := idx.SearchSubset(queryVector, ids, 10)\n</code></pre>"},{"location":"features/metadata-filtering/#faceted-search","title":"Faceted Search","text":"<p>Faceted search allows filtering by specific metadata facets:</p> <pre><code>// Search with facets\nresults, _ := idx.FacetedSearch(queryVector, 10, map[string]string{\n    \"category\": \"science\",\n    \"year\": \"2023\",\n})\n</code></pre>"},{"location":"features/metadata-filtering/#best-practices","title":"Best Practices","text":""},{"location":"features/metadata-filtering/#metadata-design","title":"Metadata Design","text":"<ul> <li>Keep metadata fields consistent across vectors</li> <li>Use a schema validation function for consistency</li> <li>Consider indexing frequently queried fields</li> <li>Use meaningful categories for organization</li> </ul>"},{"location":"features/metadata-filtering/#performance-tips","title":"Performance Tips","text":"<ul> <li>Avoid overly complex SQL queries on large datasets</li> <li>Use two-stage search for highly selective filters</li> <li>Cache common query results if possible</li> <li>Consider denormalizing data for faster queries</li> </ul>"},{"location":"features/metadata-filtering/#example-metadata-schemas","title":"Example Metadata Schemas","text":"<p>Document Vectors:</p> <pre><code>metadata := map[string]interface{}{\n    \"category\": \"document\",\n    \"title\": \"Quantum Computing Basics\",\n    \"author\": \"Jane Smith\",\n    \"tags\": []string{\"quantum\", \"computing\", \"tutorial\"},\n    \"created_at\": time.Now().Unix(),\n    \"word_count\": 2500,\n}\n</code></pre> <p>Product Vectors:</p> <pre><code>metadata := map[string]interface{}{\n    \"category\": \"product\",\n    \"name\": \"Wireless Headphones\",\n    \"brand\": \"AudioTech\",\n    \"price\": 99.99,\n    \"colors\": []string{\"black\", \"white\", \"blue\"},\n    \"in_stock\": true,\n    \"ratings\": map[string]interface{}{\n        \"average\": 4.7,\n        \"count\": 253,\n    },\n}\n</code></pre>"},{"location":"features/metadata-filtering/#next-steps","title":"Next Steps","text":"<p>Now that you've mastered metadata and filtering, check out:</p> <ul> <li>Persistence &amp; Backup - Keep your data safe</li> <li>Security - Secure your vector database</li> <li>HTTP API - Use Quiver as a service</li> </ul>"},{"location":"features/persistence-backup/","title":"Persistence &amp; Backup","text":"<p>Data is precious, and Quiver takes data safety seriously. Let's explore how Quiver keeps your vectors safe and sound, even when things go wrong! \ud83d\udee1\ufe0f</p>"},{"location":"features/persistence-backup/#persistence","title":"Persistence","text":""},{"location":"features/persistence-backup/#how-persistence-works","title":"How Persistence Works","text":"<p>Quiver automatically persists your index to disk at regular intervals. This ensures that your data is safe even if the application crashes or is terminated unexpectedly.</p> <p>The persistence process:</p> <ol> <li>Saves the HNSW graph structure</li> <li>Stores all vector data</li> <li>Persists metadata to DuckDB</li> <li>Updates the changelog</li> </ol>"},{"location":"features/persistence-backup/#configuring-persistence","title":"Configuring Persistence","text":"<p>You can configure how often Quiver persists data:</p> <pre><code>config := quiver.Config{\n    // ... other settings ...\n    PersistInterval: 5 * time.Minute, // Default is 5 minutes\n}\n</code></pre> <p>A shorter interval means less data loss in case of a crash, but more I/O overhead.</p>"},{"location":"features/persistence-backup/#manual-persistence","title":"Manual Persistence","text":"<p>You can also trigger persistence manually:</p> <pre><code>// Manually persist the index\nerr := idx.Save(\"./data/manual_save\")\nif err != nil {\n    log.Fatalf(\"Failed to save index: %v\", err)\n}\n</code></pre> <p>This is useful before shutting down or when you want to ensure all data is saved at a specific point.</p>"},{"location":"features/persistence-backup/#incremental-persistence","title":"Incremental Persistence","text":"<p>Quiver uses incremental persistence to minimize I/O:</p> <ol> <li>Only new or changed vectors are persisted</li> <li>The changelog tracks which vectors have changed</li> <li>The persistence worker only writes what's necessary</li> </ol> <p>This makes persistence efficient even with large indices.</p>"},{"location":"features/persistence-backup/#backup","title":"Backup","text":""},{"location":"features/persistence-backup/#automatic-backups","title":"Automatic Backups","text":"<p>Quiver can create automatic backups at regular intervals:</p> <pre><code>config := quiver.Config{\n    // ... other settings ...\n    BackupInterval:    1 * time.Hour,    // How often to create backups\n    BackupPath:        \"./backups\",      // Where to store backups\n    BackupCompression: true,             // Whether to compress backups\n    MaxBackups:        5,                // Maximum number of backups to keep\n}\n</code></pre> <p>Each backup includes:</p> <ul> <li>The complete HNSW graph</li> <li>All vector data</li> <li>All metadata</li> <li>Configuration settings</li> </ul>"},{"location":"features/persistence-backup/#manual-backups","title":"Manual Backups","text":"<p>You can also create backups manually:</p> <pre><code>// Create a full backup\nerr := idx.Backup(\"./backups/manual\", false, true)\nif err != nil {\n    log.Fatalf(\"Backup failed: %v\", err)\n}\n</code></pre> <p>The parameters are:</p> <ul> <li>Backup path</li> <li>Whether to create an incremental backup</li> <li>Whether to compress the backup</li> </ul>"},{"location":"features/persistence-backup/#incremental-backups","title":"Incremental Backups","text":"<p>For large indices, incremental backups can save time and space:</p> <pre><code>// Create an incremental backup\nerr := idx.Backup(\"./backups/incremental\", true, true)\n</code></pre> <p>Incremental backups only store what has changed since the last backup.</p>"},{"location":"features/persistence-backup/#backup-rotation","title":"Backup Rotation","text":"<p>Quiver automatically manages backup rotation:</p> <ol> <li>When <code>MaxBackups</code> is reached, the oldest backup is deleted</li> <li>This prevents backups from consuming too much disk space</li> <li>You always have the most recent backups available</li> </ol>"},{"location":"features/persistence-backup/#recovery","title":"Recovery","text":""},{"location":"features/persistence-backup/#loading-from-persistence","title":"Loading from Persistence","text":"<p>When you restart Quiver, it automatically loads from the persisted data:</p> <pre><code>// Load the index from disk\nidx, err := quiver.Load(config, logger)\nif err != nil {\n    log.Fatalf(\"Failed to load index: %v\", err)\n}\n</code></pre> <p>This restores the index to its last persisted state.</p>"},{"location":"features/persistence-backup/#restoring-from-backup","title":"Restoring from Backup","text":"<p>If you need to restore from a backup:</p> <pre><code>// Create a new index with the same configuration\nidx, _ := quiver.New(config, logger)\n\n// Restore from backup\nerr := idx.Restore(\"./backups/backup_20230615_120000\")\nif err != nil {\n    log.Fatalf(\"Restore failed: %v\", err)\n}\n</code></pre> <p>This completely replaces the current index with the data from the backup.</p>"},{"location":"features/persistence-backup/#disaster-recovery","title":"Disaster Recovery","text":"<p>For disaster recovery scenarios:</p> <ol> <li>Keep backups in a separate location (ideally off-site)</li> <li>Regularly test the restore process</li> <li>Consider using cloud storage for backups</li> <li>Document the recovery procedure</li> </ol>"},{"location":"features/persistence-backup/#best-practices","title":"Best Practices","text":""},{"location":"features/persistence-backup/#persistence-strategy","title":"Persistence Strategy","text":"<ul> <li>Use a shorter <code>PersistInterval</code> for critical data</li> <li>Manually trigger persistence before shutdowns</li> <li>Store data on reliable storage (SSD recommended)</li> <li>Monitor disk space to prevent running out</li> </ul>"},{"location":"features/persistence-backup/#backup-strategy","title":"Backup Strategy","text":"<ul> <li>Use compressed backups to save space</li> <li>Keep enough backups to meet your recovery point objective (RPO)</li> <li>Store backups in a different location than the primary data</li> <li>Regularly test the restore process</li> </ul>"},{"location":"features/persistence-backup/#example-configuration","title":"Example Configuration","text":"<pre><code>config := quiver.Config{\n    // ... core settings ...\n\n    // Persistence\n    PersistInterval: 2 * time.Minute,\n\n    // Backups\n    BackupInterval:    6 * time.Hour,\n    BackupPath:        \"/mnt/backup/quiver\",\n    BackupCompression: true,\n    MaxBackups:        24, // Keep 6 days worth\n}\n</code></pre>"},{"location":"features/persistence-backup/#monitoring","title":"Monitoring","text":"<p>Quiver provides metrics to monitor persistence and backup:</p> <pre><code>// Get metrics\nmetrics := idx.CollectMetrics()\n\n// Check persistence metrics\nfmt.Printf(\"Last persist time: %v\\n\", metrics[\"last_persist_time\"])\nfmt.Printf(\"Vectors since last persist: %v\\n\", metrics[\"vectors_since_last_persist\"])\n\n// Check backup metrics\nfmt.Printf(\"Last backup time: %v\\n\", metrics[\"last_backup_time\"])\nfmt.Printf(\"Backup count: %v\\n\", metrics[\"backup_count\"])\n</code></pre>"},{"location":"features/persistence-backup/#next-steps","title":"Next Steps","text":"<p>Now that you've learned how to keep your data safe, check out:</p> <ul> <li>Security - Secure your vector database</li> <li>Performance Tuning - Optimize Quiver for your needs</li> <li>HTTP API - Use Quiver as a service</li> </ul>"},{"location":"features/security/","title":"Security","text":"<p>Keeping your vector data safe is a top priority. Quiver provides several security features to protect your data from prying eyes and unauthorized access. Let's lock things down! \ud83d\udd12</p>"},{"location":"features/security/#encryption-at-rest","title":"Encryption at Rest","text":""},{"location":"features/security/#how-encryption-works","title":"How Encryption Works","text":"<p>Quiver can encrypt all data stored on disk, ensuring that even if someone gets access to your storage, they can't read your vectors or metadata.</p> <p>Encryption uses AES-GCM, a strong authenticated encryption algorithm:</p> <ol> <li>Each file is encrypted with a unique nonce</li> <li>The encryption key is derived from your provided key</li> <li>Both the data and its integrity are protected</li> </ol>"},{"location":"features/security/#enabling-encryption","title":"Enabling Encryption","text":"<p>To enable encryption, set the appropriate configuration options:</p> <pre><code>config := quiver.Config{\n    // ... other settings ...\n    EncryptionEnabled: true,\n    EncryptionKey:     \"your-secret-key-at-least-32-bytes-long\",\n}\n</code></pre> <p>Key Management</p> <p>Keep your encryption key safe! If you lose it, you won't be able to recover your data.</p>"},{"location":"features/security/#what-gets-encrypted","title":"What Gets Encrypted","text":"<p>When encryption is enabled, Quiver encrypts:</p> <ul> <li>Vector data files</li> <li>HNSW graph structure</li> <li>Metadata exports</li> <li>Backup files</li> </ul> <p>The DuckDB database is also encrypted as part of the process.</p>"},{"location":"features/security/#key-requirements","title":"Key Requirements","text":"<p>The encryption key must be:</p> <ul> <li>At least 32 bytes long (for AES-256)</li> <li>Kept secure and backed up</li> <li>Rotated periodically for best security</li> </ul> <p>If the key is longer than 32 bytes, it will be truncated.</p>"},{"location":"features/security/#api-security","title":"API Security","text":""},{"location":"features/security/#tlsssl","title":"TLS/SSL","text":"<p>When using Quiver's HTTP API, you can enable TLS to encrypt data in transit:</p> <pre><code>// Create the server\nserver := api.NewServer(api.ServerOptions{\n    Port:    \"8080\",\n    Prefork: false,\n}, idx, logger)\n\n// Start with TLS\nserver.StartTLS(\"server.crt\", \"server.key\")\n</code></pre> <p>This ensures that all communication between clients and the server is encrypted.</p>"},{"location":"features/security/#authentication","title":"Authentication","text":"<p>Quiver's API server supports basic authentication:</p> <pre><code>// Create the server with authentication\nserver := api.NewServer(api.ServerOptions{\n    Port:    \"8080\",\n    Prefork: false,\n    Auth: api.AuthOptions{\n        Enabled:  true,\n        Username: \"admin\",\n        Password: \"secure-password\",\n    },\n}, idx, logger)\n</code></pre> <p>For more advanced authentication, you can implement custom middleware:</p> <pre><code>// Add JWT authentication middleware\napp := server.GetApp()\napp.Use(jwtMiddleware())\n</code></pre>"},{"location":"features/security/#authorization","title":"Authorization","text":"<p>You can implement role-based access control using middleware:</p> <pre><code>// Add RBAC middleware\napp := server.GetApp()\napp.Use(rbacMiddleware())\n\n// Define routes with specific permissions\napp.Post(\"/admin/backup\", adminOnly(), backupHandler())\n</code></pre>"},{"location":"features/security/#network-security","title":"Network Security","text":""},{"location":"features/security/#binding-address","title":"Binding Address","text":"<p>Control which network interfaces Quiver listens on:</p> <pre><code>// Only listen on localhost\nserver := api.NewServer(api.ServerOptions{\n    Host: \"127.0.0.1\",\n    Port: \"8080\",\n}, idx, logger)\n</code></pre>"},{"location":"features/security/#firewall-configuration","title":"Firewall Configuration","text":"<p>It's recommended to use a firewall to restrict access to Quiver:</p> <pre><code># Allow only specific IPs to access Quiver\nsudo ufw allow from 192.168.1.0/24 to any port 8080\n</code></pre>"},{"location":"features/security/#operational-security","title":"Operational Security","text":""},{"location":"features/security/#logging","title":"Logging","text":"<p>Quiver uses structured logging that can be integrated with security monitoring systems:</p> <pre><code>// Create a production logger with specific log level\nlogger, _ := zap.NewProduction(zap.IncreaseLevel(zap.InfoLevel))\n</code></pre> <p>Sensitive information is never logged.</p>"},{"location":"features/security/#metrics-and-monitoring","title":"Metrics and Monitoring","text":"<p>Monitor security-related metrics:</p> <pre><code>// Get metrics\nmetrics := idx.CollectMetrics()\n\n// Check security metrics\nfmt.Printf(\"Encryption enabled: %v\\n\", metrics[\"encryption_enabled\"])\nfmt.Printf(\"Authentication failures: %v\\n\", metrics[\"auth_failures\"])\n</code></pre>"},{"location":"features/security/#secure-configuration","title":"Secure Configuration","text":"<p>Keep your configuration secure:</p> <ul> <li>Don't hardcode encryption keys or credentials</li> <li>Use environment variables or a secure vault</li> <li>Restrict access to configuration files</li> </ul> <pre><code>// Load encryption key from environment\nconfig := quiver.Config{\n    // ... other settings ...\n    EncryptionEnabled: true,\n    EncryptionKey:     os.Getenv(\"QUIVER_ENCRYPTION_KEY\"),\n}\n</code></pre>"},{"location":"features/security/#security-best-practices","title":"Security Best Practices","text":""},{"location":"features/security/#defense-in-depth","title":"Defense in Depth","text":"<p>Implement multiple layers of security:</p> <ol> <li>Network security (firewalls, VPNs)</li> <li>Transport security (TLS)</li> <li>Authentication and authorization</li> <li>Encryption at rest</li> <li>Secure operations and monitoring</li> </ol>"},{"location":"features/security/#regular-updates","title":"Regular Updates","text":"<p>Keep Quiver and its dependencies up to date:</p> <pre><code>go get -u github.com/TFMV/quiver\n</code></pre>"},{"location":"features/security/#security-audits","title":"Security Audits","text":"<p>Regularly audit your Quiver deployment:</p> <ul> <li>Check access logs for suspicious activity</li> <li>Verify encryption is working correctly</li> <li>Test authentication and authorization</li> <li>Review network security</li> </ul>"},{"location":"features/security/#example-secure-configuration","title":"Example Secure Configuration","text":"<pre><code>// Secure production configuration\nconfig := quiver.Config{\n    // ... core settings ...\n\n    // Security\n    EncryptionEnabled: true,\n    EncryptionKey:     os.Getenv(\"QUIVER_ENCRYPTION_KEY\"),\n}\n\n// Secure API server\nserver := api.NewServer(api.ServerOptions{\n    Host:    \"0.0.0.0\",  // Listen on all interfaces\n    Port:    \"8443\",     // HTTPS port\n    Prefork: false,\n\n    // Authentication\n    Auth: api.AuthOptions{\n        Enabled:  true,\n        Username: os.Getenv(\"QUIVER_API_USER\"),\n        Password: os.Getenv(\"QUIVER_API_PASSWORD\"),\n    },\n\n    // Rate limiting\n    RateLimit: api.RateLimitOptions{\n        Enabled:    true,\n        MaxRequests: 100,\n        TimeWindow:  time.Minute,\n    },\n}, idx, logger)\n\n// Start with TLS\nserver.StartTLS(\"/etc/certs/server.crt\", \"/etc/certs/server.key\")\n</code></pre>"},{"location":"features/security/#next-steps","title":"Next Steps","text":"<p>Now that you've secured your Quiver deployment, check out:</p> <ul> <li>HTTP API - Use Quiver as a service</li> <li>Performance Tuning - Optimize Quiver for your needs</li> <li>Benchmarking - Measure Quiver's performance</li> </ul>"},{"location":"features/vector-operations/","title":"Vector Operations","text":"<p>Quiver offers a rich set of vector operations to help you manage and search your vector database. Let's explore all the ways you can sling vectors around! \ud83c\udff9</p>"},{"location":"features/vector-operations/#adding-vectors","title":"Adding Vectors","text":""},{"location":"features/vector-operations/#basic-addition","title":"Basic Addition","text":"<p>The most fundamental operation is adding a vector to the index:</p> <pre><code>// Add a single vector with ID 1\nerr := idx.Add(1, []float32{0.1, 0.2, 0.3, ...}, map[string]interface{}{\n    \"category\": \"science\",\n    \"name\": \"black hole\",\n})\n</code></pre> <p>Each vector needs:</p> <ul> <li>A unique ID (uint64)</li> <li>The vector data ([]float32)</li> <li>Metadata (map[string]interface{})</li> </ul> <p>Required Metadata</p> <p>Quiver requires at least a <code>\"category\"</code> field in the metadata. This helps with organization and filtering.</p>"},{"location":"features/vector-operations/#batch-addition","title":"Batch Addition","text":"<p>For better performance when adding many vectors, Quiver automatically batches additions:</p> <pre><code>// Add 1000 vectors in a loop\nfor i := 0; i &lt; 1000; i++ {\n    vector := generateRandomVector(dimension)\n    metadata := map[string]interface{}{\n        \"category\": \"batch\",\n        \"index\": i,\n    }\n    idx.Add(uint64(i), vector, metadata)\n}\n</code></pre> <p>The vectors will be added to a batch buffer and inserted into the index when:</p> <ol> <li>The batch size reaches the configured limit (<code>BatchSize</code>)</li> <li>You explicitly call <code>idx.flushBatch()</code></li> <li>You close the index with <code>idx.Close()</code></li> </ol>"},{"location":"features/vector-operations/#arrow-integration","title":"Arrow Integration","text":"<p>For even faster bulk loading, Quiver supports Apache Arrow:</p> <pre><code>// Create Arrow record with vectors and metadata\nbuilder := array.NewRecordBuilder(memory.DefaultAllocator, quiver.NewVectorSchema(dimension))\n// ... populate the builder ...\nrecord := builder.NewRecord()\n\n// Add all vectors from the Arrow record\nerr := idx.AppendFromArrow(record)\n</code></pre> <p>This is the fastest way to add vectors, especially when loading from external sources.</p>"},{"location":"features/vector-operations/#searching-vectors","title":"Searching Vectors","text":""},{"location":"features/vector-operations/#basic-search","title":"Basic Search","text":"<p>The most common operation is searching for similar vectors:</p> <pre><code>// Search for the 10 most similar vectors\nresults, err := idx.Search(queryVector, 10, 1, 10)\n</code></pre> <p>The parameters are:</p> <ul> <li><code>queryVector</code>: The vector to search for</li> <li><code>k</code>: Number of results to return</li> <li><code>page</code>: Page number (1-indexed)</li> <li><code>pageSize</code>: Number of results per page</li> </ul> <p>The results include:</p> <ul> <li>Vector ID</li> <li>Distance (similarity score)</li> <li>Metadata</li> </ul> <pre><code>for i, result := range results {\n    fmt.Printf(\"%d. ID: %d, Distance: %.4f, Name: %s\\n\", \n        i+1, result.ID, result.Distance, result.Metadata[\"name\"])\n}\n</code></pre>"},{"location":"features/vector-operations/#hybrid-search-vector-metadata","title":"Hybrid Search (Vector + Metadata)","text":"<p>Combine vector similarity with metadata filtering:</p> <pre><code>// Find vectors similar to queryVector that match the filter\nresults, err := idx.SearchWithFilter(queryVector, 10, \n    \"category = 'science' AND json_array_contains(tags, 'physics')\")\n</code></pre> <p>The filter is a SQL WHERE clause that operates on the metadata.</p> <p>SQL Power</p> <p>The filter uses DuckDB's SQL engine, so you can use any SQL expression that DuckDB supports!</p>"},{"location":"features/vector-operations/#search-with-negative-examples","title":"Search with Negative Examples","text":"<p>Find vectors similar to A but dissimilar to B:</p> <pre><code>// Define what we like and what we don't like\npositiveVector := []float32{0.1, 0.2, 0.3, ...}\nnegativeVectors := [][]float32{\n    {0.9, 0.8, 0.7, ...},\n    {0.8, 0.7, 0.6, ...},\n}\n\n// Search with negative examples\nresults, err := idx.SearchWithNegatives(\n    positiveVector,    // What we're looking for\n    negativeVectors,   // What we want to avoid\n    10, 1, 10)         // k, page, pageSize\n</code></pre> <p>This is great for:</p> <ul> <li>Recommendation systems (\"more like this, less like that\")</li> <li>Refining search results based on user feedback</li> <li>Exploring different regions of the vector space</li> </ul>"},{"location":"features/vector-operations/#faceted-search","title":"Faceted Search","text":"<p>Search with specific metadata facets:</p> <pre><code>// Search with facets\nresults, err := idx.FacetedSearch(queryVector, 10, map[string]string{\n    \"category\": \"science\",\n    \"year\": \"2023\",\n})\n</code></pre>"},{"location":"features/vector-operations/#multi-vector-search","title":"Multi-Vector Search","text":"<p>Search with multiple query vectors:</p> <pre><code>// Search with multiple query vectors\nmultiResults, err := idx.MultiVectorSearch(\n    [][]float32{vector1, vector2, vector3}, \n    5)\n</code></pre> <p>This returns a slice of result slices, one for each query vector.</p>"},{"location":"features/vector-operations/#metadata-operations","title":"Metadata Operations","text":""},{"location":"features/vector-operations/#querying-metadata","title":"Querying Metadata","text":"<p>You can query metadata directly without vector search:</p> <pre><code>// Query metadata using SQL\nresults, err := idx.QueryMetadata(\n    \"SELECT * FROM metadata WHERE category = 'science' ORDER BY created_at DESC LIMIT 10\")\n</code></pre> <p>This returns a slice of metadata maps.</p>"},{"location":"features/vector-operations/#performance-considerations","title":"Performance Considerations","text":""},{"location":"features/vector-operations/#search-performance","title":"Search Performance","text":"<ul> <li>The <code>HNSWEfSearch</code> parameter controls the trade-off between search speed and accuracy</li> <li>Higher values give more accurate results but slower searches</li> <li>For most applications, values between 50-200 provide a good balance</li> </ul>"},{"location":"features/vector-operations/#addition-performance","title":"Addition Performance","text":"<ul> <li>Batch additions are much faster than individual additions</li> <li>The <code>BatchSize</code> parameter controls how many vectors are batched before insertion</li> <li>Larger batch sizes improve throughput but increase memory usage</li> <li>Arrow integration provides the best performance for bulk loading</li> </ul>"},{"location":"features/vector-operations/#next-steps","title":"Next Steps","text":"<p>Now that you've mastered vector operations, check out:</p> <ul> <li>Metadata &amp; Filtering - Learn more about metadata and filtering</li> <li>Persistence &amp; Backup - Keep your data safe</li> <li>HTTP API - Use Quiver as a service</li> </ul>"},{"location":"features/vector-search/","title":"Vector Search","text":"<p>Vector search is the core functionality of Quiver, allowing you to find similar vectors based on their semantic similarity. This guide explains how vector search works in Quiver and how to use it effectively.</p>"},{"location":"features/vector-search/#how-vector-search-works","title":"How Vector Search Works","text":"<p>Vector search in Quiver is powered by the HNSW (Hierarchical Navigable Small World) algorithm, which provides an excellent balance between search speed and accuracy. Here's how it works:</p> <ol> <li>Indexing: When you add vectors to Quiver, they are organized into a graph structure where similar vectors are connected.</li> <li>Search: When you search, Quiver navigates this graph to find the most similar vectors to your query.</li> <li>Distance Calculation: Similarity is measured using a distance metric (cosine or L2).</li> <li>Result Ranking: Results are ranked by similarity, with the most similar vectors first.</li> </ol>"},{"location":"features/vector-search/#basic-vector-search","title":"Basic Vector Search","text":"<p>The most basic form of vector search finds the k-nearest neighbors to a query vector:</p> <pre><code>from quiver import Quiver\n\n# Create a Quiver index\nindex = Quiver(dimension=128)\n\n# Add some vectors\nindex.add(id=1, vector=[0.1, 0.2, 0.3, ...], metadata={\"text\": \"Document 1\"})\nindex.add(id=2, vector=[0.2, 0.3, 0.4, ...], metadata={\"text\": \"Document 2\"})\nindex.add(id=3, vector=[0.3, 0.4, 0.5, ...], metadata={\"text\": \"Document 3\"})\n\n# Search for similar vectors\nquery_vector = [0.15, 0.25, 0.35, ...]\nresults = index.search(query=query_vector, k=2)\n\n# Print results\nfor result in results:\n    print(f\"ID: {result.id}, Distance: {result.distance}, Text: {result.metadata['text']}\")\n</code></pre>"},{"location":"features/vector-search/#search-parameters","title":"Search Parameters","text":"<p>Quiver's search function accepts several parameters to customize your search:</p> <pre><code>results = index.search(\n    query=query_vector,  # The query vector\n    k=10,                # Number of results to return\n    page=1,              # Page number (1-indexed)\n    page_size=10         # Number of results per page\n)\n</code></pre>"},{"location":"features/vector-search/#parameters","title":"Parameters","text":"<ul> <li>query: The query vector to search for</li> <li>k: Number of nearest neighbors to find</li> <li>page: Page number for pagination (1-indexed)</li> <li>page_size: Number of results per page</li> </ul>"},{"location":"features/vector-search/#distance-metrics","title":"Distance Metrics","text":"<p>Quiver supports two distance metrics:</p> <ol> <li>Cosine Distance (default): Measures the cosine of the angle between vectors (1 - cosine similarity)</li> <li>L2 Distance (Euclidean): Measures the straight-line distance between vectors</li> </ol> <p>You can specify the distance metric when creating the index:</p> <pre><code># Create an index with L2 distance\nindex = Quiver(dimension=128, distance=\"l2\")\n\n# Create an index with cosine distance (default)\nindex = Quiver(dimension=128, distance=\"cosine\")\n</code></pre>"},{"location":"features/vector-search/#which-distance-metric-to-use","title":"Which Distance Metric to Use?","text":"<ul> <li>Cosine Distance: Best for text embeddings and when vector magnitude doesn't matter</li> <li>L2 Distance: Best when vector magnitude is important (e.g., image embeddings)</li> </ul>"},{"location":"features/vector-search/#advanced-search-features","title":"Advanced Search Features","text":"<p>Quiver offers several advanced search features:</p>"},{"location":"features/vector-search/#search-with-metadata-filtering","title":"Search with Metadata Filtering","text":"<p>Filter search results based on metadata:</p> <pre><code>results = index.search_with_filter(\n    query=query_vector,\n    k=10,\n    filter=\"category = 'news' AND date &gt; '2023-01-01'\"\n)\n</code></pre>"},{"location":"features/vector-search/#search-with-negative-examples","title":"Search with Negative Examples","text":"<p>Find vectors similar to a positive example but dissimilar to negative examples:</p> <pre><code>results = index.search_with_negatives(\n    positive_query=positive_vector,\n    negative_queries=[negative_vector1, negative_vector2],\n    k=10\n)\n</code></pre>"},{"location":"features/vector-search/#multi-vector-search","title":"Multi-Vector Search","text":"<p>Search for multiple query vectors in a single call:</p> <pre><code>results = index.multi_vector_search(\n    queries=[query_vector1, query_vector2, query_vector3],\n    k=10\n)\n</code></pre>"},{"location":"features/vector-search/#faceted-search","title":"Faceted Search","text":"<p>Filter search results based on exact metadata field matches:</p> <pre><code>results = index.faceted_search(\n    query=query_vector,\n    k=10,\n    facets={\n        \"category\": \"news\",\n        \"author\": \"John Doe\"\n    }\n)\n</code></pre>"},{"location":"features/vector-search/#performance-considerations","title":"Performance Considerations","text":"<p>To get the best performance from Quiver's vector search:</p> <ol> <li>Choose the right HNSW parameters:</li> <li>Higher <code>hnsw_m</code> values improve search quality but increase memory usage</li> <li> <p>Higher <code>hnsw_ef_search</code> values improve search accuracy but decrease speed</p> </li> <li> <p>Use dimensionality reduction for large vectors:</p> </li> <li>Enable dimensionality reduction for vectors with more than 1000 dimensions</li> <li> <p>This can significantly improve search speed with minimal impact on accuracy</p> </li> <li> <p>Batch similar operations:</p> </li> <li>Use batch operations when adding or searching multiple vectors</li> <li> <p>This reduces overhead and improves throughput</p> </li> <li> <p>Consider pagination for large result sets:</p> </li> <li>Use the <code>page</code> and <code>page_size</code> parameters to paginate results</li> <li>This reduces memory usage and improves response times</li> </ol>"},{"location":"features/vector-search/#best-practices","title":"Best Practices","text":"<ol> <li>Normalize vectors before adding them to the index (especially for L2 distance)</li> <li>Use consistent embedding models for queries and indexed vectors</li> <li>Add meaningful metadata to make search results more useful</li> <li>Use the right distance metric for your use case</li> <li>Tune HNSW parameters based on your specific requirements</li> <li>Consider using dimensionality reduction for very high-dimensional vectors</li> </ol>"},{"location":"features/vector-search/#next-steps","title":"Next Steps","text":"<ul> <li>Metadata Filtering - Learn how to filter search results based on metadata</li> <li>Hybrid Search - Combine vector search with metadata filtering</li> <li>Dimensionality Reduction - Improve performance with dimensionality reduction</li> <li>Performance Tuning - Fine-tune Quiver's performance</li> </ul>"},{"location":"getting-started/configuration/","title":"Configuration","text":"<p>Quiver is highly configurable to meet your specific needs. Let's dive into all the knobs and dials you can tweak to make Quiver purr like a well-tuned sports car! \ud83c\udfce\ufe0f</p>"},{"location":"getting-started/configuration/#configuration-options","title":"Configuration Options","text":"<p>Here's the full <code>Config</code> struct with all available options:</p> <pre><code>type Config struct {\n    // Core settings\n    Dimension       int            // Vector dimension\n    StoragePath     string         // Base directory for storing index files\n    Distance        DistanceMetric // Cosine or L2\n    MaxElements     uint64         // Maximum number of vectors\n\n    // HNSW algorithm parameters\n    HNSWM           int            // Number of connections per element\n    HNSWEfConstruct int            // Construction quality parameter\n    HNSWEfSearch    int            // Search quality parameter\n\n    // Performance settings\n    BatchSize       int            // Number of vectors to batch before insertion\n\n    // Persistence configuration\n    PersistInterval time.Duration  // How often to persist index to disk\n\n    // Backup configuration\n    BackupInterval    time.Duration // How often to create backups\n    BackupPath        string        // Path to store backups\n    BackupCompression bool          // Whether to compress backups\n    MaxBackups        int           // Maximum number of backups to keep\n\n    // Security configuration\n    EncryptionEnabled bool          // Whether to encrypt data at rest\n    EncryptionKey     string        // Key for encrypting data at rest\n}\n</code></pre>"},{"location":"getting-started/configuration/#core-settings","title":"Core Settings","text":""},{"location":"getting-started/configuration/#dimension","title":"Dimension","text":"<p>The dimension of your vectors. This must match the output dimension of your embedding model.</p> <pre><code>Dimension: 768, // For BERT embeddings\n</code></pre> <p>Immutable Setting</p> <p>Once you create an index with a specific dimension, you cannot change it later.</p>"},{"location":"getting-started/configuration/#storagepath","title":"StoragePath","text":"<p>Where Quiver will store its data. This can be:</p> <ul> <li>A path to a directory (e.g., <code>\"./data\"</code>)</li> <li>A path to a specific file (e.g., <code>\"./data/quiver.db\"</code>)</li> <li><code>:memory:</code> for an in-memory database (no persistence)</li> </ul> <pre><code>StoragePath: \"./data/my_vectors.db\",\n</code></pre>"},{"location":"getting-started/configuration/#distance","title":"Distance","text":"<p>The distance metric to use for similarity calculations:</p> <pre><code>Distance: quiver.Cosine, // Options: quiver.Cosine, quiver.L2\n</code></pre> <ul> <li><code>Cosine</code>: Measures the cosine of the angle between vectors (good for text embeddings)</li> <li><code>L2</code>: Euclidean distance (good for image embeddings)</li> </ul>"},{"location":"getting-started/configuration/#maxelements","title":"MaxElements","text":"<p>The maximum number of vectors your index will hold:</p> <pre><code>MaxElements: 1000000, // 1 million vectors\n</code></pre> <p>Setting this appropriately helps Quiver allocate memory efficiently.</p>"},{"location":"getting-started/configuration/#hnsw-algorithm-parameters","title":"HNSW Algorithm Parameters","text":"<p>These parameters control the HNSW graph that powers Quiver's lightning-fast searches.</p>"},{"location":"getting-started/configuration/#hnswm","title":"HNSWM","text":"<p>The number of connections per element in the graph:</p> <pre><code>HNSWM: 16, // Default is 16\n</code></pre> <p>Higher values create more connections, which can improve search quality but increase memory usage and construction time.</p> <p>Rule of Thumb</p> <p>Values between 12-64 work well for most applications. Start with 16 and adjust if needed.</p>"},{"location":"getting-started/configuration/#hnswefconstruct","title":"HNSWEfConstruct","text":"<p>Controls the quality of graph construction:</p> <pre><code>HNSWEfConstruct: 200, // Default is 200\n</code></pre> <p>Higher values create a better graph but slow down construction.</p>"},{"location":"getting-started/configuration/#hnswefsearch","title":"HNSWEfSearch","text":"<p>Controls the quality of search:</p> <pre><code>HNSWEfSearch: 100, // Default is 100\n</code></pre> <p>Higher values improve search quality but slow down search speed.</p> <p>Balancing Act</p> <p>For most applications, values between 50-200 provide a good balance. If you need more precision, increase this value.</p>"},{"location":"getting-started/configuration/#performance-settings","title":"Performance Settings","text":""},{"location":"getting-started/configuration/#batchsize","title":"BatchSize","text":"<p>The number of vectors to accumulate before adding them to the index:</p> <pre><code>BatchSize: 1000, // Default is 1000\n</code></pre> <p>Larger batch sizes can improve throughput for bulk loading but increase memory usage.</p>"},{"location":"getting-started/configuration/#persistence-configuration","title":"Persistence Configuration","text":""},{"location":"getting-started/configuration/#persistinterval","title":"PersistInterval","text":"<p>How often to automatically save the index to disk:</p> <pre><code>PersistInterval: 5 * time.Minute, // Default is 5 minutes\n</code></pre>"},{"location":"getting-started/configuration/#backup-configuration","title":"Backup Configuration","text":""},{"location":"getting-started/configuration/#backupinterval","title":"BackupInterval","text":"<p>How often to create backups:</p> <pre><code>BackupInterval: 1 * time.Hour, // Default is 1 hour\n</code></pre>"},{"location":"getting-started/configuration/#backuppath","title":"BackupPath","text":"<p>Where to store backups:</p> <pre><code>BackupPath: \"./backups\", // Default is StoragePath/backups\n</code></pre>"},{"location":"getting-started/configuration/#backupcompression","title":"BackupCompression","text":"<p>Whether to compress backups to save space:</p> <pre><code>BackupCompression: true, // Default is true\n</code></pre>"},{"location":"getting-started/configuration/#maxbackups","title":"MaxBackups","text":"<p>Maximum number of backups to keep:</p> <pre><code>MaxBackups: 5, // Default is 5\n</code></pre>"},{"location":"getting-started/configuration/#security-configuration","title":"Security Configuration","text":""},{"location":"getting-started/configuration/#encryptionenabled","title":"EncryptionEnabled","text":"<p>Whether to encrypt data at rest:</p> <pre><code>EncryptionEnabled: true, // Default is false\n</code></pre>"},{"location":"getting-started/configuration/#encryptionkey","title":"EncryptionKey","text":"<p>The key used for encryption:</p> <pre><code>EncryptionKey: \"your-secret-key-at-least-32-bytes-long\",\n</code></pre> <p>Key Length</p> <p>The encryption key must be at least 32 bytes long. If it's longer, it will be truncated.</p>"},{"location":"getting-started/configuration/#configuration-examples","title":"Configuration Examples","text":""},{"location":"getting-started/configuration/#minimal-configuration","title":"Minimal Configuration","text":"<pre><code>config := quiver.Config{\n    Dimension:   128,\n    StoragePath: \"./data\",\n}\n</code></pre>"},{"location":"getting-started/configuration/#production-configuration","title":"Production Configuration","text":"<pre><code>config := quiver.Config{\n    // Core settings\n    Dimension:       768,\n    StoragePath:     \"/var/lib/quiver/production.db\",\n    Distance:        quiver.Cosine,\n    MaxElements:     10000000,\n\n    // HNSW parameters\n    HNSWM:           32,\n    HNSWEfConstruct: 200,\n    HNSWEfSearch:    100,\n\n    // Performance\n    BatchSize:       5000,\n\n    // Persistence\n    PersistInterval: 10 * time.Minute,\n\n    // Backups\n    BackupInterval:    1 * time.Hour,\n    BackupPath:        \"/var/backups/quiver\",\n    BackupCompression: true,\n    MaxBackups:        24, // Keep a day's worth\n\n    // Security\n    EncryptionEnabled: true,\n    EncryptionKey:     os.Getenv(\"QUIVER_ENCRYPTION_KEY\"),\n}\n</code></pre>"},{"location":"getting-started/configuration/#in-memory-configuration-for-testing","title":"In-Memory Configuration (for Testing)","text":"<pre><code>config := quiver.Config{\n    Dimension:   128,\n    StoragePath: \":memory:\",\n    BatchSize:   100,\n}\n</code></pre>"},{"location":"getting-started/configuration/#environment-variables","title":"Environment Variables","text":"<p>Quiver doesn't directly use environment variables, but you can use them in your configuration:</p> <pre><code>config := quiver.Config{\n    Dimension:       128,\n    StoragePath:     os.Getenv(\"QUIVER_STORAGE_PATH\"),\n    EncryptionKey:   os.Getenv(\"QUIVER_ENCRYPTION_KEY\"),\n    MaxElements:     parseUint64(os.Getenv(\"QUIVER_MAX_ELEMENTS\")),\n}\n</code></pre>"},{"location":"getting-started/configuration/#next-steps","title":"Next Steps","text":"<p>Now that you've configured Quiver to your liking, check out:</p> <ul> <li>Vector Operations - Learn about all the vector operations</li> <li>Metadata &amp; Filtering - Master the art of hybrid search</li> </ul>"},{"location":"getting-started/installation/","title":"Installation","text":"<p>Getting Quiver up and running is as easy as shooting an arrow! Well, maybe easier. \ud83c\udfaf</p>"},{"location":"getting-started/installation/#go-package","title":"Go Package","text":"<p>The simplest way to use Quiver is as a Go package in your application:</p> <pre><code>go get github.com/TFMV/quiver\n</code></pre> <p>That's it! You're ready to import Quiver in your Go code:</p> <pre><code>import \"github.com/TFMV/quiver\"\n</code></pre>"},{"location":"getting-started/installation/#prerequisites","title":"Prerequisites","text":"<p>Quiver has minimal dependencies, but you'll need:</p> <ul> <li>Go 1.18 or later</li> <li>A C compiler (for DuckDB integration)</li> </ul>"},{"location":"getting-started/installation/#platform-support","title":"Platform Support","text":"<p>Quiver runs on:</p> <ul> <li>Linux (x86_64, ARM64)</li> <li>macOS (x86_64, Apple Silicon)</li> <li>Windows (x86_64)</li> </ul>"},{"location":"getting-started/installation/#building-from-source","title":"Building from Source","text":"<p>If you want to build Quiver from source (maybe you want to contribute or just like the smell of freshly compiled code), here's how:</p> <pre><code># Clone the repository\ngit clone https://github.com/TFMV/quiver.git\ncd quiver\n\n# Build the library\ngo build ./...\n\n# Run tests\ngo test ./...\n</code></pre>"},{"location":"getting-started/installation/#docker","title":"Docker","text":"<p>Prefer to keep things containerized? We've got you covered:</p> <pre><code># Pull the Quiver image\ndocker pull tfmv/quiver:latest\n\n# Run Quiver in a container\ndocker run -p 8080:8080 -v /path/to/data:/data tfmv/quiver\n</code></pre>"},{"location":"getting-started/installation/#verifying-your-installation","title":"Verifying Your Installation","text":"<p>Let's make sure everything is working:</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"github.com/TFMV/quiver\"\n    \"go.uber.org/zap\"\n)\n\nfunc main() {\n    // Create a logger\n    logger, _ := zap.NewDevelopment()\n\n    // Initialize Quiver\n    config := quiver.Config{\n        Dimension: 3,\n        StoragePath: \":memory:\", // In-memory for testing\n    }\n\n    idx, err := quiver.New(config, logger)\n    if err != nil {\n        panic(err)\n    }\n    defer idx.Close()\n\n    fmt.Println(\"Quiver initialized successfully!\")\n}\n</code></pre> <p>If this runs without errors, you're all set! \ud83c\udf89</p>"},{"location":"getting-started/installation/#next-steps","title":"Next Steps","text":"<p>Now that you have Quiver installed, check out the Quick Start Guide to learn how to use it.</p>"},{"location":"getting-started/quick-start/","title":"Quick Start","text":"<p>Ready to start slinging vectors at lightning speed? Let's get you up and running with Quiver in just a few minutes! \u26a1</p>"},{"location":"getting-started/quick-start/#the-30-second-version","title":"The 30-Second Version","text":"<pre><code>package main\n\nimport (\n    \"fmt\"\n    \"github.com/TFMV/quiver\"\n    \"go.uber.org/zap\"\n)\n\nfunc main() {\n    // Create a logger\n    logger, _ := zap.NewDevelopment()\n\n    // Initialize Quiver\n    idx, _ := quiver.New(quiver.Config{\n        Dimension: 128,\n        StoragePath: \"./quiver.db\",\n    }, logger)\n    defer idx.Close()\n\n    // Add a vector\n    vector := []float32{0.1, 0.2, 0.3, /* ... */}\n    idx.Add(1, vector, map[string]interface{}{\n        \"category\": \"example\",\n        \"name\": \"first vector\",\n    })\n\n    // Search for similar vectors\n    results, _ := idx.Search(vector, 10, 1, 10)\n    fmt.Println(\"Found:\", results[0].ID, results[0].Distance)\n}\n</code></pre>"},{"location":"getting-started/quick-start/#step-by-step-guide","title":"Step-by-Step Guide","text":""},{"location":"getting-started/quick-start/#1-initialize-quiver","title":"1. Initialize Quiver","text":"<p>First, you need to create a Quiver index. This is where all your vectors and metadata will be stored.</p> <pre><code>// Create a logger (Quiver uses zap for logging)\nlogger, _ := zap.NewDevelopment()\n\n// Configure Quiver\nconfig := quiver.Config{\n    Dimension:       128,    // Dimension of your vectors\n    StoragePath:     \"./data/quiver.db\", // Where to store the data\n    Distance:        quiver.Cosine,      // Distance metric (Cosine or L2)\n    MaxElements:     1000000, // Maximum number of vectors\n    HNSWM:           16,      // HNSW hyperparameter M\n    HNSWEfConstruct: 200,     // HNSW construction quality\n    HNSWEfSearch:    100,     // HNSW search quality\n    BatchSize:       1000,    // Batch size for insertions\n}\n\n// Create the index\nidx, err := quiver.New(config, logger)\nif err != nil {\n    panic(err)\n}\ndefer idx.Close() // Don't forget to close when done!\n</code></pre>"},{"location":"getting-started/quick-start/#2-add-vectors","title":"2. Add Vectors","text":"<p>Now let's add some vectors to the index. Each vector needs:</p> <ul> <li>A unique ID</li> <li>The vector data (a slice of float32)</li> <li>Optional metadata (a map of string to interface{})</li> </ul> <pre><code>// Create a vector (this would typically come from your embedding model)\nvector := []float32{0.1, 0.2, 0.3, /* ... and so on for your dimension */}\n\n// Add it to the index with metadata\nerr = idx.Add(1, vector, map[string]interface{}{\n    \"category\": \"science\",\n    \"name\": \"black hole\",\n    \"tags\": []string{\"astronomy\", \"physics\"},\n})\nif err != nil {\n    panic(err)\n}\n\n// Add more vectors\nidx.Add(2, []float32{0.2, 0.3, 0.4, /* ... */}, map[string]interface{}{\n    \"category\": \"science\",\n    \"name\": \"quantum mechanics\",\n    \"tags\": []string{\"physics\", \"quantum\"},\n})\n</code></pre>"},{"location":"getting-started/quick-start/#3-search-for-similar-vectors","title":"3. Search for Similar Vectors","text":"<p>The moment you've been waiting for - searching for similar vectors!</p> <pre><code>// Create a query vector\nqueryVector := []float32{0.15, 0.25, 0.35, /* ... */}\n\n// Search for the 5 most similar vectors\nresults, err := idx.Search(queryVector, 5, 1, 10)\nif err != nil {\n    panic(err)\n}\n\n// Print the results\nfor i, result := range results {\n    fmt.Printf(\"%d. ID: %d, Distance: %.4f, Name: %s\\n\", \n        i+1, result.ID, result.Distance, result.Metadata[\"name\"])\n}\n</code></pre>"},{"location":"getting-started/quick-start/#4-hybrid-search-vector-metadata","title":"4. Hybrid Search (Vector + Metadata)","text":"<p>One of Quiver's superpowers is combining vector search with metadata filtering:</p> <pre><code>// Search for similar vectors that match a metadata filter\nresults, err := idx.SearchWithFilter(queryVector, 5, \n    \"category = 'science' AND json_array_contains(tags, 'physics')\")\nif err != nil {\n    panic(err)\n}\n</code></pre>"},{"location":"getting-started/quick-start/#5-search-with-negative-examples","title":"5. Search with Negative Examples","text":"<p>Want to find vectors similar to A but dissimilar to B? Use negative examples:</p> <pre><code>// Define what we like and what we don't like\npositiveVector := []float32{0.1, 0.2, 0.3, /* ... */}\nnegativeVector := []float32{0.9, 0.8, 0.7, /* ... */}\n\n// Search with negative examples\nresults, err := idx.SearchWithNegatives(\n    positiveVector,           // What we're looking for\n    [][]float32{negativeVector}, // What we want to avoid\n    5, 1, 10)                    // k, page, pageSize\n</code></pre>"},{"location":"getting-started/quick-start/#whats-next","title":"What's Next?","text":"<p>Now that you've got the basics down, check out:</p> <ul> <li>Configuration Guide - Fine-tune Quiver for your needs</li> <li>Vector Operations - Learn about all the vector operations</li> <li>Metadata &amp; Filtering - Master the art of hybrid search</li> <li>HTTP API - Use Quiver as a service</li> </ul> <p>Happy vector searching! \ud83d\ude80</p>"},{"location":"usage/examples/","title":"Examples","text":"<p>Let's explore some real-world examples of how to use Quiver in different scenarios. These examples will help you understand how to integrate Quiver into your applications and get the most out of its features. \ud83d\ude80</p>"},{"location":"usage/examples/#semantic-search-engine","title":"Semantic Search Engine","text":"<p>This example shows how to build a simple semantic search engine for documents:</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"io/ioutil\"\n    \"path/filepath\"\n    \"strings\"\n\n    \"github.com/TFMV/quiver\"\n    \"github.com/sashabaranov/go-openai\"\n    \"go.uber.org/zap\"\n)\n\nfunc main() {\n    // Create a logger\n    logger, _ := zap.NewDevelopment()\n\n    // Initialize Quiver\n    idx, _ := quiver.New(quiver.Config{\n        Dimension:   1536,  // OpenAI embeddings dimension\n        StoragePath: \"./data/documents.db\",\n        Distance:    quiver.Cosine,\n    }, logger)\n    defer idx.Close()\n\n    // Initialize OpenAI client\n    openaiClient := openai.NewClient(\"your-api-key\")\n\n    // Index documents\n    docs, _ := loadDocuments(\"./documents\")\n    for i, doc := range docs {\n        // Get embedding from OpenAI\n        resp, _ := openaiClient.CreateEmbeddings(\n            context.Background(),\n            openai.EmbeddingRequest{\n                Input: []string{doc.Content},\n                Model: openai.AdaEmbeddingV2,\n            },\n        )\n\n        // Convert to float32\n        vector := make([]float32, len(resp.Data[0].Embedding))\n        for i, v := range resp.Data[0].Embedding {\n            vector[i] = float32(v)\n        }\n\n        // Add to Quiver\n        idx.Add(uint64(i), vector, map[string]interface{}{\n            \"category\": \"document\",\n            \"title\":    doc.Title,\n            \"path\":     doc.Path,\n            \"tags\":     doc.Tags,\n        })\n    }\n\n    // Search function\n    searchDocuments := func(query string) {\n        // Get embedding for query\n        resp, _ := openaiClient.CreateEmbeddings(\n            context.Background(),\n            openai.EmbeddingRequest{\n                Input: []string{query},\n                Model: openai.AdaEmbeddingV2,\n            },\n        )\n\n        // Convert to float32\n        queryVector := make([]float32, len(resp.Data[0].Embedding))\n        for i, v := range resp.Data[0].Embedding {\n            queryVector[i] = float32(v)\n        }\n\n        // Search\n        results, _ := idx.Search(queryVector, 5, 1, 5)\n\n        // Print results\n        fmt.Printf(\"Results for query: %s\\n\", query)\n        for i, result := range results {\n            fmt.Printf(\"%d. %s (%.4f)\\n\", i+1, result.Metadata[\"title\"], result.Distance)\n        }\n    }\n\n    // Example searches\n    searchDocuments(\"How does quantum computing work?\")\n    searchDocuments(\"Latest developments in AI\")\n}\n\ntype Document struct {\n    Title   string\n    Content string\n    Path    string\n    Tags    []string\n}\n\nfunc loadDocuments(dir string) ([]Document, error) {\n    // Implementation omitted for brevity\n    // This would load documents from files in the specified directory\n    return []Document{}, nil\n}\n</code></pre>"},{"location":"usage/examples/#product-recommendation-system","title":"Product Recommendation System","text":"<p>This example demonstrates how to build a product recommendation system:</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n\n    \"github.com/TFMV/quiver\"\n    \"go.uber.org/zap\"\n)\n\nfunc main() {\n    // Create a logger\n    logger, _ := zap.NewDevelopment()\n\n    // Initialize Quiver\n    idx, _ := quiver.New(quiver.Config{\n        Dimension:   128,\n        StoragePath: \"./data/products.db\",\n        Distance:    quiver.Cosine,\n    }, logger)\n    defer idx.Close()\n\n    // Load product embeddings\n    // In a real system, these would come from a model trained on product features\n    products := loadProductEmbeddings(\"./data/product_embeddings.json\")\n\n    // Add products to the index\n    for _, product := range products {\n        idx.Add(product.ID, product.Embedding, map[string]interface{}{\n            \"category\":    \"product\",\n            \"name\":        product.Name,\n            \"description\": product.Description,\n            \"price\":       product.Price,\n            \"brand\":       product.Brand,\n            \"tags\":        product.Tags,\n        })\n    }\n\n    // Get recommendations for a user\n    userID := uint64(12345)\n    userProfile := getUserProfile(userID)\n\n    // Get products the user has viewed or purchased\n    viewedProducts := getViewedProducts(userID)\n\n    // Create a positive query from the user profile\n    positiveQuery := userProfile.Embedding\n\n    // Create negative queries from products the user has already seen\n    negativeQueries := make([][]float32, len(viewedProducts))\n    for i, product := range viewedProducts {\n        negativeQueries[i] = product.Embedding\n    }\n\n    // Search with negative examples to avoid recommending products the user has already seen\n    results, _ := idx.SearchWithNegatives(positiveQuery, negativeQueries, 10, 1, 10)\n\n    // Filter by price range\n    results, _ = idx.SearchWithFilter(positiveQuery, 10, \n        fmt.Sprintf(\"price &gt;= %f AND price &lt;= %f\", userProfile.MinPrice, userProfile.MaxPrice))\n\n    // Print recommendations\n    fmt.Printf(\"Recommendations for user %d:\\n\", userID)\n    for i, result := range results {\n        fmt.Printf(\"%d. %s - $%.2f\\n\", \n            i+1, \n            result.Metadata[\"name\"], \n            result.Metadata[\"price\"])\n    }\n}\n\n// Placeholder functions and types\ntype Product struct {\n    ID          uint64\n    Name        string\n    Description string\n    Price       float64\n    Brand       string\n    Tags        []string\n    Embedding   []float32\n}\n\ntype UserProfile struct {\n    Embedding []float32\n    MinPrice  float64\n    MaxPrice  float64\n}\n\nfunc loadProductEmbeddings(path string) []Product {\n    // Implementation omitted for brevity\n    return []Product{}\n}\n\nfunc getUserProfile(userID uint64) UserProfile {\n    // Implementation omitted for brevity\n    return UserProfile{}\n}\n\nfunc getViewedProducts(userID uint64) []Product {\n    // Implementation omitted for brevity\n    return []Product{}\n}\n</code></pre>"},{"location":"usage/examples/#image-similarity-search","title":"Image Similarity Search","text":"<p>This example shows how to use Quiver for image similarity search:</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"image\"\n    _ \"image/jpeg\"\n    _ \"image/png\"\n    \"os\"\n    \"path/filepath\"\n\n    \"github.com/TFMV/quiver\"\n    \"github.com/nfnt/resize\"\n    \"go.uber.org/zap\"\n    \"gorgonia.org/tensor\"\n)\n\nfunc main() {\n    // Create a logger\n    logger, _ := zap.NewDevelopment()\n\n    // Initialize Quiver\n    idx, _ := quiver.New(quiver.Config{\n        Dimension:   512,  // ResNet feature dimension\n        StoragePath: \"./data/images.db\",\n        Distance:    quiver.L2,  // L2 is better for image features\n    }, logger)\n    defer idx.Close()\n\n    // Load pre-trained model (placeholder)\n    model := loadResNetModel()\n\n    // Index images\n    imageDir := \"./images\"\n    files, _ := filepath.Glob(filepath.Join(imageDir, \"*.jpg\"))\n\n    for i, file := range files {\n        // Load and preprocess image\n        img, _ := loadImage(file)\n        resized := resize.Resize(224, 224, img, resize.Lanczos3)\n\n        // Extract features using the model\n        features := extractFeatures(model, resized)\n\n        // Add to Quiver\n        idx.Add(uint64(i), features, map[string]interface{}{\n            \"category\": \"image\",\n            \"path\":     file,\n            \"filename\": filepath.Base(file),\n        })\n    }\n\n    // Search for similar images\n    queryImage, _ := loadImage(\"./query.jpg\")\n    queryResized := resize.Resize(224, 224, queryImage, resize.Lanczos3)\n    queryFeatures := extractFeatures(model, queryResized)\n\n    results, _ := idx.Search(queryFeatures, 10, 1, 10)\n\n    // Print results\n    fmt.Println(\"Similar images:\")\n    for i, result := range results {\n        fmt.Printf(\"%d. %s (Distance: %.4f)\\n\", \n            i+1, \n            result.Metadata[\"filename\"], \n            result.Distance)\n    }\n}\n\n// Placeholder functions\nfunc loadResNetModel() interface{} {\n    // Implementation omitted for brevity\n    return nil\n}\n\nfunc loadImage(path string) (image.Image, error) {\n    file, err := os.Open(path)\n    if err != nil {\n        return nil, err\n    }\n    defer file.Close()\n\n    img, _, err := image.Decode(file)\n    return img, err\n}\n\nfunc extractFeatures(model interface{}, img image.Image) []float32 {\n    // Implementation omitted for brevity\n    // This would convert the image to a tensor, run it through the model,\n    // and return the feature vector\n    return make([]float32, 512)\n}\n</code></pre>"},{"location":"usage/examples/#real-time-anomaly-detection","title":"Real-time Anomaly Detection","text":"<p>This example demonstrates using Quiver for real-time anomaly detection:</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"time\"\n\n    \"github.com/TFMV/quiver\"\n    \"go.uber.org/zap\"\n)\n\nfunc main() {\n    // Create a logger\n    logger, _ := zap.NewDevelopment()\n\n    // Initialize Quiver\n    idx, _ := quiver.New(quiver.Config{\n        Dimension:   64,\n        StoragePath: \"./data/anomalies.db\",\n        Distance:    quiver.L2,\n    }, logger)\n    defer idx.Close()\n\n    // Load historical normal patterns\n    patterns := loadHistoricalPatterns()\n\n    // Add normal patterns to the index\n    for i, pattern := range patterns {\n        idx.Add(uint64(i), pattern.Features, map[string]interface{}{\n            \"category\":    \"pattern\",\n            \"timestamp\":   pattern.Timestamp,\n            \"source\":      pattern.Source,\n            \"is_anomaly\":  false,\n        })\n    }\n\n    // Anomaly detection function\n    detectAnomaly := func(newPattern Pattern) bool {\n        // Search for similar patterns\n        results, _ := idx.Search(newPattern.Features, 5, 1, 5)\n\n        // Calculate average distance to k nearest neighbors\n        var totalDistance float32\n        for _, result := range results {\n            totalDistance += result.Distance\n        }\n        avgDistance := totalDistance / float32(len(results))\n\n        // If average distance is above threshold, it's an anomaly\n        threshold := float32(0.8)\n        isAnomaly := avgDistance &gt; threshold\n\n        // Log the result\n        if isAnomaly {\n            fmt.Printf(\"ANOMALY DETECTED! Source: %s, Time: %s, Score: %.4f\\n\",\n                newPattern.Source, newPattern.Timestamp.Format(time.RFC3339), avgDistance)\n        }\n\n        // Add the new pattern to the index\n        idx.Add(uint64(time.Now().UnixNano()), newPattern.Features, map[string]interface{}{\n            \"category\":    \"pattern\",\n            \"timestamp\":   newPattern.Timestamp.Unix(),\n            \"source\":      newPattern.Source,\n            \"is_anomaly\":  isAnomaly,\n            \"score\":       avgDistance,\n        })\n\n        return isAnomaly\n    }\n\n    // Simulate real-time data stream\n    go func() {\n        for {\n            // Get new pattern from data source\n            newPattern := getNewPattern()\n\n            // Detect anomaly\n            detectAnomaly(newPattern)\n\n            // Wait for next data point\n            time.Sleep(1 * time.Second)\n        }\n    }()\n\n    // Keep the main thread alive\n    select {}\n}\n\n// Placeholder types and functions\ntype Pattern struct {\n    Features  []float32\n    Timestamp time.Time\n    Source    string\n}\n\nfunc loadHistoricalPatterns() []Pattern {\n    // Implementation omitted for brevity\n    return []Pattern{}\n}\n\nfunc getNewPattern() Pattern {\n    // Implementation omitted for brevity\n    return Pattern{\n        Features:  make([]float32, 64),\n        Timestamp: time.Now(),\n        Source:    \"sensor-1\",\n    }\n}\n</code></pre>"},{"location":"usage/examples/#next-steps","title":"Next Steps","text":"<p>These examples demonstrate just a few of the many ways you can use Quiver in your applications. For more detailed examples and best practices, check out:</p> <ul> <li>Go Library - Learn more about using Quiver as a library</li> <li>HTTP API - Use Quiver as a service</li> <li>Performance Tuning - Optimize Quiver for your needs</li> </ul>"},{"location":"usage/go-library/","title":"Go Library","text":"<p>Quiver is primarily a Go library that you can embed directly in your applications. Let's dive into how to use Quiver as a library to supercharge your Go applications with vector search! \ud83d\udcda</p>"},{"location":"usage/go-library/#installation","title":"Installation","text":"<p>First, add Quiver to your Go project:</p> <pre><code>go get github.com/TFMV/quiver\n</code></pre>"},{"location":"usage/go-library/#basic-usage","title":"Basic Usage","text":""},{"location":"usage/go-library/#initializing-quiver","title":"Initializing Quiver","text":"<p>The first step is to create a new Quiver index:</p> <pre><code>package main\n\nimport (\n    \"log\"\n\n    \"github.com/TFMV/quiver\"\n    \"go.uber.org/zap\"\n)\n\nfunc main() {\n    // Create a logger\n    logger, _ := zap.NewDevelopment()\n\n    // Configure Quiver\n    config := quiver.Config{\n        Dimension:   128,            // Vector dimension\n        StoragePath: \"./data\",       // Where to store the data\n        Distance:    quiver.Cosine,  // Distance metric\n    }\n\n    // Create the index\n    idx, err := quiver.New(config, logger)\n    if err != nil {\n        log.Fatalf(\"Failed to create index: %v\", err)\n    }\n    defer idx.Close() // Don't forget to close when done!\n\n    // Now you can use idx to add and search vectors\n}\n</code></pre>"},{"location":"usage/go-library/#adding-vectors","title":"Adding Vectors","text":"<p>Add vectors to the index:</p> <pre><code>// Add a single vector\nerr := idx.Add(1, []float32{0.1, 0.2, 0.3, /* ... */}, map[string]interface{}{\n    \"category\": \"example\",\n    \"name\": \"first vector\",\n})\nif err != nil {\n    log.Fatalf(\"Failed to add vector: %v\", err)\n}\n\n// Add multiple vectors\nfor i := 2; i &lt;= 100; i++ {\n    vector := generateRandomVector(128) // Your function to generate vectors\n    metadata := map[string]interface{}{\n        \"category\": \"example\",\n        \"name\": fmt.Sprintf(\"vector %d\", i),\n        \"index\": i,\n    }\n\n    if err := idx.Add(uint64(i), vector, metadata); err != nil {\n        log.Printf(\"Failed to add vector %d: %v\", i, err)\n    }\n}\n</code></pre>"},{"location":"usage/go-library/#searching","title":"Searching","text":"<p>Search for similar vectors:</p> <pre><code>// Create a query vector\nqueryVector := []float32{0.1, 0.2, 0.3, /* ... */}\n\n// Search for the 10 most similar vectors\nresults, err := idx.Search(queryVector, 10, 1, 10)\nif err != nil {\n    log.Fatalf(\"Search failed: %v\", err)\n}\n\n// Print the results\nfor i, result := range results {\n    fmt.Printf(\"%d. ID: %d, Distance: %.4f, Name: %s\\n\", \n        i+1, result.ID, result.Distance, result.Metadata[\"name\"])\n}\n</code></pre>"},{"location":"usage/go-library/#hybrid-search","title":"Hybrid Search","text":"<p>Combine vector search with metadata filtering:</p> <pre><code>// Search with a metadata filter\nresults, err := idx.SearchWithFilter(queryVector, 10, \n    \"category = 'example' AND index &gt; 50\")\nif err != nil {\n    log.Fatalf(\"Hybrid search failed: %v\", err)\n}\n</code></pre>"},{"location":"usage/go-library/#advanced-usage","title":"Advanced Usage","text":""},{"location":"usage/go-library/#working-with-arrow","title":"Working with Arrow","text":"<p>Quiver integrates with Apache Arrow for efficient data transfer:</p> <pre><code>import (\n    \"github.com/TFMV/quiver\"\n    \"github.com/apache/arrow-go/v18/arrow\"\n    \"github.com/apache/arrow/go/v18/arrow/array\"\n    \"github.com/apache/arrow/go/v18/arrow/memory\"\n)\n\nfunc addVectorsWithArrow(idx *quiver.Index, vectors [][]float32, metadata []map[string]interface{}) error {\n    // Create a schema for the vectors\n    schema := quiver.NewVectorSchema(len(vectors[0]))\n\n    // Create a record builder\n    builder := array.NewRecordBuilder(memory.DefaultAllocator, schema)\n    defer builder.Release()\n\n    // Get the builders for each column\n    idBuilder := builder.Field(0).(*array.Uint64Builder)\n    vectorBuilder := builder.Field(1).(*array.Float32Builder)\n    metadataBuilder := builder.Field(2).(*array.MapBuilder)\n\n    // Add data to the builders\n    for i, vec := range vectors {\n        // Add ID\n        idBuilder.Append(uint64(i + 1))\n\n        // Add vector\n        for _, v := range vec {\n            vectorBuilder.Append(v)\n        }\n\n        // Add metadata\n        // ... (code to add metadata to the MapBuilder)\n    }\n\n    // Create the record\n    record := builder.NewRecord()\n    defer record.Release()\n\n    // Add the record to the index\n    return idx.AppendFromArrow(record)\n}\n</code></pre>"},{"location":"usage/go-library/#custom-distance-functions","title":"Custom Distance Functions","text":"<p>Quiver supports custom distance functions:</p> <pre><code>// Define a custom distance function\nfunc customDistance(a, b []float32) float32 {\n    // Your custom distance calculation\n    var sum float32\n    for i := range a {\n        diff := a[i] - b[i]\n        sum += diff * diff\n    }\n    return float32(math.Sqrt(float64(sum)))\n}\n\n// Use it in your configuration\nconfig := quiver.Config{\n    Dimension:       128,\n    StoragePath:     \"./data\",\n    Distance:        quiver.CustomDistance(customDistance),\n}\n</code></pre>"},{"location":"usage/go-library/#persistence-and-recovery","title":"Persistence and Recovery","text":"<p>Save and load the index:</p> <pre><code>// Save the index to a specific location\nerr := idx.Save(\"./backup/my_index\")\nif err != nil {\n    log.Fatalf(\"Failed to save index: %v\", err)\n}\n\n// Load the index from disk\nidx, err = quiver.Load(config, logger)\nif err != nil {\n    log.Fatalf(\"Failed to load index: %v\", err)\n}\n</code></pre>"},{"location":"usage/go-library/#backup-and-restore","title":"Backup and Restore","text":"<p>Create and restore backups:</p> <pre><code>// Create a backup\nerr := idx.Backup(\"./backups/backup1\", false, true)\nif err != nil {\n    log.Fatalf(\"Backup failed: %v\", err)\n}\n\n// Restore from a backup\nerr = idx.Restore(\"./backups/backup1\")\nif err != nil {\n    log.Fatalf(\"Restore failed: %v\", err)\n}\n</code></pre>"},{"location":"usage/go-library/#integration-patterns","title":"Integration Patterns","text":""},{"location":"usage/go-library/#embedding-in-a-web-service","title":"Embedding in a Web Service","text":"<p>Integrate Quiver with your web service:</p> <pre><code>package main\n\nimport (\n    \"encoding/json\"\n    \"net/http\"\n\n    \"github.com/TFMV/quiver\"\n    \"go.uber.org/zap\"\n)\n\ntype SearchRequest struct {\n    Vector []float32 `json:\"vector\"`\n    K      int       `json:\"k\"`\n}\n\ntype SearchResponse struct {\n    Results []quiver.SearchResult `json:\"results\"`\n}\n\nfunc main() {\n    // Create a logger\n    logger, _ := zap.NewDevelopment()\n\n    // Initialize Quiver\n    idx, _ := quiver.New(quiver.Config{\n        Dimension:   128,\n        StoragePath: \"./data\",\n    }, logger)\n    defer idx.Close()\n\n    // Define a search handler\n    http.HandleFunc(\"/search\", func(w http.ResponseWriter, r *http.Request) {\n        var req SearchRequest\n        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil {\n            http.Error(w, err.Error(), http.StatusBadRequest)\n            return\n        }\n\n        results, err := idx.Search(req.Vector, req.K, 1, req.K)\n        if err != nil {\n            http.Error(w, err.Error(), http.StatusInternalServerError)\n            return\n        }\n\n        json.NewEncoder(w).Encode(SearchResponse{Results: results})\n    })\n\n    // Start the server\n    http.ListenAndServe(\":8080\", nil)\n}\n</code></pre>"},{"location":"usage/go-library/#background-processing","title":"Background Processing","text":"<p>Use Quiver in a background worker:</p> <pre><code>package main\n\nimport (\n    \"time\"\n\n    \"github.com/TFMV/quiver\"\n    \"go.uber.org/zap\"\n)\n\nfunc main() {\n    // Create a logger\n    logger, _ := zap.NewDevelopment()\n\n    // Initialize Quiver\n    idx, _ := quiver.New(quiver.Config{\n        Dimension:   128,\n        StoragePath: \"./data\",\n        BatchSize:   10000, // Large batch size for bulk processing\n    }, logger)\n    defer idx.Close()\n\n    // Process vectors in the background\n    go func() {\n        for {\n            // Get vectors from somewhere (e.g., a queue)\n            vectors, metadata := getVectorsFromQueue()\n\n            // Add them to the index\n            for i, vec := range vectors {\n                idx.Add(uint64(i), vec, metadata[i])\n            }\n\n            // Sleep for a bit\n            time.Sleep(1 * time.Second)\n        }\n    }()\n\n    // Keep the main thread alive\n    select {}\n}\n</code></pre>"},{"location":"usage/go-library/#best-practices","title":"Best Practices","text":""},{"location":"usage/go-library/#memory-management","title":"Memory Management","text":"<ul> <li>Close the index when done to release resources</li> <li>Use appropriate batch sizes for your memory constraints</li> <li>Consider using Arrow for bulk operations to reduce memory overhead</li> </ul>"},{"location":"usage/go-library/#concurrency","title":"Concurrency","text":"<p>Quiver is thread-safe, but be mindful of:</p> <ul> <li>Concurrent reads are fine</li> <li>Concurrent writes are serialized</li> <li>Heavy write loads might benefit from batching</li> </ul>"},{"location":"usage/go-library/#error-handling","title":"Error Handling","text":"<p>Always check errors:</p> <pre><code>// Add with proper error handling\nif err := idx.Add(id, vector, metadata); err != nil {\n    // Log the error\n    logger.Error(\"Failed to add vector\", zap.Uint64(\"id\", id), zap.Error(err))\n\n    // Maybe retry\n    if isRetryable(err) {\n        // Retry logic\n    }\n\n    // Or return the error\n    return err\n}\n</code></pre>"},{"location":"usage/go-library/#logging","title":"Logging","text":"<p>Quiver uses zap for logging. Configure it appropriately:</p> <pre><code>// Development logger (verbose)\nlogger, _ := zap.NewDevelopment()\n\n// Production logger (less verbose)\nlogger, _ := zap.NewProduction()\n\n// Custom logger\nlogger, _ := zap.Config{\n    Level:       zap.NewAtomicLevelAt(zap.InfoLevel),\n    Development: false,\n    Encoding:    \"json\",\n    // ... other options\n}.Build()\n</code></pre>"},{"location":"usage/go-library/#next-steps","title":"Next Steps","text":"<p>Now that you've learned how to use Quiver as a Go library, check out:</p> <ul> <li>HTTP API - Use Quiver as a service</li> <li>Examples - See more usage examples</li> <li>Performance Tuning - Optimize Quiver for your needs</li> </ul>"},{"location":"usage/http-api/","title":"HTTP API","text":"<p>Want to use Quiver as a service? The built-in HTTP API has you covered! Let's explore how to set up and use Quiver's API to sling vectors over the network. \ud83c\udf10</p>"},{"location":"usage/http-api/#setting-up-the-api-server","title":"Setting Up the API Server","text":""},{"location":"usage/http-api/#basic-setup","title":"Basic Setup","text":"<p>Setting up the Quiver API server is straightforward:</p> <pre><code>package main\n\nimport (\n    \"github.com/TFMV/quiver\"\n    \"github.com/TFMV/quiver/api\"\n    \"go.uber.org/zap\"\n)\n\nfunc main() {\n    // Create a logger\n    logger, _ := zap.NewDevelopment()\n\n    // Initialize Quiver\n    idx, _ := quiver.New(quiver.Config{\n        Dimension:   128,\n        StoragePath: \"./data\",\n    }, logger)\n    defer idx.Close()\n\n    // Create the API server\n    server := api.NewServer(api.ServerOptions{\n        Port:    \"8080\",\n        Prefork: false,\n    }, idx, logger)\n\n    // Start the server\n    server.Start()\n}\n</code></pre> <p>This starts an HTTP server on port 8080 that exposes Quiver's functionality via REST endpoints.</p>"},{"location":"usage/http-api/#advanced-configuration","title":"Advanced Configuration","text":"<p>For production use, you'll want more configuration:</p> <pre><code>// Create the API server with advanced options\nserver := api.NewServer(api.ServerOptions{\n    Host:    \"0.0.0.0\",     // Listen on all interfaces\n    Port:    \"8080\",\n    Prefork: true,          // Use multiple processes for better performance\n\n    // Authentication\n    Auth: api.AuthOptions{\n        Enabled:  true,\n        Username: \"admin\",\n        Password: \"secure-password\",\n    },\n\n    // Rate limiting\n    RateLimit: api.RateLimitOptions{\n        Enabled:     true,\n        MaxRequests: 100,\n        TimeWindow:  time.Minute,\n    },\n\n    // CORS\n    CORS: api.CORSOptions{\n        Enabled:      true,\n        AllowOrigins: []string{\"https://yourdomain.com\"},\n    },\n}, idx, logger)\n</code></pre>"},{"location":"usage/http-api/#tlshttps","title":"TLS/HTTPS","text":"<p>For secure communication, enable TLS:</p> <pre><code>// Start with TLS\nserver.StartTLS(\"server.crt\", \"server.key\")\n</code></pre> <p>This ensures all API traffic is encrypted.</p>"},{"location":"usage/http-api/#api-endpoints","title":"API Endpoints","text":""},{"location":"usage/http-api/#vector-operations","title":"Vector Operations","text":""},{"location":"usage/http-api/#add-vector","title":"Add Vector","text":"<p>Add a vector to the index:</p> <pre><code>POST /vectors\nContent-Type: application/json\n\n{\n  \"id\": 1,\n  \"vector\": [0.1, 0.2, 0.3, ...],\n  \"metadata\": {\n    \"category\": \"science\",\n    \"name\": \"black hole\",\n    \"tags\": [\"astronomy\", \"physics\"]\n  }\n}\n</code></pre> <p>Response:</p> <pre><code>{\n  \"success\": true,\n  \"id\": 1\n}\n</code></pre>"},{"location":"usage/http-api/#search","title":"Search","text":"<p>Search for similar vectors:</p> <pre><code>POST /search\nContent-Type: application/json\n\n{\n  \"vector\": [0.1, 0.2, 0.3, ...],\n  \"k\": 10,\n  \"page\": 1,\n  \"pageSize\": 10\n}\n</code></pre> <p>Response:</p> <pre><code>{\n  \"results\": [\n    {\n      \"id\": 1,\n      \"distance\": 0.0,\n      \"metadata\": {\n        \"category\": \"science\",\n        \"name\": \"black hole\",\n        \"tags\": [\"astronomy\", \"physics\"]\n      }\n    },\n    // More results...\n  ]\n}\n</code></pre>"},{"location":"usage/http-api/#hybrid-search","title":"Hybrid Search","text":"<p>Search with metadata filtering:</p> <pre><code>POST /search/hybrid\nContent-Type: application/json\n\n{\n  \"vector\": [0.1, 0.2, 0.3, ...],\n  \"k\": 10,\n  \"filter\": \"category = 'science' AND json_array_contains(tags, 'physics')\"\n}\n</code></pre> <p>Response:</p> <pre><code>{\n  \"results\": [\n    {\n      \"id\": 1,\n      \"distance\": 0.0,\n      \"metadata\": {\n        \"category\": \"science\",\n        \"name\": \"black hole\",\n        \"tags\": [\"astronomy\", \"physics\"]\n      }\n    },\n    // More results...\n  ]\n}\n</code></pre>"},{"location":"usage/http-api/#metadata-operations","title":"Metadata Operations","text":""},{"location":"usage/http-api/#query-metadata","title":"Query Metadata","text":"<p>Query metadata directly:</p> <pre><code>POST /metadata/query\nContent-Type: application/json\n\n{\n  \"query\": \"SELECT * FROM metadata WHERE category = 'science' ORDER BY created_at DESC LIMIT 10\"\n}\n</code></pre> <p>Response:</p> <pre><code>{\n  \"results\": [\n    {\n      \"category\": \"science\",\n      \"name\": \"black hole\",\n      \"tags\": [\"astronomy\", \"physics\"]\n    },\n    // More results...\n  ]\n}\n</code></pre>"},{"location":"usage/http-api/#management-operations","title":"Management Operations","text":""},{"location":"usage/http-api/#health-check","title":"Health Check","text":"<p>Check if the server is healthy:</p> <pre><code>GET /health\n</code></pre> <p>Response:</p> <pre><code>{\n  \"status\": \"ok\",\n  \"version\": \"1.0.0\",\n  \"uptime\": \"3h2m15s\"\n}\n</code></pre>"},{"location":"usage/http-api/#metrics","title":"Metrics","text":"<p>Get server metrics:</p> <pre><code>GET /metrics\n</code></pre> <p>Response:</p> <pre><code>{\n  \"vector_count\": 10000,\n  \"memory_usage_mb\": 256,\n  \"search_latency_ms\": 0.5,\n  \"queries_per_second\": 120\n}\n</code></pre>"},{"location":"usage/http-api/#using-the-api","title":"Using the API","text":""},{"location":"usage/http-api/#curl-examples","title":"cURL Examples","text":""},{"location":"usage/http-api/#add-a-vector","title":"Add a Vector","text":"<pre><code>curl -X POST http://localhost:8080/vectors \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"id\": 1,\n    \"vector\": [0.1, 0.2, 0.3],\n    \"metadata\": {\n      \"category\": \"example\",\n      \"name\": \"test vector\"\n    }\n  }'\n</code></pre>"},{"location":"usage/http-api/#search_1","title":"Search","text":"<pre><code>curl -X POST http://localhost:8080/search \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"vector\": [0.1, 0.2, 0.3],\n    \"k\": 5\n  }'\n</code></pre>"},{"location":"usage/http-api/#python-client","title":"Python Client","text":"<p>Here's a simple Python client for the Quiver API:</p> <pre><code>import requests\nimport numpy as np\n\nclass QuiverClient:\n    def __init__(self, base_url, username=None, password=None):\n        self.base_url = base_url\n        self.auth = None\n        if username and password:\n            self.auth = (username, password)\n\n    def add_vector(self, id, vector, metadata):\n        response = requests.post(\n            f\"{self.base_url}/vectors\",\n            json={\n                \"id\": id,\n                \"vector\": vector.tolist() if isinstance(vector, np.ndarray) else vector,\n                \"metadata\": metadata\n            },\n            auth=self.auth\n        )\n        return response.json()\n\n    def search(self, vector, k=10, page=1, page_size=10):\n        response = requests.post(\n            f\"{self.base_url}/search\",\n            json={\n                \"vector\": vector.tolist() if isinstance(vector, np.ndarray) else vector,\n                \"k\": k,\n                \"page\": page,\n                \"pageSize\": page_size\n            },\n            auth=self.auth\n        )\n        return response.json()\n\n    def hybrid_search(self, vector, k=10, filter=None):\n        response = requests.post(\n            f\"{self.base_url}/search/hybrid\",\n            json={\n                \"vector\": vector.tolist() if isinstance(vector, np.ndarray) else vector,\n                \"k\": k,\n                \"filter\": filter\n            },\n            auth=self.auth\n        )\n        return response.json()\n\n# Usage\nclient = QuiverClient(\"http://localhost:8080\", \"admin\", \"password\")\n\n# Add a vector\nclient.add_vector(\n    id=1,\n    vector=[0.1, 0.2, 0.3],\n    metadata={\"category\": \"example\", \"name\": \"test vector\"}\n)\n\n# Search\nresults = client.search([0.1, 0.2, 0.3], k=5)\nprint(results)\n</code></pre>"},{"location":"usage/http-api/#javascript-client","title":"JavaScript Client","text":"<p>And here's a JavaScript client:</p> <pre><code>class QuiverClient {\n  constructor(baseUrl, username = null, password = null) {\n    this.baseUrl = baseUrl;\n    this.headers = {\n      'Content-Type': 'application/json'\n    };\n\n    if (username &amp;&amp; password) {\n      this.headers['Authorization'] = 'Basic ' + \n        btoa(`${username}:${password}`);\n    }\n  }\n\n  async addVector(id, vector, metadata) {\n    const response = await fetch(`${this.baseUrl}/vectors`, {\n      method: 'POST',\n      headers: this.headers,\n      body: JSON.stringify({\n        id,\n        vector,\n        metadata\n      })\n    });\n\n    return response.json();\n  }\n\n  async search(vector, k = 10, page = 1, pageSize = 10) {\n    const response = await fetch(`${this.baseUrl}/search`, {\n      method: 'POST',\n      headers: this.headers,\n      body: JSON.stringify({\n        vector,\n        k,\n        page,\n        pageSize\n      })\n    });\n\n    return response.json();\n  }\n\n  async hybridSearch(vector, k = 10, filter = null) {\n    const response = await fetch(`${this.baseUrl}/search/hybrid`, {\n      method: 'POST',\n      headers: this.headers,\n      body: JSON.stringify({\n        vector,\n        k,\n        filter\n      })\n    });\n\n    return response.json();\n  }\n}\n\n// Usage\nconst client = new QuiverClient('http://localhost:8080', 'admin', 'password');\n\n// Add a vector\nclient.addVector(\n  1,\n  [0.1, 0.2, 0.3],\n  {category: 'example', name: 'test vector'}\n).then(result =&gt; console.log(result));\n\n// Search\nclient.search([0.1, 0.2, 0.3], 5)\n  .then(results =&gt; console.log(results));\n</code></pre>"},{"location":"usage/http-api/#performance-considerations","title":"Performance Considerations","text":""},{"location":"usage/http-api/#server-configuration","title":"Server Configuration","text":"<p>For optimal performance:</p> <ul> <li>Enable <code>Prefork</code> mode for multi-core utilization</li> <li>Use a reverse proxy like Nginx for SSL termination</li> <li>Configure appropriate timeouts for your use case</li> <li>Monitor server resources and scale as needed</li> </ul>"},{"location":"usage/http-api/#client-best-practices","title":"Client Best Practices","text":"<ul> <li>Reuse HTTP connections (connection pooling)</li> <li>Batch vector additions when possible</li> <li>Use appropriate timeout settings</li> <li>Implement retry logic for transient failures</li> </ul>"},{"location":"usage/http-api/#next-steps","title":"Next Steps","text":"<p>Now that you've learned how to use Quiver's HTTP API, check out:</p> <ul> <li>Go Library - Use Quiver as a library</li> <li>Examples - See more usage examples</li> <li>Performance Tuning - Optimize Quiver for your needs</li> </ul>"}]}