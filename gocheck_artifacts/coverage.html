
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>api: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/TFMV/quiver/api/api.go (0.0%)</option>
				
				<option value="file1">github.com/TFMV/quiver/api/dashboard.go (0.0%)</option>
				
				<option value="file2">github.com/TFMV/quiver/api/metrics.go (0.0%)</option>
				
				<option value="file3">github.com/TFMV/quiver/cmd/main.go (0.0%)</option>
				
				<option value="file4">github.com/TFMV/quiver/config_validator.go (31.2%)</option>
				
				<option value="file5">github.com/TFMV/quiver/quiver.go (56.8%)</option>
				
				<option value="file6">github.com/TFMV/quiver/router/router.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">// Package api provides the API for the Quiver application.
package api

import (
        "context"
        "errors"
        "fmt"
        "os"
        "os/signal"
        "syscall"
        "time"

        "github.com/TFMV/quiver"
        "github.com/TFMV/quiver/router"
        "github.com/gofiber/fiber/v2"
        "github.com/gofiber/fiber/v2/middleware/compress"
        "github.com/gofiber/fiber/v2/middleware/monitor"
        "github.com/gofiber/fiber/v2/middleware/recover"
        "github.com/prometheus/client_golang/prometheus/promhttp"
        "github.com/valyala/fasthttp/fasthttpadaptor"
        "go.uber.org/zap"
)

// Server holds the Fiber app instance
type Server struct {
        app   *fiber.App
        log   *zap.Logger
        port  string
        index *quiver.Index
}

// ServerOptions defines the configuration for the server.
type ServerOptions struct {
        Port    string
        Prefork bool
        // Extension options
        EnableExtensions bool
        RouterConfig     router.RouterConfig
}

// DimReductionOptions defines the configuration for dimensionality reduction
type DimReductionOptions struct {
        Enabled     bool    `json:"enabled"`
        Method      string  `json:"method,omitempty"`
        TargetDim   int     `json:"target_dim,omitempty"`
        Adaptive    bool    `json:"adaptive,omitempty"`
        MinVariance float64 `json:"min_variance,omitempty"`
}

// IndexOptions defines the configuration for creating a new index
type IndexOptions struct {
        Dimension       int                 `json:"dimension"`
        Distance        string              `json:"distance"`
        MaxElements     uint64              `json:"max_elements,omitempty"`
        HNSWM           int                 `json:"hnsw_m,omitempty"`
        HNSWEfConstruct int                 `json:"hnsw_ef_construct,omitempty"`
        HNSWEfSearch    int                 `json:"hnsw_ef_search,omitempty"`
        DimReduction    DimReductionOptions `json:"dim_reduction,omitempty"`
}

// SearchRequest represents a search request
type SearchRequest struct {
        Vector   []float32              `json:"vector"`
        K        int                    `json:"k"`
        Filter   string                 `json:"filter,omitempty"`
        Metadata map[string]interface{} `json:"metadata,omitempty"`
}

// SearchResponse represents a search response
type SearchResponse struct {
        Results []quiver.SearchResult `json:"results"`
}

// NewServer initializes a new Fiber instance with best practices
func NewServer(opts ServerOptions, index *quiver.Index, logger *zap.Logger) *Server <span class="cov0" title="0">{
        if logger == nil </span><span class="cov0" title="0">{
                var err error
                logger, err = zap.NewProduction()
                if err != nil </span><span class="cov0" title="0">{
                        panic(err)</span>
                }
        }

        <span class="cov0" title="0">fiberConfig := fiber.Config{
                IdleTimeout:   10 * time.Second,
                ReadTimeout:   10 * time.Second,
                WriteTimeout:  10 * time.Second,
                Prefork:       opts.Prefork,
                ErrorHandler:  customErrorHandler(logger),
                CaseSensitive: true,
                StrictRouting: true,
        }

        app := fiber.New(fiberConfig)

        // Middleware
        app.Use(recover.New())  // Auto-recovers from panics
        app.Use(compress.New()) // Enable gzip compression
        // Note: We're not using Fiber's logger middleware as we have our own custom logger

        // Create the server
        server := &amp;Server{
                app:   app,
                log:   logger,
                port:  opts.Port,
                index: index,
        }

        // Routes
        app.Get("/health", healthCheckHandler(logger))
        app.Get("/health/live", livenessHandler)
        app.Get("/health/ready", readinessHandler)
        app.Get("/metrics", metricsHandler())
        app.Get("/dashboard", monitor.New())

        // API routes
        api := app.Group("/api")
        v1 := api.Group("/v1")

        // Index operations
        v1.Post("/index/create", createIndexHandler(logger))
        v1.Post("/index/backup", backupHandler(index, logger))
        v1.Post("/index/restore", restoreHandler(index, logger))

        // Vector operations
        v1.Post("/vectors", addVectorHandler(index, logger))
        v1.Delete("/vectors/:id", deleteVectorHandler(index, logger))
        v1.Get("/vectors/:id", getVectorByIDHandler(index))

        // Search endpoints
        v1.Post("/search", searchHandler(index, logger))
        v1.Post("/search/hybrid", hybridSearchHandler(index, logger))
        v1.Post("/search/negatives", searchWithNegativesHandler(index, logger))

        // Metadata operations
        v1.Post("/metadata/query", queryMetadataHandler(index, logger))

        // Add custom logging middleware
        app.Use(customLoggingMiddleware(logger))

        return server</span>
}

// customErrorHandler provides structured error handling
func customErrorHandler(log *zap.Logger) fiber.ErrorHandler <span class="cov0" title="0">{
        return func(c *fiber.Ctx, err error) error </span><span class="cov0" title="0">{
                code := fiber.StatusInternalServerError
                message := "Internal Server Error"

                if e, ok := err.(*fiber.Error); ok </span><span class="cov0" title="0">{
                        code = e.Code
                        message = e.Message
                }</span>

                <span class="cov0" title="0">log.Error("Request failed",
                        zap.String("method", c.Method()),
                        zap.String("path", c.Path()),
                        zap.Int("status", code),
                        zap.Error(err),
                )

                // Respect "Accept" headers for response format
                if c.Accepts("text/html") != "" </span><span class="cov0" title="0">{
                        return c.Status(code).SendString(fmt.Sprintf("&lt;h1&gt;Error %d&lt;/h1&gt;&lt;p&gt;%s&lt;/p&gt;", code, message))
                }</span>

                <span class="cov0" title="0">return c.Status(code).JSON(fiber.Map{
                        "error":   true,
                        "message": message,
                })</span>
        }
}

// healthCheckHandler returns a simple health check response
func healthCheckHandler(log *zap.Logger) fiber.Handler <span class="cov0" title="0">{
        return func(c *fiber.Ctx) error </span><span class="cov0" title="0">{
                log.Debug("Health check requested")
                return c.SendString("OK")
        }</span>
}

// Liveness probe for Kubernetes
func livenessHandler(c *fiber.Ctx) error <span class="cov0" title="0">{
        return c.SendStatus(fiber.StatusOK)
}</span>

// Readiness probe for Kubernetes
func readinessHandler(c *fiber.Ctx) error <span class="cov0" title="0">{
        // Check if necessary dependencies (e.g., DB, cache) are ready.
        // If not ready, return StatusServiceUnavailable (503)
        return c.SendStatus(fiber.StatusOK)
}</span>

// customLoggingMiddleware logs requests in a structured format
func customLoggingMiddleware(log *zap.Logger) fiber.Handler <span class="cov0" title="0">{
        return func(c *fiber.Ctx) error </span><span class="cov0" title="0">{
                start := time.Now()
                err := c.Next()
                duration := time.Since(start)

                // Ensure status is set to avoid misleading logs
                status := c.Response().StatusCode()
                if status == 0 </span><span class="cov0" title="0">{
                        status = fiber.StatusInternalServerError
                }</span>

                <span class="cov0" title="0">fields := []zap.Field{
                        zap.String("method", c.Method()),
                        zap.String("path", c.Path()),
                        zap.Int("status", status),
                        zap.Duration("duration", duration),
                        zap.String("client_ip", c.IP()),
                }

                if err != nil </span><span class="cov0" title="0">{
                        fields = append(fields, zap.Error(err))
                }</span>

                <span class="cov0" title="0">log.Info("Request handled", fields...)
                return err</span>
        }
}

// Start runs the Fiber server and handles graceful shutdown
func (s *Server) Start() error <span class="cov0" title="0">{
        if s.port == "" </span><span class="cov0" title="0">{
                s.port = "8080"
        }</span>

        <span class="cov0" title="0">addr := fmt.Sprintf(":%s", s.port)
        s.log.Info("Starting server", zap.String("address", addr))

        idleConnsClosed := make(chan error, 1)

        go func() </span><span class="cov0" title="0">{
                sigint := make(chan os.Signal, 1)
                signal.Notify(sigint, os.Interrupt, syscall.SIGTERM)
                &lt;-sigint

                s.log.Info("Shutdown signal received")

                ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
                defer cancel()

                if err := s.Shutdown(ctx); err != nil </span><span class="cov0" title="0">{
                        idleConnsClosed &lt;- fmt.Errorf("server shutdown error: %w", err)
                        return
                }</span>
                <span class="cov0" title="0">idleConnsClosed &lt;- nil</span>
        }()

        // Start server in a separate goroutine
        <span class="cov0" title="0">serverErr := make(chan error, 1)
        go func() </span><span class="cov0" title="0">{
                if err := s.app.Listen(addr); err != nil &amp;&amp; !errors.Is(err, fiber.ErrServiceUnavailable) </span><span class="cov0" title="0">{
                        serverErr &lt;- fmt.Errorf("server startup error: %w", err)
                }</span>
        }()

        <span class="cov0" title="0">select </span>{
        case err := &lt;-idleConnsClosed:<span class="cov0" title="0">
                if err != nil </span><span class="cov0" title="0">{
                        s.log.Error("Shutdown error", zap.Error(err))
                        return err
                }</span>
        case err := &lt;-serverErr:<span class="cov0" title="0">
                s.log.Error("Startup error", zap.Error(err))
                return err</span>
        }

        <span class="cov0" title="0">s.log.Info("Server stopped")
        return nil</span>
}

// Shutdown stops the server gracefully
func (s *Server) Shutdown(ctx context.Context) error <span class="cov0" title="0">{
        s.log.Warn("Server is shutting down...")
        if err := s.app.ShutdownWithContext(ctx); err != nil </span><span class="cov0" title="0">{
                s.log.Error("Fiber shutdown error", zap.Error(err))
                return fmt.Errorf("fiber shutdown error: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// GetApp returns the underlying Fiber app
func (s *Server) GetApp() *fiber.App <span class="cov0" title="0">{
        return s.app
}</span>

// StartTLS starts the server with TLS
func (s *Server) StartTLS(certFile, keyFile string) error <span class="cov0" title="0">{
        // Verify that the certificate files exist and are valid
        if _, err := os.Stat(certFile); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("certificate file not found: %w", err)
        }</span>
        <span class="cov0" title="0">if _, err := os.Stat(keyFile); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("key file not found: %w", err)
        }</span>

        // Note: Fiber doesn't support passing a TLS config directly
        // We recommend using TLS 1.2 or higher for security

        // Start server with TLS
        <span class="cov0" title="0">return s.app.ListenTLS(":"+s.port, certFile, keyFile)</span>
}

// Handler implementations

func addVectorHandler(idx *quiver.Index, log *zap.Logger) fiber.Handler <span class="cov0" title="0">{
        return func(c *fiber.Ctx) error </span><span class="cov0" title="0">{
                start := time.Now()

                var req struct {
                        ID       uint64                 `json:"id"`
                        Vector   []float32              `json:"vector"`
                        Metadata map[string]interface{} `json:"metadata"`
                }

                if err := c.BodyParser(&amp;req); err != nil </span><span class="cov0" title="0">{
                        log.Error("Failed to parse request body", zap.Error(err))
                        return c.Status(fiber.StatusBadRequest).JSON(fiber.Map{
                                "error":   true,
                                "message": "Invalid request body",
                        })
                }</span>

                <span class="cov0" title="0">if len(req.Vector) == 0 </span><span class="cov0" title="0">{
                        return c.Status(fiber.StatusBadRequest).JSON(fiber.Map{
                                "error":   true,
                                "message": "Vector is required",
                        })
                }</span>

                <span class="cov0" title="0">err := idx.Add(req.ID, req.Vector, req.Metadata)
                if err != nil </span><span class="cov0" title="0">{
                        log.Error("Failed to add vector", zap.Error(err))
                        return c.Status(fiber.StatusInternalServerError).JSON(fiber.Map{
                                "error":   true,
                                "message": "Failed to add vector: " + err.Error(),
                        })
                }</span>

                // Log the operation duration
                <span class="cov0" title="0">log.Debug("Vector added",
                        zap.Uint64("id", req.ID),
                        zap.Duration("duration", time.Since(start)),
                )

                return c.Status(fiber.StatusCreated).JSON(fiber.Map{
                        "success": true,
                        "id":      req.ID,
                        "message": "Vector added successfully",
                })</span>
        }
}

func deleteVectorHandler(idx *quiver.Index, log *zap.Logger) fiber.Handler <span class="cov0" title="0">{
        return func(c *fiber.Ctx) error </span><span class="cov0" title="0">{
                start := time.Now()
                idParam := c.Params("id")
                var id uint64

                _, err := fmt.Sscanf(idParam, "%d", &amp;id)
                if err != nil </span><span class="cov0" title="0">{
                        log.Error("Invalid ID format", zap.String("id", idParam), zap.Error(err))
                        return c.Status(fiber.StatusBadRequest).JSON(fiber.Map{
                                "error":   true,
                                "message": "Invalid ID format",
                        })
                }</span>

                // Try to delete the vector
                <span class="cov0" title="0">err = idx.DeleteVector(id)
                if err != nil </span><span class="cov0" title="0">{
                        log.Error("Failed to delete vector", zap.Uint64("id", id), zap.Error(err))
                        return c.Status(fiber.StatusInternalServerError).JSON(fiber.Map{
                                "error":   true,
                                "message": "Failed to delete vector: " + err.Error(),
                        })
                }</span>

                // Log the operation duration
                <span class="cov0" title="0">log.Debug("Vector deleted",
                        zap.Uint64("id", id),
                        zap.Duration("duration", time.Since(start)),
                )

                return c.JSON(fiber.Map{
                        "success": true,
                        "message": "Vector deleted successfully",
                })</span>
        }
}

func getVectorByIDHandler(idx *quiver.Index) fiber.Handler <span class="cov0" title="0">{
        return func(c *fiber.Ctx) error </span><span class="cov0" title="0">{
                idParam := c.Params("id")
                var id uint64

                _, err := fmt.Sscanf(idParam, "%d", &amp;id)
                if err != nil </span><span class="cov0" title="0">{
                        return c.Status(fiber.StatusBadRequest).JSON(fiber.Map{
                                "error":   true,
                                "message": "Invalid ID format",
                        })
                }</span>

                // Access the unexported methods through the public API
                // This is a workaround until proper methods are exposed
                <span class="cov0" title="0">metadata := make(map[string]interface{})

                // Check if the vector exists by attempting a search
                results, err := idx.Search([]float32{0.1}, 1, 0, 0)
                if err != nil || len(results) == 0 </span><span class="cov0" title="0">{
                        return c.Status(fiber.StatusNotFound).JSON(fiber.Map{
                                "error":   true,
                                "message": "Vector not found",
                        })
                }</span>

                // For now, we'll just return the ID since we can't access the vector directly
                <span class="cov0" title="0">return c.JSON(fiber.Map{
                        "id":       id,
                        "metadata": metadata,
                })</span>
        }
}

func searchHandler(idx *quiver.Index, log *zap.Logger) fiber.Handler <span class="cov0" title="0">{
        return func(c *fiber.Ctx) error </span><span class="cov0" title="0">{
                start := time.Now()

                var req SearchRequest
                if err := c.BodyParser(&amp;req); err != nil </span><span class="cov0" title="0">{
                        log.Error("Failed to parse request body", zap.Error(err))
                        return c.Status(fiber.StatusBadRequest).JSON(fiber.Map{
                                "error":   true,
                                "message": "Invalid request body",
                        })
                }</span>

                <span class="cov0" title="0">if len(req.Vector) == 0 </span><span class="cov0" title="0">{
                        return c.Status(fiber.StatusBadRequest).JSON(fiber.Map{
                                "error":   true,
                                "message": "Vector is required",
                        })
                }</span>

                <span class="cov0" title="0">if req.K &lt;= 0 </span><span class="cov0" title="0">{
                        req.K = 10 // Default to 10 results
                }</span>

                <span class="cov0" title="0">results, err := idx.Search(req.Vector, req.K, 0, 0)
                if err != nil </span><span class="cov0" title="0">{
                        log.Error("Search failed", zap.Error(err))
                        return c.Status(fiber.StatusInternalServerError).JSON(fiber.Map{
                                "error":   true,
                                "message": "Search failed: " + err.Error(),
                        })
                }</span>

                // Log the operation duration
                <span class="cov0" title="0">log.Debug("Search completed",
                        zap.Int("results", len(results)),
                        zap.Duration("duration", time.Since(start)),
                )

                return c.JSON(SearchResponse{
                        Results: results,
                })</span>
        }
}

func hybridSearchHandler(idx *quiver.Index, log *zap.Logger) fiber.Handler <span class="cov0" title="0">{
        return func(c *fiber.Ctx) error </span><span class="cov0" title="0">{
                start := time.Now()

                var req SearchRequest
                if err := c.BodyParser(&amp;req); err != nil </span><span class="cov0" title="0">{
                        log.Error("Failed to parse request body", zap.Error(err))
                        return c.Status(fiber.StatusBadRequest).JSON(fiber.Map{
                                "error":   true,
                                "message": "Invalid request body",
                        })
                }</span>

                <span class="cov0" title="0">if len(req.Vector) == 0 </span><span class="cov0" title="0">{
                        return c.Status(fiber.StatusBadRequest).JSON(fiber.Map{
                                "error":   true,
                                "message": "Vector is required",
                        })
                }</span>

                <span class="cov0" title="0">if req.K &lt;= 0 </span><span class="cov0" title="0">{
                        req.K = 10 // Default to 10 results
                }</span>

                <span class="cov0" title="0">if req.Filter == "" </span><span class="cov0" title="0">{
                        return c.Status(fiber.StatusBadRequest).JSON(fiber.Map{
                                "error":   true,
                                "message": "Filter is required for hybrid search",
                        })
                }</span>

                <span class="cov0" title="0">results, err := idx.SearchWithFilter(req.Vector, req.K, req.Filter)
                if err != nil </span><span class="cov0" title="0">{
                        log.Error("Hybrid search failed", zap.Error(err))
                        return c.Status(fiber.StatusInternalServerError).JSON(fiber.Map{
                                "error":   true,
                                "message": "Hybrid search failed: " + err.Error(),
                        })
                }</span>

                // Log the operation duration
                <span class="cov0" title="0">log.Debug("Hybrid search completed",
                        zap.Int("results", len(results)),
                        zap.Duration("duration", time.Since(start)),
                )

                return c.JSON(SearchResponse{
                        Results: results,
                })</span>
        }
}

func searchWithNegativesHandler(idx *quiver.Index, log *zap.Logger) fiber.Handler <span class="cov0" title="0">{
        return func(c *fiber.Ctx) error </span><span class="cov0" title="0">{
                start := time.Now()

                var req struct {
                        PositiveVector  []float32   `json:"positive_vector"`
                        NegativeVectors [][]float32 `json:"negative_vectors"`
                        K               int         `json:"k"`
                        Page            int         `json:"page"`
                        PageSize        int         `json:"page_size"`
                }

                if err := c.BodyParser(&amp;req); err != nil </span><span class="cov0" title="0">{
                        log.Error("Failed to parse request body", zap.Error(err))
                        return c.Status(fiber.StatusBadRequest).JSON(fiber.Map{
                                "error":   true,
                                "message": "Invalid request body",
                        })
                }</span>

                <span class="cov0" title="0">if len(req.PositiveVector) == 0 </span><span class="cov0" title="0">{
                        return c.Status(fiber.StatusBadRequest).JSON(fiber.Map{
                                "error":   true,
                                "message": "Positive vector is required",
                        })
                }</span>

                <span class="cov0" title="0">if len(req.NegativeVectors) == 0 </span><span class="cov0" title="0">{
                        return c.Status(fiber.StatusBadRequest).JSON(fiber.Map{
                                "error":   true,
                                "message": "At least one negative vector is required",
                        })
                }</span>

                <span class="cov0" title="0">if req.K &lt;= 0 </span><span class="cov0" title="0">{
                        req.K = 10 // Default to 10 results
                }</span>

                <span class="cov0" title="0">if req.Page &lt; 0 </span><span class="cov0" title="0">{
                        req.Page = 0
                }</span>

                <span class="cov0" title="0">if req.PageSize &lt;= 0 </span><span class="cov0" title="0">{
                        req.PageSize = 10
                }</span>

                <span class="cov0" title="0">results, err := idx.SearchWithNegatives(req.PositiveVector, req.NegativeVectors, req.K, req.Page, req.PageSize)
                if err != nil </span><span class="cov0" title="0">{
                        log.Error("Search with negatives failed", zap.Error(err))
                        return c.Status(fiber.StatusInternalServerError).JSON(fiber.Map{
                                "error":   true,
                                "message": "Search with negatives failed: " + err.Error(),
                        })
                }</span>

                // Log the operation duration
                <span class="cov0" title="0">log.Debug("Search with negatives completed",
                        zap.Int("results", len(results)),
                        zap.Duration("duration", time.Since(start)),
                )

                return c.JSON(SearchResponse{
                        Results: results,
                })</span>
        }
}

func queryMetadataHandler(idx *quiver.Index, log *zap.Logger) fiber.Handler <span class="cov0" title="0">{
        return func(c *fiber.Ctx) error </span><span class="cov0" title="0">{
                var req struct {
                        Query string `json:"query"`
                }

                if err := c.BodyParser(&amp;req); err != nil </span><span class="cov0" title="0">{
                        log.Error("Failed to parse request body", zap.Error(err))
                        return c.Status(fiber.StatusBadRequest).JSON(fiber.Map{
                                "error":   true,
                                "message": "Invalid request body",
                        })
                }</span>

                <span class="cov0" title="0">if req.Query == "" </span><span class="cov0" title="0">{
                        return c.Status(fiber.StatusBadRequest).JSON(fiber.Map{
                                "error":   true,
                                "message": "Query is required",
                        })
                }</span>

                <span class="cov0" title="0">results, err := idx.QueryMetadata(req.Query)
                if err != nil </span><span class="cov0" title="0">{
                        log.Error("Metadata query failed", zap.Error(err))
                        return c.Status(fiber.StatusInternalServerError).JSON(fiber.Map{
                                "error":   true,
                                "message": "Metadata query failed: " + err.Error(),
                        })
                }</span>

                <span class="cov0" title="0">return c.JSON(fiber.Map{
                        "results": results,
                })</span>
        }
}

func backupHandler(idx *quiver.Index, log *zap.Logger) fiber.Handler <span class="cov0" title="0">{
        return func(c *fiber.Ctx) error </span><span class="cov0" title="0">{
                var req struct {
                        Path        string `json:"path"`
                        Incremental bool   `json:"incremental"`
                        Compress    bool   `json:"compress"`
                }

                if err := c.BodyParser(&amp;req); err != nil </span><span class="cov0" title="0">{
                        log.Error("Failed to parse request body", zap.Error(err))
                        return c.Status(fiber.StatusBadRequest).JSON(fiber.Map{
                                "error":   true,
                                "message": "Invalid request body",
                        })
                }</span>

                <span class="cov0" title="0">if req.Path == "" </span><span class="cov0" title="0">{
                        return c.Status(fiber.StatusBadRequest).JSON(fiber.Map{
                                "error":   true,
                                "message": "Backup path is required",
                        })
                }</span>

                <span class="cov0" title="0">err := idx.Backup(req.Path, req.Incremental, req.Compress)
                if err != nil </span><span class="cov0" title="0">{
                        log.Error("Backup failed", zap.Error(err))
                        return c.Status(fiber.StatusInternalServerError).JSON(fiber.Map{
                                "error":   true,
                                "message": "Backup failed: " + err.Error(),
                        })
                }</span>

                <span class="cov0" title="0">return c.JSON(fiber.Map{
                        "success": true,
                        "message": "Backup completed successfully",
                        "path":    req.Path,
                })</span>
        }
}

func restoreHandler(idx *quiver.Index, log *zap.Logger) fiber.Handler <span class="cov0" title="0">{
        return func(c *fiber.Ctx) error </span><span class="cov0" title="0">{
                var req struct {
                        Path string `json:"path"`
                }

                if err := c.BodyParser(&amp;req); err != nil </span><span class="cov0" title="0">{
                        log.Error("Failed to parse request body", zap.Error(err))
                        return c.Status(fiber.StatusBadRequest).JSON(fiber.Map{
                                "error":   true,
                                "message": "Invalid request body",
                        })
                }</span>

                <span class="cov0" title="0">if req.Path == "" </span><span class="cov0" title="0">{
                        return c.Status(fiber.StatusBadRequest).JSON(fiber.Map{
                                "error":   true,
                                "message": "Restore path is required",
                        })
                }</span>

                <span class="cov0" title="0">err := idx.Restore(req.Path)
                if err != nil </span><span class="cov0" title="0">{
                        log.Error("Restore failed", zap.Error(err))
                        return c.Status(fiber.StatusInternalServerError).JSON(fiber.Map{
                                "error":   true,
                                "message": "Restore failed: " + err.Error(),
                        })
                }</span>

                <span class="cov0" title="0">return c.JSON(fiber.Map{
                        "success": true,
                        "message": "Restore completed successfully",
                })</span>
        }
}

// metricsHandler returns a handler for Prometheus metrics
func metricsHandler() fiber.Handler <span class="cov0" title="0">{
        return func(c *fiber.Ctx) error </span><span class="cov0" title="0">{
                // Convert the Prometheus handler to a Fiber handler
                handler := fasthttpadaptor.NewFastHTTPHandler(promhttp.Handler())
                handler(c.Context())
                return nil
        }</span>
}

func createIndexHandler(logger *zap.Logger) fiber.Handler <span class="cov0" title="0">{
        return func(c *fiber.Ctx) error </span><span class="cov0" title="0">{
                var opts IndexOptions
                if err := c.BodyParser(&amp;opts); err != nil </span><span class="cov0" title="0">{
                        logger.Error("Failed to parse index options", zap.Error(err))
                        return c.Status(fiber.StatusBadRequest).JSON(fiber.Map{
                                "error":   true,
                                "message": "Invalid request format",
                        })
                }</span>

                // Validate options
                <span class="cov0" title="0">if opts.Dimension &lt;= 0 </span><span class="cov0" title="0">{
                        return c.Status(fiber.StatusBadRequest).JSON(fiber.Map{
                                "error":   true,
                                "message": "Dimension must be positive",
                        })
                }</span>

                // Create the index configuration
                <span class="cov0" title="0">config := quiver.Config{
                        Dimension:       opts.Dimension,
                        Distance:        quiver.CosineDistance, // Default
                        MaxElements:     opts.MaxElements,
                        HNSWM:           opts.HNSWM,
                        HNSWEfConstruct: opts.HNSWEfConstruct,
                        HNSWEfSearch:    opts.HNSWEfSearch,
                }

                // Set the distance metric
                if opts.Distance == "l2" </span><span class="cov0" title="0">{
                        config.Distance = quiver.L2Distance
                }</span>

                // Set default values if not provided
                <span class="cov0" title="0">if config.MaxElements == 0 </span><span class="cov0" title="0">{
                        config.MaxElements = 1000000
                }</span>
                <span class="cov0" title="0">if config.HNSWM == 0 </span><span class="cov0" title="0">{
                        config.HNSWM = 16
                }</span>
                <span class="cov0" title="0">if config.HNSWEfConstruct == 0 </span><span class="cov0" title="0">{
                        config.HNSWEfConstruct = 200
                }</span>
                <span class="cov0" title="0">if config.HNSWEfSearch == 0 </span><span class="cov0" title="0">{
                        config.HNSWEfSearch = 100
                }</span>

                // Configure dimensionality reduction if enabled
                <span class="cov0" title="0">if opts.DimReduction.Enabled </span><span class="cov0" title="0">{
                        config.EnableDimReduction = true
                        config.DimReductionMethod = opts.DimReduction.Method
                        config.DimReductionTarget = opts.DimReduction.TargetDim
                        config.DimReductionAdaptive = opts.DimReduction.Adaptive
                        config.DimReductionMinVariance = opts.DimReduction.MinVariance

                        // Set default values if not provided
                        if config.DimReductionMethod == "" </span><span class="cov0" title="0">{
                                config.DimReductionMethod = "PCA"
                        }</span>
                        <span class="cov0" title="0">if config.DimReductionTarget &lt;= 0 </span><span class="cov0" title="0">{
                                config.DimReductionTarget = config.Dimension / 2
                        }</span>
                        <span class="cov0" title="0">if config.DimReductionMinVariance &lt;= 0 </span><span class="cov0" title="0">{
                                config.DimReductionMinVariance = 0.95
                        }</span>
                }

                // Create the index
                <span class="cov0" title="0">_, err := quiver.New(config, logger)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error("Failed to create index", zap.Error(err))
                        return c.Status(fiber.StatusInternalServerError).JSON(fiber.Map{
                                "error":   true,
                                "message": "Failed to create index: " + err.Error(),
                        })
                }</span>

                // Return the index configuration
                <span class="cov0" title="0">return c.JSON(fiber.Map{
                        "success": true,
                        "message": "Index created successfully",
                        "config":  config,
                })</span>
        }
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package api

import (
        "fmt"
        "html/template"
        "os"
        "strings"
        "time"

        "github.com/TFMV/quiver"
        "github.com/gofiber/fiber/v2"
        "go.uber.org/zap"
)

// DashboardConfig contains configuration for the dashboard
type DashboardConfig struct {
        // RefreshInterval is how often the dashboard should refresh metrics (in seconds)
        RefreshInterval int
        // EnableAuth enables basic authentication for the dashboard
        EnableAuth bool
        // Username for basic authentication
        Username string
        // Password for basic authentication
        Password string
        // CustomTitle is a custom title for the dashboard
        CustomTitle string
}

// DefaultDashboardConfig returns the default dashboard configuration
func DefaultDashboardConfig() DashboardConfig <span class="cov0" title="0">{
        return DashboardConfig{
                RefreshInterval: 5,
                EnableAuth:      false,
                CustomTitle:     "Quiver Dashboard",
        }
}</span>

// RegisterDashboard registers the dashboard routes with the Fiber app
func RegisterDashboard(app *fiber.App, idx *quiver.Index, config DashboardConfig, logger *zap.Logger) <span class="cov0" title="0">{
        // Create a dashboard group
        dashboard := app.Group("/dashboard")

        // Add basic authentication if enabled
        if config.EnableAuth </span><span class="cov0" title="0">{
                dashboard.Use(func(c *fiber.Ctx) error </span><span class="cov0" title="0">{
                        // Get authorization header
                        auth := c.Get("Authorization")
                        if auth == "" </span><span class="cov0" title="0">{
                                c.Set("WWW-Authenticate", "Basic realm=Quiver Dashboard")
                                return c.Status(fiber.StatusUnauthorized).SendString("Unauthorized")
                        }</span>

                        // Parse basic auth
                        <span class="cov0" title="0">username, password, ok := parseBasicAuth(auth)
                        if !ok || username != config.Username || password != config.Password </span><span class="cov0" title="0">{
                                c.Set("WWW-Authenticate", "Basic realm=Quiver Dashboard")
                                return c.Status(fiber.StatusUnauthorized).SendString("Unauthorized")
                        }</span>

                        <span class="cov0" title="0">return c.Next()</span>
                })
        }

        // Register dashboard routes
        <span class="cov0" title="0">dashboard.Get("/", dashboardHandler(idx, config, logger))
        dashboard.Get("/metrics", dashboardMetricsHandler(idx, logger))
        dashboard.Get("/config", configHandler(idx, logger))
        dashboard.Get("/health", healthHandler(idx, logger))
        dashboard.Get("/stats", statsHandler(idx, logger))

        logger.Info("Dashboard registered", zap.String("path", "/dashboard"))</span>
}

// dashboardHandler serves the main dashboard page
func dashboardHandler(idx *quiver.Index, config DashboardConfig, logger *zap.Logger) fiber.Handler <span class="cov0" title="0">{
        return func(c *fiber.Ctx) error </span><span class="cov0" title="0">{
                // Load the dashboard template from file system
                // Note: In a production environment, you would use embed.FS
                // but for simplicity, we'll load from the file system directly
                tmplContent, err := os.ReadFile("quiver/api/dashboard_templates/dashboard.html")
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error("Failed to load dashboard template", zap.Error(err))
                        return c.Status(fiber.StatusInternalServerError).SendString("Failed to load dashboard template")
                }</span>

                // Parse the template
                <span class="cov0" title="0">tmpl, err := template.New("dashboard").Parse(string(tmplContent))
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error("Failed to parse dashboard template", zap.Error(err))
                        return c.Status(fiber.StatusInternalServerError).SendString("Failed to parse dashboard template")
                }</span>

                // Get index configuration
                <span class="cov0" title="0">indexConfig := idx.Config()

                // Prepare template data
                data := map[string]interface{}{
                        "Title":           config.CustomTitle,
                        "RefreshInterval": config.RefreshInterval,
                        "Config":          indexConfig,
                        "Timestamp":       time.Now().Format(time.RFC3339),
                }

                // Render the template
                return c.Type("html").SendString(renderTemplate(tmpl, data))</span>
        }
}

// dashboardMetricsHandler serves the metrics data as JSON
func dashboardMetricsHandler(idx *quiver.Index, logger *zap.Logger) fiber.Handler <span class="cov0" title="0">{
        return func(c *fiber.Ctx) error </span><span class="cov0" title="0">{
                metrics := idx.CollectMetrics()
                return c.JSON(metrics)
        }</span>
}

// configHandler serves the index configuration as JSON
func configHandler(idx *quiver.Index, logger *zap.Logger) fiber.Handler <span class="cov0" title="0">{
        return func(c *fiber.Ctx) error </span><span class="cov0" title="0">{
                config := idx.Config()

                // Redact sensitive information
                if config.EncryptionEnabled </span><span class="cov0" title="0">{
                        config.EncryptionKey = "********"
                }</span>

                <span class="cov0" title="0">return c.JSON(config)</span>
        }
}

// healthHandler serves the health check status
func healthHandler(idx *quiver.Index, logger *zap.Logger) fiber.Handler <span class="cov0" title="0">{
        return func(c *fiber.Ctx) error </span><span class="cov0" title="0">{
                err := idx.HealthCheck()
                if err != nil </span><span class="cov0" title="0">{
                        return c.JSON(fiber.Map{
                                "status":  "unhealthy",
                                "message": err.Error(),
                                "time":    time.Now().Format(time.RFC3339),
                        })
                }</span>

                <span class="cov0" title="0">return c.JSON(fiber.Map{
                        "status":  "healthy",
                        "message": "All systems operational",
                        "time":    time.Now().Format(time.RFC3339),
                })</span>
        }
}

// statsHandler serves detailed statistics about the index
func statsHandler(idx *quiver.Index, logger *zap.Logger) fiber.Handler <span class="cov0" title="0">{
        return func(c *fiber.Ctx) error </span><span class="cov0" title="0">{
                metrics := idx.CollectMetrics()

                // Get additional statistics
                vectorCount, ok := metrics["vector_count"].(int)
                if !ok </span><span class="cov0" title="0">{
                        vectorCount = 0
                }</span>

                // Calculate memory usage per vector
                <span class="cov0" title="0">var memoryPerVector float64
                if vectorCount &gt; 0 </span><span class="cov0" title="0">{
                        if totalMemory, ok := metrics["memory_usage"].(int64); ok </span><span class="cov0" title="0">{
                                memoryPerVector = float64(totalMemory) / float64(vectorCount)
                        }</span>
                }

                <span class="cov0" title="0">stats := fiber.Map{
                        "vector_count":      vectorCount,
                        "memory_per_vector": memoryPerVector,
                        "metrics":           metrics,
                        "time":              time.Now().Format(time.RFC3339),
                }

                return c.JSON(stats)</span>
        }
}

// Helper functions

// parseBasicAuth parses an HTTP Basic Authentication string
func parseBasicAuth(auth string) (username, password string, ok bool) <span class="cov0" title="0">{
        // Implementation omitted for brevity
        // This would parse the "Basic dXNlcm5hbWU6cGFzc3dvcmQ=" format
        return "username", "password", true
}</span>

// renderTemplate renders a template to a string
func renderTemplate(tmpl *template.Template, data interface{}) string <span class="cov0" title="0">{
        var result strings.Builder
        if err := tmpl.Execute(&amp;result, data); err != nil </span><span class="cov0" title="0">{
                return fmt.Sprintf("Error rendering template: %v", err)
        }</span>
        <span class="cov0" title="0">return result.String()</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package api

import (
        "time"

        "github.com/prometheus/client_golang/prometheus"
)

var (
        // Define Prometheus metrics
        searchRequests = prometheus.NewCounterVec(
                prometheus.CounterOpts{
                        Name: "quiver_search_requests_total",
                        Help: "Total number of search requests",
                },
                []string{"status"},
        )

        searchLatency = prometheus.NewHistogramVec(
                prometheus.HistogramOpts{
                        Name:    "quiver_search_latency_seconds",
                        Help:    "Search request latency in seconds",
                        Buckets: prometheus.ExponentialBuckets(0.001, 2, 15), // from 1ms to ~16s
                },
                []string{"status"},
        )

        vectorCount = prometheus.NewGauge(
                prometheus.GaugeOpts{
                        Name: "quiver_vector_count",
                        Help: "Number of vectors in the index",
                },
        )

        memoryUsage = prometheus.NewGauge(
                prometheus.GaugeOpts{
                        Name: "quiver_memory_usage_bytes",
                        Help: "Memory usage in bytes",
                },
        )
)

func init() <span class="cov0" title="0">{
        // Register metrics with Prometheus
        prometheus.MustRegister(searchRequests)
        prometheus.MustRegister(searchLatency)
        prometheus.MustRegister(vectorCount)
        prometheus.MustRegister(memoryUsage)
}</span>

// ObserveSearchLatency records the latency of a search request
func ObserveSearchLatency(start time.Time, status string) <span class="cov0" title="0">{
        duration := time.Since(start).Seconds()
        searchLatency.WithLabelValues(status).Observe(duration)
        searchRequests.WithLabelValues(status).Inc()
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">package main

import (
        "context"
        "errors"
        "fmt"
        "math/rand/v2"
        "net/http"
        "os"
        "os/signal"
        "strconv"
        "syscall"
        "time"

        "strings"

        "github.com/TFMV/quiver"
        "github.com/TFMV/quiver/api"
        "github.com/bytedance/sonic"
        "github.com/olekukonko/tablewriter"
        "github.com/spf13/cobra"
        "github.com/spf13/viper"
        "go.uber.org/zap"
)

var (
        logger    *zap.Logger
        cfgFile   string
        indexPath string
        verbose   bool
)

func init() <span class="cov0" title="0">{
        cobra.OnInitialize(initConfig)

        // Root command flags
        rootCmd.PersistentFlags().StringVar(&amp;cfgFile, "config", "", "config file (default is ./config.yaml)")
        rootCmd.PersistentFlags().StringVarP(&amp;indexPath, "index", "i", "", "Path to index directory (overrides config)")
        rootCmd.PersistentFlags().BoolVarP(&amp;verbose, "verbose", "v", false, "Enable verbose output")

        // Add commands
        rootCmd.AddCommand(serveCmd)
        rootCmd.AddCommand(statusCmd)
        rootCmd.AddCommand(infoCmd)
        rootCmd.AddCommand(statsCmd)
        rootCmd.AddCommand(benchmarkCmd)
        rootCmd.AddCommand(validateCmd)
        rootCmd.AddCommand(exportCmd)
        rootCmd.AddCommand(importCmd)
        rootCmd.AddCommand(optimizeCmd)
        rootCmd.AddCommand(backupCmd)
        rootCmd.AddCommand(restoreCmd)
        rootCmd.AddCommand(healthCmd)
}</span>

// rootCmd represents the base command
var rootCmd = &amp;cobra.Command{
        Use:   "quiver",
        Short: "Quiver is a high-performance vector database",
        Long: `Quiver is a lightweight, high-performance vector search engine 
designed for structured datasets. It uses HNSW for efficient vector 
indexing and DuckDB for metadata storage.`,
        PersistentPreRun: func(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
                if verbose </span><span class="cov0" title="0">{
                        // Switch to development logger with debug level
                        var err error
                        logger, err = zap.NewDevelopment()
                        if err != nil </span><span class="cov0" title="0">{
                                fmt.Fprintf(os.Stderr, "Failed to initialize development logger: %v\n", err)
                                os.Exit(1)
                        }</span>
                }
        },
}

// serveCmd represents the serve command
var serveCmd = &amp;cobra.Command{
        Use:   "serve",
        Short: "Start the Quiver server",
        RunE:  runServer,
}

// statusCmd represents the status command
var statusCmd = &amp;cobra.Command{
        Use:   "status",
        Short: "Check Quiver server status",
        RunE:  checkStatus,
}

var infoCmd = &amp;cobra.Command{
        Use:   "info",
        Short: "Display information about the index",
        Run: func(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
                idx, err := loadIndex()
                if err != nil </span><span class="cov0" title="0">{
                        logger.Fatal("Failed to load index", zap.Error(err))
                }</span>
                <span class="cov0" title="0">defer idx.Close()

                config := idx.Config()
                fmt.Println("Index Information:")
                fmt.Printf("  Path: %s\n", config.StoragePath)
                fmt.Printf("  Dimension: %d\n", config.Dimension)
                fmt.Printf("  Distance Metric: %s\n", getDistanceMetricName(config.Distance))
                fmt.Printf("  Max Elements: %d\n", config.MaxElements)
                fmt.Printf("  HNSW M: %d\n", config.HNSWM)
                fmt.Printf("  HNSW Ef Construction: %d\n", config.HNSWEfConstruct)
                fmt.Printf("  HNSW Ef Search: %d\n", config.HNSWEfSearch)
                fmt.Printf("  Batch Size: %d\n", config.BatchSize)
                fmt.Printf("  Persistence Interval: %s\n", config.PersistInterval)
                fmt.Printf("  Backup Interval: %s\n", config.BackupInterval)
                fmt.Printf("  Encryption Enabled: %v\n", config.EncryptionEnabled)
                fmt.Printf("  Dimensionality Reduction Enabled: %v\n", config.EnableDimReduction)
                if config.EnableDimReduction </span><span class="cov0" title="0">{
                        fmt.Printf("  Dim Reduction Method: %s\n", config.DimReductionMethod)
                        fmt.Printf("  Dim Reduction Target: %d\n", config.DimReductionTarget)
                        fmt.Printf("  Dim Reduction Adaptive: %v\n", config.DimReductionAdaptive)
                        if config.DimReductionAdaptive </span><span class="cov0" title="0">{
                                fmt.Printf("  Dim Reduction Min Variance: %.2f\n", config.DimReductionMinVariance)
                        }</span>
                }
        },
}

var statsCmd = &amp;cobra.Command{
        Use:   "stats",
        Short: "Display statistics about the index",
        Run: func(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
                idx, err := loadIndex()
                if err != nil </span><span class="cov0" title="0">{
                        logger.Fatal("Failed to load index", zap.Error(err))
                }</span>
                <span class="cov0" title="0">defer idx.Close()

                metrics := idx.CollectMetrics()
                fmt.Println("Index Statistics:")

                table := tablewriter.NewWriter(os.Stdout)
                table.SetHeader([]string{"Metric", "Value"})
                table.SetBorder(false)
                table.SetColumnSeparator(" | ")

                // Add rows for each metric
                for k, v := range metrics </span><span class="cov0" title="0">{
                        table.Append([]string{k, fmt.Sprintf("%v", v)})
                }</span>
                <span class="cov0" title="0">table.Render()</span>
        },
}

var benchmarkCmd = &amp;cobra.Command{
        Use:   "benchmark",
        Short: "Run a benchmark on the index",
        Run: func(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
                idx, err := loadIndex()
                if err != nil </span><span class="cov0" title="0">{
                        logger.Fatal("Failed to load index", zap.Error(err))
                }</span>
                <span class="cov0" title="0">defer idx.Close()

                fmt.Println("Running benchmark...")

                // Generate random vectors for benchmarking
                numVectors := 100
                dimension := idx.Config().Dimension
                vectors := make([][]float32, numVectors)
                for i := range vectors </span><span class="cov0" title="0">{
                        vectors[i] = make([]float32, dimension)
                        for j := range vectors[i] </span><span class="cov0" title="0">{
                                vectors[i][j] = rand.Float32()
                        }</span>
                }

                // Benchmark Add operation
                <span class="cov0" title="0">fmt.Println("\nBenchmarking Add operation...")
                startAdd := time.Now()
                for i, vec := range vectors </span><span class="cov0" title="0">{
                        err := idx.Add(uint64(i+1000), vec, map[string]interface{}{
                                "benchmark": true,
                                "index":     i,
                        })
                        if err != nil </span><span class="cov0" title="0">{
                                logger.Error("Failed to add vector", zap.Error(err))
                        }</span>
                }
                <span class="cov0" title="0">addDuration := time.Since(startAdd)
                fmt.Printf("  Added %d vectors in %s (%.2f vectors/sec)\n",
                        numVectors, addDuration, float64(numVectors)/addDuration.Seconds())

                // Benchmark Search operation
                fmt.Println("\nBenchmarking Search operation...")
                totalSearchTime := time.Duration(0)
                for i := 0; i &lt; 10; i++ </span><span class="cov0" title="0">{
                        queryVector := vectors[i]
                        startSearch := time.Now()
                        _, err := idx.Search(queryVector, 10, 1, 10)
                        if err != nil </span><span class="cov0" title="0">{
                                logger.Error("Failed to search", zap.Error(err))
                                continue</span>
                        }
                        <span class="cov0" title="0">totalSearchTime += time.Since(startSearch)</span>
                }
                <span class="cov0" title="0">avgSearchTime := totalSearchTime / 10
                fmt.Printf("  Average search time: %s (%.2f searches/sec)\n",
                        avgSearchTime, float64(1)/avgSearchTime.Seconds())</span>
        },
}

var validateCmd = &amp;cobra.Command{
        Use:   "validate [config-file]",
        Short: "Validate a configuration file",
        Args:  cobra.ExactArgs(1),
        Run: func(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
                configFile := args[0]
                fmt.Printf("Validating configuration file: %s\n", configFile)

                // Read and parse the config file
                data, err := os.ReadFile(configFile)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Fatal("Failed to read config file", zap.Error(err))
                }</span>

                <span class="cov0" title="0">var config quiver.Config
                if err := sonic.Unmarshal(data, &amp;config); err != nil </span><span class="cov0" title="0">{
                        logger.Fatal("Failed to parse config file", zap.Error(err))
                }</span>

                // Validate the configuration
                <span class="cov0" title="0">issues := validateConfig(config)
                if len(issues) == 0 </span><span class="cov0" title="0">{
                        fmt.Println("Configuration is valid!")
                        return
                }</span>

                <span class="cov0" title="0">fmt.Println("Configuration validation issues:")
                for i, issue := range issues </span><span class="cov0" title="0">{
                        fmt.Printf("  %d. %s\n", i+1, issue)
                }</span>
        },
}

var exportCmd = &amp;cobra.Command{
        Use:   "export [output-file]",
        Short: "Export index metadata to a file",
        Args:  cobra.ExactArgs(1),
        Run: func(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
                outputFile := args[0]
                idx, err := loadIndex()
                if err != nil </span><span class="cov0" title="0">{
                        logger.Fatal("Failed to load index", zap.Error(err))
                }</span>
                <span class="cov0" title="0">defer idx.Close()

                fmt.Printf("Exporting metadata to: %s\n", outputFile)

                // Get all metadata
                results, err := idx.QueryMetadata("SELECT * FROM metadata")
                if err != nil </span><span class="cov0" title="0">{
                        logger.Fatal("Failed to query metadata", zap.Error(err))
                }</span>

                // Write to file
                <span class="cov0" title="0">data, err := sonic.MarshalIndent(results, "", "  ")
                if err != nil </span><span class="cov0" title="0">{
                        logger.Fatal("Failed to marshal metadata", zap.Error(err))
                }</span>

                <span class="cov0" title="0">if err := os.WriteFile(outputFile, data, 0644); err != nil </span><span class="cov0" title="0">{
                        logger.Fatal("Failed to write output file", zap.Error(err))
                }</span>

                <span class="cov0" title="0">fmt.Printf("Successfully exported %d records\n", len(results))</span>
        },
}

var importCmd = &amp;cobra.Command{
        Use:   "import [input-file]",
        Short: "Import vectors and metadata from a file",
        Args:  cobra.ExactArgs(1),
        Run: func(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
                inputFile := args[0]
                idx, err := loadIndex()
                if err != nil </span><span class="cov0" title="0">{
                        logger.Fatal("Failed to load index", zap.Error(err))
                }</span>
                <span class="cov0" title="0">defer idx.Close()

                fmt.Printf("Importing from: %s\n", inputFile)

                // Read the input file
                data, err := os.ReadFile(inputFile)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Fatal("Failed to read input file", zap.Error(err))
                }</span>

                <span class="cov0" title="0">var records []map[string]interface{}
                if err := sonic.Unmarshal(data, &amp;records); err != nil </span><span class="cov0" title="0">{
                        logger.Fatal("Failed to parse input file", zap.Error(err))
                }</span>

                // Import the records
                <span class="cov0" title="0">for i, record := range records </span><span class="cov0" title="0">{
                        // Extract vector and ID
                        vectorData, ok := record["vector"].([]interface{})
                        if !ok </span><span class="cov0" title="0">{
                                logger.Error("Record missing vector field", zap.Int("index", i))
                                continue</span>
                        }

                        <span class="cov0" title="0">vector := make([]float32, len(vectorData))
                        for j, v := range vectorData </span><span class="cov0" title="0">{
                                f, ok := v.(float64)
                                if !ok </span><span class="cov0" title="0">{
                                        logger.Error("Invalid vector value", zap.Int("index", i), zap.Int("position", j))
                                        continue</span>
                                }
                                <span class="cov0" title="0">vector[j] = float32(f)</span>
                        }

                        <span class="cov0" title="0">idVal, ok := record["id"]
                        if !ok </span><span class="cov0" title="0">{
                                logger.Error("Record missing ID field", zap.Int("index", i))
                                continue</span>
                        }

                        <span class="cov0" title="0">var id uint64
                        switch v := idVal.(type) </span>{
                        case float64:<span class="cov0" title="0">
                                id = uint64(v)</span>
                        case string:<span class="cov0" title="0">
                                id, err = strconv.ParseUint(v, 10, 64)
                                if err != nil </span><span class="cov0" title="0">{
                                        logger.Error("Invalid ID value", zap.Int("index", i), zap.Error(err))
                                        continue</span>
                                }
                        default:<span class="cov0" title="0">
                                logger.Error("Invalid ID type", zap.Int("index", i))
                                continue</span>
                        }

                        // Remove vector and ID from metadata
                        <span class="cov0" title="0">delete(record, "vector")
                        delete(record, "id")

                        // Add to index
                        if err := idx.Add(id, vector, record); err != nil </span><span class="cov0" title="0">{
                                logger.Error("Failed to add record", zap.Int("index", i), zap.Error(err))
                        }</span>
                }

                <span class="cov0" title="0">fmt.Printf("Successfully imported %d records\n", len(records))</span>
        },
}

var optimizeCmd = &amp;cobra.Command{
        Use:   "optimize",
        Short: "Optimize the index for better performance",
        Run: func(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
                idx, err := loadIndex()
                if err != nil </span><span class="cov0" title="0">{
                        logger.Fatal("Failed to load index", zap.Error(err))
                }</span>
                <span class="cov0" title="0">defer idx.Close()

                fmt.Println("Optimizing index...")

                // Force a batch flush
                fmt.Println("Flushing batch buffer...")
                // This is a private method, so we can't call it directly
                // Instead, we'll add a dummy vector to trigger a flush
                dummyVector := make([]float32, idx.Config().Dimension)
                err = idx.Add(0, dummyVector, map[string]interface{}{"_dummy": true})
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error("Failed to add dummy vector", zap.Error(err))
                }</span>

                // Force persistence
                <span class="cov0" title="0">fmt.Println("Persisting index to disk...")
                // Again, this is private, so we'll use Save instead
                err = idx.Save(idx.Config().StoragePath)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Fatal("Failed to save index", zap.Error(err))
                }</span>

                <span class="cov0" title="0">fmt.Println("Optimization complete!")</span>
        },
}

var backupCmd = &amp;cobra.Command{
        Use:   "backup [path]",
        Short: "Backup the index and metadata",
        Args:  cobra.ExactArgs(1),
        RunE:  runBackup,
}

var restoreCmd = &amp;cobra.Command{
        Use:   "restore [path]",
        Short: "Restore the index from backup",
        Args:  cobra.ExactArgs(1),
        RunE:  runRestore,
}

var healthCmd = &amp;cobra.Command{
        Use:   "health",
        Short: "Check the health of the index",
        Run: func(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
                idx, err := loadIndex()
                if err != nil </span><span class="cov0" title="0">{
                        logger.Fatal("Failed to load index", zap.Error(err))
                }</span>
                <span class="cov0" title="0">defer idx.Close()

                fmt.Println("Checking index health...")

                // Check index health
                err = idx.HealthCheck()
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Println("❌ Index health check failed:")
                        fmt.Printf("   %s\n", err)
                        os.Exit(1)
                }</span>

                <span class="cov0" title="0">fmt.Println("✅ Index is healthy!")</span>
        },
}

func initConfig() <span class="cov0" title="0">{
        if cfgFile != "" </span><span class="cov0" title="0">{
                viper.SetConfigFile(cfgFile)
        }</span> else<span class="cov0" title="0"> {
                viper.SetConfigName("config")
                viper.AddConfigPath(".")
        }</span>

        <span class="cov0" title="0">viper.SetEnvPrefix("QUIVER")
        viper.AutomaticEnv()

        if err := viper.ReadInConfig(); err == nil </span><span class="cov0" title="0">{
                if logger != nil </span><span class="cov0" title="0">{
                        logger.Info("Using config file", zap.String("file", viper.ConfigFileUsed()))
                }</span>
        }
}

func runServer(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
        port := viper.GetString("server.port")
        if port == "" </span><span class="cov0" title="0">{
                port = "8080"
        }</span>

        // Set default index configuration
        <span class="cov0" title="0">viper.SetDefault("index.dimension", 128)
        viper.SetDefault("index.storage_path", "quiver.db")
        viper.SetDefault("index.max_elements", 100000)
        viper.SetDefault("index.hnsw_m", 32)
        viper.SetDefault("index.ef_construction", 200)
        viper.SetDefault("index.ef_search", 200)
        viper.SetDefault("index.batch_size", 1000)
        viper.SetDefault("index.distance", int(quiver.Cosine))

        // Override storage path if provided
        storagePath := viper.GetString("index.storage_path")
        if indexPath != "" </span><span class="cov0" title="0">{
                storagePath = indexPath
        }</span>

        // Create the vector index
        <span class="cov0" title="0">index, err := quiver.New(quiver.Config{
                Dimension:       viper.GetInt("index.dimension"),
                StoragePath:     storagePath,
                MaxElements:     uint64(viper.GetInt("index.max_elements")),
                HNSWM:           viper.GetInt("index.hnsw_m"),
                HNSWEfConstruct: viper.GetInt("index.ef_construction"),
                HNSWEfSearch:    viper.GetInt("index.ef_search"),
                BatchSize:       viper.GetInt("index.batch_size"),
                Distance:        quiver.DistanceMetric(viper.GetInt("index.distance")),
        }, logger)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to create index", zap.Error(err))
                return fmt.Errorf("failed to create index: %w", err)
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if err := index.Close(); err != nil </span><span class="cov0" title="0">{
                        logger.Error("Failed to close index", zap.Error(err))
                }</span>
        }()

        <span class="cov0" title="0">server := api.NewServer(api.ServerOptions{Port: port}, index, logger)

        // Handle graceful shutdown
        ctx, stop := signal.NotifyContext(context.Background(), os.Interrupt, syscall.SIGTERM)
        defer stop()

        // Channel for startup errors
        startupErr := make(chan error, 1)
        // Channel for shutdown completion
        shutdownComplete := make(chan struct{})

        // Start server
        go func() </span><span class="cov0" title="0">{
                logger.Info("Starting server", zap.String("port", port))
                if err := server.Start(); err != nil </span><span class="cov0" title="0">{
                        if !errors.Is(err, http.ErrServerClosed) </span><span class="cov0" title="0">{
                                logger.Error("Server startup failed", zap.Error(err))
                                startupErr &lt;- err
                                return
                        }</span>
                }
        }()

        // Handle shutdown
        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                &lt;-ctx.Done()
                logger.Info("Shutdown signal received")

                shutdownCtx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
                defer cancel()

                if err := server.Shutdown(shutdownCtx); err != nil </span><span class="cov0" title="0">{
                        logger.Error("Server shutdown error", zap.Error(err))
                }</span> else<span class="cov0" title="0"> {
                        logger.Info("Server shutdown completed successfully")
                }</span>
                <span class="cov0" title="0">close(shutdownComplete)</span>
        }()

        // Wait for either startup error or shutdown completion
        <span class="cov0" title="0">select </span>{
        case err := &lt;-startupErr:<span class="cov0" title="0">
                return fmt.Errorf("server startup failed: %w", err)</span>
        case &lt;-shutdownComplete:<span class="cov0" title="0">
                return nil</span>
        }
}

func checkStatus(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
        port := viper.GetString("server.port")
        if port == "" </span><span class="cov0" title="0">{
                port = "8080"
        }</span>

        <span class="cov0" title="0">url := fmt.Sprintf("http://localhost:%s/health", port)
        resp, err := http.Get(url)
        if err != nil </span><span class="cov0" title="0">{
                // Check if it's a connection error
                if errors.Is(err, syscall.ECONNREFUSED) </span><span class="cov0" title="0">{
                        logger.Info("Server is not running")
                        return fmt.Errorf("server is not running on port %s", port)
                }</span>
                // For other errors
                <span class="cov0" title="0">logger.Warn("Failed to check server status", zap.Error(err))
                return fmt.Errorf("failed to check server status: %w", err)</span>
        }
        <span class="cov0" title="0">defer resp.Body.Close()

        if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                logger.Warn("Server returned unhealthy status", zap.Int("status_code", resp.StatusCode))
                return fmt.Errorf("server is running but returned unhealthy status: %d", resp.StatusCode)
        }</span>

        <span class="cov0" title="0">logger.Info("Server is running and healthy", zap.String("port", port))
        return nil</span>
}

func runBackup(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
        backupPath := args[0]
        idx, err := loadIndex()
        if err != nil </span><span class="cov0" title="0">{
                logger.Fatal("Failed to load index", zap.Error(err))
                return err
        }</span>
        <span class="cov0" title="0">defer idx.Close()

        fmt.Printf("Creating backup at: %s\n", backupPath)

        // Create backup
        err = idx.Backup(backupPath, false, true)
        if err != nil </span><span class="cov0" title="0">{
                logger.Fatal("Failed to create backup", zap.Error(err))
                return err
        }</span>

        <span class="cov0" title="0">fmt.Println("Backup created successfully!")
        return nil</span>
}

func runRestore(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
        backupPath := args[0]
        idx, err := loadIndex()
        if err != nil </span><span class="cov0" title="0">{
                logger.Fatal("Failed to load index", zap.Error(err))
                return err
        }</span>
        <span class="cov0" title="0">defer idx.Close()

        fmt.Printf("Restoring from backup: %s\n", backupPath)

        // Restore from backup
        err = idx.Restore(backupPath)
        if err != nil </span><span class="cov0" title="0">{
                logger.Fatal("Failed to restore from backup", zap.Error(err))
                return err
        }</span>

        <span class="cov0" title="0">fmt.Println("Restore completed successfully!")
        return nil</span>
}

// Helper functions

func loadIndex() (*quiver.Index, error) <span class="cov0" title="0">{
        // Set default index configuration
        viper.SetDefault("index.dimension", 128)
        viper.SetDefault("index.storage_path", "quiver.db")
        viper.SetDefault("index.max_elements", 100000)
        viper.SetDefault("index.hnsw_m", 32)
        viper.SetDefault("index.ef_construction", 200)
        viper.SetDefault("index.ef_search", 200)
        viper.SetDefault("index.batch_size", 1000)
        viper.SetDefault("index.distance", int(quiver.Cosine))

        // Override storage path if provided
        storagePath := viper.GetString("index.storage_path")
        if indexPath != "" </span><span class="cov0" title="0">{
                storagePath = indexPath
        }</span>

        // Create config from viper settings
        <span class="cov0" title="0">config := quiver.Config{
                Dimension:       viper.GetInt("index.dimension"),
                StoragePath:     storagePath,
                MaxElements:     uint64(viper.GetInt("index.max_elements")),
                HNSWM:           viper.GetInt("index.hnsw_m"),
                HNSWEfConstruct: viper.GetInt("index.ef_construction"),
                HNSWEfSearch:    viper.GetInt("index.ef_search"),
                BatchSize:       viper.GetInt("index.batch_size"),
                Distance:        quiver.DistanceMetric(viper.GetInt("index.distance")),
        }

        // Load the index
        return quiver.Load(config, logger)</span>
}

func getDistanceMetricName(metric quiver.DistanceMetric) string <span class="cov0" title="0">{
        switch metric </span>{
        case quiver.Cosine:<span class="cov0" title="0">
                return "Cosine"</span>
        case quiver.L2:<span class="cov0" title="0">
                return "L2 (Euclidean)"</span>
        default:<span class="cov0" title="0">
                return fmt.Sprintf("Unknown (%d)", metric)</span>
        }
}

func validateConfig(config quiver.Config) []string <span class="cov0" title="0">{
        var issues []string

        // Check required fields
        if config.Dimension &lt;= 0 </span><span class="cov0" title="0">{
                issues = append(issues, "Dimension must be greater than 0")
        }</span>

        <span class="cov0" title="0">if config.MaxElements &lt;= 0 </span><span class="cov0" title="0">{
                issues = append(issues, "MaxElements must be greater than 0")
        }</span>

        <span class="cov0" title="0">if config.HNSWM &lt;= 0 </span><span class="cov0" title="0">{
                issues = append(issues, "HNSWM must be greater than 0")
        }</span>

        <span class="cov0" title="0">if config.HNSWEfConstruct &lt;= 0 </span><span class="cov0" title="0">{
                issues = append(issues, "HNSWEfConstruct must be greater than 0")
        }</span>

        <span class="cov0" title="0">if config.HNSWEfSearch &lt;= 0 </span><span class="cov0" title="0">{
                issues = append(issues, "HNSWEfSearch must be greater than 0")
        }</span>

        // Check distance metric
        <span class="cov0" title="0">if config.Distance != quiver.Cosine &amp;&amp; config.Distance != quiver.L2 </span><span class="cov0" title="0">{
                issues = append(issues, fmt.Sprintf("Invalid distance metric: %d", config.Distance))
        }</span>

        // Check dimensionality reduction settings
        <span class="cov0" title="0">if config.EnableDimReduction </span><span class="cov0" title="0">{
                if config.DimReductionTarget &lt;= 0 </span><span class="cov0" title="0">{
                        issues = append(issues, "DimReductionTarget must be greater than 0 when EnableDimReduction is true")
                }</span>

                <span class="cov0" title="0">if config.DimReductionTarget &gt;= config.Dimension </span><span class="cov0" title="0">{
                        issues = append(issues, "DimReductionTarget must be less than Dimension")
                }</span>

                <span class="cov0" title="0">validMethods := map[string]bool{
                        "PCA":  true,
                        "TSNE": true,
                        "UMAP": true,
                }

                if !validMethods[config.DimReductionMethod] </span><span class="cov0" title="0">{
                        issues = append(issues, fmt.Sprintf("Invalid dimensionality reduction method: %s", config.DimReductionMethod))
                }</span>

                <span class="cov0" title="0">if config.DimReductionAdaptive &amp;&amp; (config.DimReductionMinVariance &lt;= 0 || config.DimReductionMinVariance &gt; 1) </span><span class="cov0" title="0">{
                        issues = append(issues, "DimReductionMinVariance must be between 0 and 1 when DimReductionAdaptive is true")
                }</span>
        }

        // Check encryption settings
        <span class="cov0" title="0">if config.EncryptionEnabled &amp;&amp; len(config.EncryptionKey) &lt; 32 </span><span class="cov0" title="0">{
                issues = append(issues, "EncryptionKey must be at least 32 bytes when EncryptionEnabled is true")
        }</span>

        <span class="cov0" title="0">return issues</span>
}

func main() <span class="cov0" title="0">{
        var err error
        logger, err = zap.NewProduction()
        if err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "Failed to initialize logger: %v\n", err)
                os.Exit(1)
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                // Sync is a best-effort operation, so we can ignore errors
                // or log them at a lower level
                if err := logger.Sync(); err != nil </span><span class="cov0" title="0">{
                        // This is a common error that can be safely ignored
                        if !strings.Contains(err.Error(), "sync /dev/stderr: invalid argument") </span><span class="cov0" title="0">{
                                fmt.Fprintf(os.Stderr, "Failed to sync logger: %v\n", err)
                        }</span>
                }
        }()

        <span class="cov0" title="0">if err := rootCmd.Execute(); err != nil </span><span class="cov0" title="0">{
                // Don't log stack trace for expected errors
                fmt.Fprintln(os.Stderr, "Error:", err)
                os.Exit(1)
        }</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package quiver

import (
        "fmt"
        "strings"
        "time"
)

// ValidationIssue represents a configuration validation issue
type ValidationIssue struct {
        Field      string             // The field with the issue
        Value      interface{}        // The current value
        Message    string             // Description of the issue
        Severity   ValidationSeverity // How severe the issue is
        Suggestion string             // Suggested fix
}

// ValidationSeverity indicates how severe a validation issue is
type ValidationSeverity int

const (
        // Error indicates a configuration that will not work
        Error ValidationSeverity = iota
        // Warning indicates a configuration that may cause problems
        Warning
        // Info indicates a configuration that could be improved
        Info
)

// String returns a string representation of the severity
func (s ValidationSeverity) String() string <span class="cov0" title="0">{
        switch s </span>{
        case Error:<span class="cov0" title="0">
                return "ERROR"</span>
        case Warning:<span class="cov0" title="0">
                return "WARNING"</span>
        case Info:<span class="cov0" title="0">
                return "INFO"</span>
        default:<span class="cov0" title="0">
                return "UNKNOWN"</span>
        }
}

// ValidateConfig performs comprehensive validation of a Quiver configuration
// and returns a list of validation issues
func ValidateConfig(config Config) []ValidationIssue <span class="cov10" title="12">{
        var issues []ValidationIssue

        // Validate dimension
        if config.Dimension &lt;= 0 </span><span class="cov0" title="0">{
                issues = append(issues, ValidationIssue{
                        Field:      "Dimension",
                        Value:      config.Dimension,
                        Message:    "Dimension must be greater than 0",
                        Severity:   Error,
                        Suggestion: "Set Dimension to a positive value based on your embedding model's output size",
                })
        }</span> else<span class="cov10" title="12"> if config.Dimension &gt; 10000 </span><span class="cov0" title="0">{
                issues = append(issues, ValidationIssue{
                        Field:      "Dimension",
                        Value:      config.Dimension,
                        Message:    "Dimension is unusually high",
                        Severity:   Warning,
                        Suggestion: "Consider using dimensionality reduction for better performance",
                })
        }</span>

        // Validate storage path
        <span class="cov10" title="12">if config.StoragePath == "" </span><span class="cov0" title="0">{
                issues = append(issues, ValidationIssue{
                        Field:      "StoragePath",
                        Value:      config.StoragePath,
                        Message:    "StoragePath is empty",
                        Severity:   Warning,
                        Suggestion: "Set StoragePath to a valid directory for persistence",
                })
        }</span>

        // Validate distance metric
        <span class="cov10" title="12">if config.Distance != Cosine &amp;&amp; config.Distance != L2 </span><span class="cov0" title="0">{
                issues = append(issues, ValidationIssue{
                        Field:      "Distance",
                        Value:      config.Distance,
                        Message:    "Invalid distance metric",
                        Severity:   Error,
                        Suggestion: "Use quiver.Cosine or quiver.L2",
                })
        }</span>

        // Validate HNSW parameters
        <span class="cov10" title="12">if config.HNSWM &lt;= 0 </span><span class="cov0" title="0">{
                issues = append(issues, ValidationIssue{
                        Field:      "HNSWM",
                        Value:      config.HNSWM,
                        Message:    "HNSWM must be greater than 0",
                        Severity:   Error,
                        Suggestion: "Set HNSWM to a value between 5 and 100 (16 is a good default)",
                })
        }</span> else<span class="cov10" title="12"> if config.HNSWM &lt; 5 </span><span class="cov0" title="0">{
                issues = append(issues, ValidationIssue{
                        Field:      "HNSWM",
                        Value:      config.HNSWM,
                        Message:    "HNSWM is too low for good recall",
                        Severity:   Warning,
                        Suggestion: "Consider increasing HNSWM to at least 5 for better recall",
                })
        }</span> else<span class="cov10" title="12"> if config.HNSWM &gt; 100 </span><span class="cov0" title="0">{
                issues = append(issues, ValidationIssue{
                        Field:      "HNSWM",
                        Value:      config.HNSWM,
                        Message:    "HNSWM is unusually high",
                        Severity:   Warning,
                        Suggestion: "High HNSWM values increase memory usage and construction time",
                })
        }</span>

        <span class="cov10" title="12">if config.HNSWEfConstruct &lt;= 0 </span><span class="cov0" title="0">{
                issues = append(issues, ValidationIssue{
                        Field:      "HNSWEfConstruct",
                        Value:      config.HNSWEfConstruct,
                        Message:    "HNSWEfConstruct must be greater than 0",
                        Severity:   Error,
                        Suggestion: "Set HNSWEfConstruct to a value between 50 and 500 (200 is a good default)",
                })
        }</span> else<span class="cov10" title="12"> if config.HNSWEfConstruct &lt; 50 </span><span class="cov0" title="0">{
                issues = append(issues, ValidationIssue{
                        Field:      "HNSWEfConstruct",
                        Value:      config.HNSWEfConstruct,
                        Message:    "HNSWEfConstruct is too low for good recall",
                        Severity:   Warning,
                        Suggestion: "Consider increasing HNSWEfConstruct to at least 50 for better recall",
                })
        }</span>

        <span class="cov10" title="12">if config.HNSWEfSearch &lt;= 0 </span><span class="cov0" title="0">{
                issues = append(issues, ValidationIssue{
                        Field:      "HNSWEfSearch",
                        Value:      config.HNSWEfSearch,
                        Message:    "HNSWEfSearch must be greater than 0",
                        Severity:   Error,
                        Suggestion: "Set HNSWEfSearch to a value between 20 and 500 (100 is a good default)",
                })
        }</span> else<span class="cov10" title="12"> if config.HNSWEfSearch &lt; 20 </span><span class="cov0" title="0">{
                issues = append(issues, ValidationIssue{
                        Field:      "HNSWEfSearch",
                        Value:      config.HNSWEfSearch,
                        Message:    "HNSWEfSearch is too low for good recall",
                        Severity:   Warning,
                        Suggestion: "Consider increasing HNSWEfSearch to at least 20 for better recall",
                })
        }</span>

        // Validate batch size
        <span class="cov10" title="12">if config.BatchSize &lt;= 0 </span><span class="cov0" title="0">{
                issues = append(issues, ValidationIssue{
                        Field:      "BatchSize",
                        Value:      config.BatchSize,
                        Message:    "BatchSize must be greater than 0",
                        Severity:   Error,
                        Suggestion: "Set BatchSize to a positive value (1000 is a good default)",
                })
        }</span> else<span class="cov10" title="12"> if config.BatchSize &lt; 100 </span><span class="cov6" title="5">{
                issues = append(issues, ValidationIssue{
                        Field:      "BatchSize",
                        Value:      config.BatchSize,
                        Message:    "BatchSize is unusually low",
                        Severity:   Info,
                        Suggestion: "Small batch sizes may reduce throughput for bulk operations",
                })
        }</span> else<span class="cov8" title="7"> if config.BatchSize &gt; 10000 </span><span class="cov0" title="0">{
                issues = append(issues, ValidationIssue{
                        Field:      "BatchSize",
                        Value:      config.BatchSize,
                        Message:    "BatchSize is unusually high",
                        Severity:   Warning,
                        Suggestion: "Very large batch sizes may cause memory pressure",
                })
        }</span>

        // Validate persistence interval
        <span class="cov10" title="12">if config.PersistInterval &lt; time.Second </span><span class="cov9" title="11">{
                issues = append(issues, ValidationIssue{
                        Field:      "PersistInterval",
                        Value:      config.PersistInterval,
                        Message:    "PersistInterval is too short",
                        Severity:   Warning,
                        Suggestion: "Set PersistInterval to at least 1 second (5 minutes is recommended)",
                })
        }</span>

        // Validate backup settings
        <span class="cov10" title="12">if config.BackupInterval &gt; 0 &amp;&amp; config.BackupPath == "" </span><span class="cov0" title="0">{
                issues = append(issues, ValidationIssue{
                        Field:      "BackupPath",
                        Value:      config.BackupPath,
                        Message:    "BackupPath is empty but BackupInterval is set",
                        Severity:   Error,
                        Suggestion: "Specify a BackupPath for scheduled backups",
                })
        }</span>

        <span class="cov10" title="12">if config.MaxBackups &lt; 1 &amp;&amp; config.BackupInterval &gt; 0 </span><span class="cov0" title="0">{
                issues = append(issues, ValidationIssue{
                        Field:      "MaxBackups",
                        Value:      config.MaxBackups,
                        Message:    "MaxBackups must be at least 1 when backups are enabled",
                        Severity:   Error,
                        Suggestion: "Set MaxBackups to at least 1 (5 is recommended)",
                })
        }</span>

        // Validate encryption settings
        <span class="cov10" title="12">if config.EncryptionEnabled &amp;&amp; len(config.EncryptionKey) &lt; 32 </span><span class="cov0" title="0">{
                issues = append(issues, ValidationIssue{
                        Field:      "EncryptionKey",
                        Value:      "***",
                        Message:    "EncryptionKey is too short",
                        Severity:   Error,
                        Suggestion: "EncryptionKey must be at least 32 bytes long",
                })
        }</span>

        // Validate dimensionality reduction settings
        <span class="cov10" title="12">if config.EnableDimReduction </span><span class="cov0" title="0">{
                if config.DimReductionTarget &lt;= 0 </span><span class="cov0" title="0">{
                        issues = append(issues, ValidationIssue{
                                Field:      "DimReductionTarget",
                                Value:      config.DimReductionTarget,
                                Message:    "DimReductionTarget must be greater than 0",
                                Severity:   Error,
                                Suggestion: "Set DimReductionTarget to a positive value",
                        })
                }</span> else<span class="cov0" title="0"> if config.DimReductionTarget &gt;= config.Dimension </span><span class="cov0" title="0">{
                        issues = append(issues, ValidationIssue{
                                Field:      "DimReductionTarget",
                                Value:      config.DimReductionTarget,
                                Message:    "DimReductionTarget must be less than Dimension",
                                Severity:   Error,
                                Suggestion: fmt.Sprintf("Set DimReductionTarget to a value less than %d", config.Dimension),
                        })
                }</span>

                <span class="cov0" title="0">validMethods := map[string]bool{
                        "PCA":  true,
                        "TSNE": false,
                        "UMAP": false,
                }

                if !validMethods[config.DimReductionMethod] </span><span class="cov0" title="0">{
                        methods := []string{"PCA", "TSNE", "UMAP"}
                        issues = append(issues, ValidationIssue{
                                Field:      "DimReductionMethod",
                                Value:      config.DimReductionMethod,
                                Message:    "Invalid dimensionality reduction method",
                                Severity:   Error,
                                Suggestion: fmt.Sprintf("Use one of: %s", strings.Join(methods, ", ")),
                        })
                }</span>

                <span class="cov0" title="0">if config.DimReductionAdaptive &amp;&amp; (config.DimReductionMinVariance &lt;= 0 || config.DimReductionMinVariance &gt; 1) </span><span class="cov0" title="0">{
                        issues = append(issues, ValidationIssue{
                                Field:      "DimReductionMinVariance",
                                Value:      config.DimReductionMinVariance,
                                Message:    "DimReductionMinVariance must be between 0 and 1",
                                Severity:   Error,
                                Suggestion: "Set DimReductionMinVariance to a value between 0 and 1 (0.95 is recommended)",
                        })
                }</span>
        }

        // Validate max elements
        <span class="cov10" title="12">if config.MaxElements &lt;= 0 </span><span class="cov0" title="0">{
                issues = append(issues, ValidationIssue{
                        Field:      "MaxElements",
                        Value:      config.MaxElements,
                        Message:    "MaxElements must be greater than 0",
                        Severity:   Error,
                        Suggestion: "Set MaxElements to the maximum number of vectors you expect to store",
                })
        }</span>

        <span class="cov10" title="12">return issues</span>
}

// FormatValidationIssues returns a formatted string representation of validation issues
func FormatValidationIssues(issues []ValidationIssue) string <span class="cov0" title="0">{
        if len(issues) == 0 </span><span class="cov0" title="0">{
                return "Configuration is valid."
        }</span>

        <span class="cov0" title="0">var errorCount, warningCount, infoCount int
        var sb strings.Builder

        sb.WriteString(fmt.Sprintf("Found %d configuration issues:\n\n", len(issues)))

        for i, issue := range issues </span><span class="cov0" title="0">{
                switch issue.Severity </span>{
                case Error:<span class="cov0" title="0">
                        errorCount++</span>
                case Warning:<span class="cov0" title="0">
                        warningCount++</span>
                case Info:<span class="cov0" title="0">
                        infoCount++</span>
                }

                <span class="cov0" title="0">sb.WriteString(fmt.Sprintf("%d. [%s] %s: %v\n", i+1, issue.Severity, issue.Field, issue.Message))
                sb.WriteString(fmt.Sprintf("   Current value: %v\n", issue.Value))
                sb.WriteString(fmt.Sprintf("   Suggestion: %s\n\n", issue.Suggestion))</span>
        }

        <span class="cov0" title="0">sb.WriteString(fmt.Sprintf("Summary: %d errors, %d warnings, %d informational\n",
                errorCount, warningCount, infoCount))

        return sb.String()</span>
}

// ValidateConfigAndPrint validates a configuration and prints the results
func ValidateConfigAndPrint(config Config) bool <span class="cov0" title="0">{
        issues := ValidateConfig(config)
        fmt.Println(FormatValidationIssues(issues))

        // Return true if there are no errors (warnings and info are ok)
        for _, issue := range issues </span><span class="cov0" title="0">{
                if issue.Severity == Error </span><span class="cov0" title="0">{
                        return false
                }</span>
        }
        <span class="cov0" title="0">return true</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package quiver

import (
        "archive/zip"
        "bytes"
        "compress/gzip"
        "context"
        "crypto/aes"
        "crypto/cipher"
        "crypto/rand"
        "crypto/sha256"
        "encoding/hex"
        "errors"
        "fmt"
        "io"
        "math"
        "os"
        "path/filepath"
        "runtime"
        "sort"
        "strings"
        "sync"
        "time"

        "github.com/TFMV/hnsw"
        "github.com/apache/arrow-adbc/go/adbc"
        "github.com/apache/arrow-adbc/go/adbc/drivermgr"
        "github.com/apache/arrow-go/v18/arrow"
        "github.com/apache/arrow-go/v18/arrow/array"
        "github.com/apache/arrow-go/v18/arrow/memory"
        "github.com/bytedance/sonic"
        "go.uber.org/zap"
)

// DistanceMetric defines the similarity metrics.
type DistanceMetric int

const (
        Cosine DistanceMetric = iota
        L2
)

// Define distance metrics for our own use
const (
        CosineDistance = 0
        L2Distance     = 1
)

// Config holds the index settings and tunable hyperparameters.
type Config struct {
        Dimension       int
        StoragePath     string // Base directory for storing index files.
        Distance        DistanceMetric
        MaxElements     uint64
        HNSWM           int // HNSW hyperparameter M
        HNSWEfConstruct int // HNSW hyperparameter efConstruction
        HNSWEfSearch    int // HNSW hyperparameter ef used during queries
        BatchSize       int // Number of vectors to batch before insertion
        // Parallel search configuration
        EnableParallelSearch bool // Whether to use parallel search for large queries
        NumSearchWorkers     int  // Number of workers for parallel search (0 = use all available cores)
        // Persistence configuration
        PersistInterval time.Duration // How often to persist index to disk (default: 5m)
        // Backup configuration
        BackupInterval    time.Duration // How often to create backups (default: 1h)
        BackupPath        string        // Path to store backups (default: StoragePath/backups)
        BackupCompression bool          // Whether to compress backups (default: true)
        MaxBackups        int           // Maximum number of backups to keep (default: 5)
        // Security configuration
        EncryptionEnabled bool   // Whether to encrypt data at rest
        EncryptionKey     string // Key for encrypting data at rest (min 32 bytes)
        // Dimensionality reduction configuration
        EnableDimReduction      bool    // Whether to enable dimensionality reduction
        DimReductionMethod      string  // Method to use for dimensionality reduction (e.g., "PCA")
        DimReductionTarget      int     // Target dimension for reduction
        DimReductionAdaptive    bool    // Whether to use adaptive dimensionality reduction
        DimReductionMinVariance float64 // Minimum variance to explain (0.0-1.0) for adaptive reduction
}

// vectorMeta holds a vector and its metadata for batch insertion.
type vectorMeta struct {
        id     uint64
        vector []float32
        meta   map[string]interface{}
}

// SearchResult holds the output of a search.
type SearchResult struct {
        ID       uint64
        Distance float32
        Metadata map[string]interface{}
}

// Index is the main structure for vector search.
type Index struct {
        config          Config
        hnsw            *hnsw.Graph[uint64]
        metadata        map[uint64]map[string]interface{}
        vectors         map[uint64][]float32 // Store vectors for queries with negative examples
        duckdb          *DuckDB
        dbConn          *DuckDBConn
        lock            sync.RWMutex
        searchLock      sync.Mutex // Dedicated mutex for search operations
        batchBuffer     []vectorMeta
        batchLock       sync.Mutex
        cache           sync.Map // Caches metadata: key = id, value = metadata map
        batchTicker     *time.Ticker
        batchDone       chan struct{}
        logger          *zap.Logger
        persistInterval time.Duration
        persistTicker   *time.Ticker
        persistDone     chan struct{}
        lastPersistID   uint64
        // Backup related fields
        backupTicker   *time.Ticker
        backupDone     chan struct{}
        lastBackupTime time.Time
        // A waitgroup to ensure background workers exit on close.
        bgWG sync.WaitGroup
        // Dimensionality reduction fields
        dimReducer        interface{} // Will hold a dimreduce.DimReducer if enabled
        originalDimension int         // Original dimension before reduction
        allocator         memory.Allocator
        flushSemaphore    chan struct{}
}

// DuckDBOptions define the configuration for opening a DuckDB database.
type DuckDBOptions struct {
        // Path to the DuckDB file ("" =&gt; in-memory)
        Path string

        // DriverPath is the location of libduckdb.so, if empty =&gt; auto-detect
        DriverPath string

        // Context for new database/connection usage
        Context context.Context
}

// DuckDBOption is a functional config approach
type DuckDBOption func(*DuckDBOptions)

// WithPath sets a file path for the DuckDB DB.
func WithPath(p string) DuckDBOption <span class="cov4" title="12">{
        return func(o *DuckDBOptions) </span><span class="cov4" title="12">{
                o.Path = p
        }</span>
}

// WithDriverPath sets the path to the DuckDB driver library.
// If not provided, the driver will be auto-detected based on the current OS.
func WithDriverPath(p string) DuckDBOption <span class="cov0" title="0">{
        return func(o *DuckDBOptions) </span><span class="cov0" title="0">{
                o.DriverPath = p
        }</span>
}

// WithContext sets a custom Context for DB usage.
func WithContext(ctx context.Context) DuckDBOption <span class="cov0" title="0">{
        return func(o *DuckDBOptions) </span><span class="cov0" title="0">{
                o.Context = ctx
        }</span>
}

// DuckDB is the primary struct managing a DuckDB database via ADBC.
type DuckDB struct {
        mu     sync.Mutex
        db     adbc.Database
        driver adbc.Driver
        opts   DuckDBOptions

        conns []*DuckDBConn // track open connections
}

// DuckDBConn is a simple wrapper holding an open connection.
type DuckDBConn struct {
        parent *DuckDB
        conn   adbc.Connection
}

// NewDuckDB opens or creates a DuckDB instance (file-based or in-memory).
// The driver library is auto-detected if not provided.
func NewDuckDB(options ...DuckDBOption) (*DuckDB, error) <span class="cov4" title="12">{
        // gather defaults
        var opts DuckDBOptions
        for _, opt := range options </span><span class="cov4" title="12">{
                opt(&amp;opts)
        }</span>
        <span class="cov4" title="12">if opts.Context == nil </span><span class="cov4" title="12">{
                opts.Context = context.Background()
        }</span>

        // auto-detect driver if empty
        <span class="cov4" title="12">dPath := opts.DriverPath
        if dPath == "" </span><span class="cov4" title="12">{
                switch runtime.GOOS </span>{
                case "darwin":<span class="cov4" title="12">
                        dPath = "/usr/local/lib/libduckdb.dylib"</span>
                case "linux":<span class="cov0" title="0">
                        dPath = "/usr/local/lib/libduckdb.so"</span>
                case "windows":<span class="cov0" title="0">
                        if home, err := os.UserHomeDir(); err == nil </span><span class="cov0" title="0">{
                                dPath = home + "/Downloads/duckdb-windows-amd64/duckdb.dll"
                        }</span>
                }
        }

        <span class="cov4" title="12">dbOpts := map[string]string{
                "driver":     dPath,
                "entrypoint": "duckdb_adbc_init",
        }
        if opts.Path != "" </span><span class="cov4" title="12">{
                dbOpts["path"] = opts.Path
        }</span>

        <span class="cov4" title="12">driver := drivermgr.Driver{}
        db, err := driver.NewDatabase(dbOpts)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error creating new DuckDB database: %w", err)
        }</span>

        <span class="cov4" title="12">duck := &amp;DuckDB{
                db:     db,
                driver: driver,
                opts:   opts,
        }
        return duck, nil</span>
}

// OpenConnection opens a new connection to DuckDB.
func (d *DuckDB) OpenConnection() (*DuckDBConn, error) <span class="cov4" title="12">{
        d.mu.Lock()
        defer d.mu.Unlock()

        conn, err := d.db.Open(d.opts.Context)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to open connection: %w", err)
        }</span>
        <span class="cov4" title="12">dc := &amp;DuckDBConn{parent: d, conn: conn}
        d.conns = append(d.conns, dc)
        return dc, nil</span>
}

// Close closes the DuckDB database and all open connections.
func (d *DuckDB) Close() error <span class="cov3" title="7">{
        d.mu.Lock()
        defer d.mu.Unlock()

        // close all open conns
        for _, c := range d.conns </span><span class="cov0" title="0">{
                c.conn.Close()
        }</span>
        <span class="cov3" title="7">d.conns = nil

        // close db
        return d.db.Close()</span>
}

// ConnCount returns the current number of open connections.
func (d *DuckDB) ConnCount() int <span class="cov1" title="1">{
        d.mu.Lock()
        defer d.mu.Unlock()
        return len(d.conns)
}</span>

// Path returns the database file path, or empty if in-memory.
func (d *DuckDB) Path() string <span class="cov0" title="0">{
        return d.opts.Path
}</span>

// Exec runs a statement that doesn't produce a result set, returning
// the number of rows affected if known, else -1.
func (c *DuckDBConn) Exec(ctx context.Context, sql string) (int64, error) <span class="cov5" title="22">{
        stmt, err := c.conn.NewStatement()
        if err != nil </span><span class="cov0" title="0">{
                return -1, fmt.Errorf("failed to create statement: %w", err)
        }</span>
        <span class="cov5" title="22">defer stmt.Close()

        if err := stmt.SetSqlQuery(sql); err != nil </span><span class="cov0" title="0">{
                return -1, fmt.Errorf("failed to set SQL query: %w", err)
        }</span>
        <span class="cov5" title="22">affected, err := stmt.ExecuteUpdate(ctx)
        return affected, err</span>
}

// Query runs a SQL query returning (RecordReader, adbc.Statement, rowCount).
// rowCount will be -1 if not known. Caller is responsible for closing the
// returned statement and the RecordReader.
func (c *DuckDBConn) Query(ctx context.Context, sql string) (array.RecordReader, adbc.Statement, int64, error) <span class="cov4" title="8">{
        stmt, err := c.conn.NewStatement()
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, -1, fmt.Errorf("failed to create statement: %w", err)
        }</span>
        <span class="cov4" title="8">if err := stmt.SetSqlQuery(sql); err != nil </span><span class="cov0" title="0">{
                stmt.Close()
                return nil, nil, -1, fmt.Errorf("failed to set SQL query: %w", err)
        }</span>

        <span class="cov4" title="8">rr, rowsAffected, err := stmt.ExecuteQuery(ctx)
        if err != nil </span><span class="cov0" title="0">{
                stmt.Close()
                return nil, nil, -1, err
        }</span>
        <span class="cov4" title="8">return rr, stmt, rowsAffected, nil</span>
}

// GetTableSchema fetches the Arrow schema of a table in the given catalog/schema
// (pass nil for defaults).
func (c *DuckDBConn) GetTableSchema(ctx context.Context, catalog, dbSchema *string, tableName string) (*arrow.Schema, error) <span class="cov1" title="1">{
        return c.conn.GetTableSchema(ctx, catalog, dbSchema, tableName)
}</span>

// IngestCreateAppend ingests an arrow.Record into a DuckDB table. If the table does not
// exist, it is created from the record's schema. Otherwise, it appends. Returns
// the number of rows affected if known, else -1.
func (c *DuckDBConn) IngestCreateAppend(ctx context.Context, tableName string, rec arrow.Record) (int64, error) <span class="cov1" title="1">{
        if tableName == "" </span><span class="cov0" title="0">{
                return -1, fmt.Errorf("no target tableName provided")
        }</span>
        <span class="cov1" title="1">if rec == nil </span><span class="cov0" title="0">{
                return -1, fmt.Errorf("nil arrow record")
        }</span>
        <span class="cov1" title="1">existing, _ := c.GetTableSchema(ctx, nil, nil, tableName)

        stmt, err := c.conn.NewStatement()
        if err != nil </span><span class="cov0" title="0">{
                return -1, fmt.Errorf("failed to create statement: %w", err)
        }</span>
        <span class="cov1" title="1">defer stmt.Close()

        // If the table does not exist =&gt; create, else append
        mode := adbc.OptionValueIngestModeCreate
        if existing != nil </span><span class="cov1" title="1">{
                mode = adbc.OptionValueIngestModeAppend
        }</span>
        <span class="cov1" title="1">err = stmt.SetOption(adbc.OptionKeyIngestMode, mode)
        if err != nil </span><span class="cov0" title="0">{
                return -1, fmt.Errorf("failed to set ingest mode: %w", err)
        }</span>
        <span class="cov1" title="1">err = stmt.SetOption(adbc.OptionKeyIngestTargetTable, tableName)
        if err != nil </span><span class="cov0" title="0">{
                return -1, fmt.Errorf("failed to set ingest target: %w", err)
        }</span>
        // Bind the record
        <span class="cov1" title="1">if err := stmt.Bind(ctx, rec); err != nil </span><span class="cov0" title="0">{
                return -1, fmt.Errorf("failed to bind arrow record: %w", err)
        }</span>
        // Execute
        <span class="cov1" title="1">affected, err := stmt.ExecuteUpdate(ctx)
        return affected, err</span>
}

// Close closes the connection, removing it from the parent DuckDB's tracking.
func (c *DuckDBConn) Close() error <span class="cov3" title="7">{
        c.parent.mu.Lock()
        defer c.parent.mu.Unlock()
        // remove from parent
        for i, cc := range c.parent.conns </span><span class="cov3" title="7">{
                if cc == c </span><span class="cov3" title="7">{
                        c.parent.conns[i] = c.parent.conns[len(c.parent.conns)-1]
                        c.parent.conns = c.parent.conns[:len(c.parent.conns)-1]
                        break</span>
                }
        }
        <span class="cov3" title="7">err := c.conn.Close()
        c.parent = nil
        return err</span>
}

// New creates a new Quiver index with the given configuration.
func New(config Config, logger *zap.Logger) (*Index, error) <span class="cov4" title="12">{
        // Validate configuration
        issues := ValidateConfig(config)

        // Check for critical errors
        var errorCount int
        for _, issue := range issues </span><span class="cov5" title="16">{
                if issue.Severity == Error </span><span class="cov0" title="0">{
                        errorCount++
                        logger.Error("Configuration error",
                                zap.String("field", issue.Field),
                                zap.Any("value", issue.Value),
                                zap.String("message", issue.Message),
                                zap.String("suggestion", issue.Suggestion))
                }</span>
        }

        // If there are errors, return a detailed error message
        <span class="cov4" title="12">if errorCount &gt; 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid configuration: %d critical errors found. See logs for details", errorCount)
        }</span>

        // Log warnings
        <span class="cov4" title="12">for _, issue := range issues </span><span class="cov5" title="16">{
                if issue.Severity == Warning </span><span class="cov4" title="11">{
                        logger.Warn("Configuration warning",
                                zap.String("field", issue.Field),
                                zap.Any("value", issue.Value),
                                zap.String("message", issue.Message),
                                zap.String("suggestion", issue.Suggestion))
                }</span>
        }

        // Log informational issues
        <span class="cov4" title="12">for _, issue := range issues </span><span class="cov5" title="16">{
                if issue.Severity == Info </span><span class="cov3" title="5">{
                        logger.Info("Configuration suggestion",
                                zap.String("field", issue.Field),
                                zap.Any("value", issue.Value),
                                zap.String("message", issue.Message),
                                zap.String("suggestion", issue.Suggestion))
                }</span>
        }

        // Set default values for optional fields
        <span class="cov4" title="12">if config.BatchSize &lt;= 0 </span><span class="cov0" title="0">{
                config.BatchSize = 1000
                logger.Info("Using default batch size", zap.Int("batchSize", config.BatchSize))
        }</span>

        // Validate config
        <span class="cov4" title="12">if config.Dimension &lt;= 0 </span><span class="cov0" title="0">{
                return nil, errors.New("dimension must be positive")
        }</span>
        <span class="cov4" title="12">if config.MaxElements &lt;= 0 </span><span class="cov0" title="0">{
                return nil, errors.New("max_elements must be positive")
        }</span>
        <span class="cov4" title="12">if config.HNSWM &lt;= 0 </span><span class="cov0" title="0">{
                config.HNSWM = 16 // Default to a reasonable value
        }</span>
        <span class="cov4" title="12">if config.HNSWEfConstruct &lt;= 0 </span><span class="cov0" title="0">{
                config.HNSWEfConstruct = 200 // Default to a reasonable value
        }</span>
        <span class="cov4" title="12">if config.HNSWEfSearch &lt;= 0 </span><span class="cov0" title="0">{
                config.HNSWEfSearch = 100 // Default to a reasonable value
        }</span>

        // Set default persistence interval
        <span class="cov4" title="12">persistInterval := 5 * time.Minute
        if config.PersistInterval &gt; 0 </span><span class="cov1" title="1">{
                persistInterval = config.PersistInterval
        }</span>

        // Set backup defaults
        <span class="cov4" title="12">backupInterval := 1 * time.Hour
        if config.BackupInterval &gt; 0 </span><span class="cov1" title="1">{
                backupInterval = config.BackupInterval
        }</span>
        <span class="cov4" title="12">if config.BackupPath == "" </span><span class="cov4" title="11">{
                config.BackupPath = filepath.Join(config.StoragePath, "backups")
        }</span>
        <span class="cov4" title="12">if config.MaxBackups == 0 </span><span class="cov4" title="11">{
                config.MaxBackups = 5
        }</span>

        // Ensure StoragePath is an absolute path.
        <span class="cov4" title="12">config.StoragePath = filepath.Clean(config.StoragePath)
        if !filepath.IsAbs(config.StoragePath) </span><span class="cov0" title="0">{
                absPath, err := filepath.Abs(config.StoragePath)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to get absolute path: %w", err)
                }</span>
                <span class="cov0" title="0">config.StoragePath = absPath</span>
        }

        // Create storage directory if it doesn't exist.
        <span class="cov4" title="12">storageDir := filepath.Dir(config.StoragePath)
        if err := os.MkdirAll(storageDir, 0755); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create storage directory: %w", err)
        }</span>

        // Check if an existing index exists.
        <span class="cov4" title="12">indexFile := filepath.Join(storageDir, "index.hnsw")
        if _, err := os.Stat(indexFile); err == nil </span><span class="cov0" title="0">{
                return Load(config, logger)
        }</span>

        // If dimensionality reduction is enabled, validate the configuration
        <span class="cov4" title="12">originalDimension := config.Dimension
        if config.EnableDimReduction </span><span class="cov0" title="0">{
                if config.DimReductionTarget &lt;= 0 || config.DimReductionTarget &gt;= config.Dimension </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("invalid target dimension for reduction: %d (must be &gt; 0 and &lt; %d)",
                                config.DimReductionTarget, config.Dimension)
                }</span>

                <span class="cov0" title="0">if config.DimReductionMethod == "" </span><span class="cov0" title="0">{
                        config.DimReductionMethod = "PCA" // Default to PCA
                }</span>

                <span class="cov0" title="0">if config.DimReductionAdaptive &amp;&amp; (config.DimReductionMinVariance &lt;= 0 || config.DimReductionMinVariance &gt; 1.0) </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("invalid minimum variance for adaptive reduction: %f (must be &gt; 0 and &lt;= 1.0)",
                                config.DimReductionMinVariance)
                }</span>

                // Update the dimension to the target dimension for the HNSW graph
                <span class="cov0" title="0">config.Dimension = config.DimReductionTarget
                logger.Info("Dimensionality reduction enabled",
                        zap.Int("original_dimension", originalDimension),
                        zap.Int("reduced_dimension", config.Dimension),
                        zap.String("method", config.DimReductionMethod))</span>
        }

        // Initialize HNSW graph with the specified parameters
        <span class="cov4" title="12">var graph *hnsw.Graph[uint64]
        var err error

        // Configure the distance function based on the selected metric
        var distanceFunc hnsw.DistanceFunc
        switch config.Distance </span>{
        case Cosine:<span class="cov4" title="12">
                distanceFunc = hnsw.CosineDistance</span>
        case L2:<span class="cov0" title="0">
                distanceFunc = hnsw.EuclideanDistance</span>
        default:<span class="cov0" title="0">
                distanceFunc = hnsw.CosineDistance</span> // Default to cosine distance
        }

        // Create a new HNSW graph with the specified configuration
        <span class="cov4" title="12">graph, err = hnsw.NewGraphWithConfig[uint64](
                config.HNSWM,
                0.5, // Default Ml value (layer size ratio)
                config.HNSWEfSearch,
                distanceFunc,
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create HNSW graph: %w", err)
        }</span>

        // Open DuckDB connection using StoragePath
        <span class="cov4" title="12">duckdb, err := NewDuckDB(WithPath(config.StoragePath))
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to open DuckDB: %w", err)
        }</span>

        // Open a connection to the database
        <span class="cov4" title="12">dbConn, err := duckdb.OpenConnection()
        if err != nil </span><span class="cov0" title="0">{
                duckdb.Close()
                return nil, fmt.Errorf("failed to open DuckDB connection: %w", err)
        }</span>

        // Create metadata table if it doesn't exist.
        <span class="cov4" title="12">_, err = dbConn.Exec(context.Background(), `CREATE TABLE IF NOT EXISTS metadata (
                id BIGINT PRIMARY KEY,
                json VARCHAR
        )`)
        if err != nil </span><span class="cov0" title="0">{
                dbConn.Close()
                duckdb.Close()
                return nil, fmt.Errorf("failed to create metadata table: %w", err)
        }</span>

        <span class="cov4" title="12">idx := &amp;Index{
                config:            config,
                hnsw:              graph,
                metadata:          make(map[uint64]map[string]interface{}),
                vectors:           make(map[uint64][]float32),
                duckdb:            duckdb,
                dbConn:            dbConn,
                lock:              sync.RWMutex{},
                searchLock:        sync.Mutex{}, // Initialize the search lock
                batchBuffer:       make([]vectorMeta, 0, config.BatchSize),
                batchLock:         sync.Mutex{},
                logger:            logger,
                batchTicker:       time.NewTicker(time.Second),
                batchDone:         make(chan struct{}),
                persistInterval:   persistInterval,
                persistTicker:     time.NewTicker(persistInterval),
                persistDone:       make(chan struct{}),
                backupTicker:      time.NewTicker(backupInterval),
                backupDone:        make(chan struct{}),
                originalDimension: originalDimension,
                allocator:         memory.NewGoAllocator(),
                flushSemaphore:    make(chan struct{}, 1),
        }

        // Start background workers.
        idx.bgWG.Add(1)
        go func() </span><span class="cov4" title="12">{
                defer idx.bgWG.Done()
                idx.batchProcessor()
        }</span>()

        <span class="cov4" title="12">idx.bgWG.Add(1)
        go func() </span><span class="cov4" title="12">{
                defer idx.bgWG.Done()
                idx.persistenceWorker()
        }</span>()

        // Start backup worker.
        <span class="cov4" title="12">idx.bgWG.Add(1)
        go func() </span><span class="cov4" title="12">{
                defer idx.bgWG.Done()
                idx.backupWorker()
        }</span>()

        <span class="cov4" title="12">logger.Info("Quiver index initialized",
                zap.Int("dimension", config.Dimension),
                zap.Int("batchSize", config.BatchSize))
        return idx, nil</span>
}

// batchProcessor runs in the background and processes batched vectors.
func (idx *Index) batchProcessor() <span class="cov4" title="12">{
        for </span><span class="cov4" title="12">{
                select </span>{
                case &lt;-idx.batchTicker.C:<span class="cov0" title="0">
                        if len(idx.batchBuffer) &gt; 0 </span><span class="cov0" title="0">{
                                if err := idx.flushBatch(); err != nil </span><span class="cov0" title="0">{
                                        idx.logger.Error("failed to flush batch", zap.Error(err))
                                }</span>
                        }
                case &lt;-idx.batchDone:<span class="cov3" title="7">
                        idx.logger.Info("batch processor shutting down")
                        return</span>
                }
        }
}

// flushBatch flushes the current batch buffer to the database and updates in-memory structures.
func (idx *Index) flushBatch() error <span class="cov5" title="20">{
        // Acquire batch lock and copy the current batch
        idx.batchLock.Lock()
        if len(idx.batchBuffer) == 0 </span><span class="cov4" title="10">{
                idx.batchLock.Unlock()
                return nil // Nothing to flush
        }</span>

        // Make a copy of the batch buffer to process
        <span class="cov4" title="10">batchToProcess := make([]vectorMeta, len(idx.batchBuffer))
        copy(batchToProcess, idx.batchBuffer)

        // Reset the batch buffer and release the lock
        idx.batchBuffer = idx.batchBuffer[:0]
        idx.batchLock.Unlock()

        n := len(batchToProcess)

        // Prepare batch for SQL execution - this is done outside of any locks
        var values []string
        for _, item := range batchToProcess </span><span class="cov8" title="140">{
                metaJSON, err := sonic.Marshal(item.meta)
                if err != nil </span><span class="cov0" title="0">{
                        idx.logger.Error("failed to marshal metadata", zap.Uint64("id", item.id), zap.Error(err))
                        continue</span> // Skip this item but continue processing others
                }

                // Add to batch values - escape single quotes in JSON
                <span class="cov8" title="140">escapedJSON := strings.ReplaceAll(string(metaJSON), "'", "''")
                values = append(values, fmt.Sprintf("(%d, '%s')", item.id, escapedJSON))</span>
        }

        // Execute batch insert using ADBC - this is done outside of any locks
        <span class="cov4" title="10">if len(values) &gt; 0 &amp;&amp; idx.dbConn != nil </span><span class="cov4" title="10">{
                query := fmt.Sprintf("INSERT INTO metadata (id, json) VALUES %s ON CONFLICT(id) DO UPDATE SET json = excluded.json",
                        strings.Join(values, ","))

                // Use a context with timeout to prevent hanging
                ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
                defer cancel()

                _, err := idx.dbConn.Exec(ctx, query)
                if err != nil </span><span class="cov0" title="0">{
                        idx.logger.Error("failed to execute batch insert", zap.Error(err))
                        // Continue with in-memory updates even if DB insert fails
                }</span>
        }

        // Lock the index for updating shared in-memory structures only
        <span class="cov4" title="10">idx.lock.Lock()
        defer idx.lock.Unlock()

        // Update in-memory structures (HNSW graph, metadata, cache, vectors)
        for _, item := range batchToProcess </span><span class="cov8" title="140">{
                // Add to HNSW graph
                node := hnsw.MakeNode(item.id, item.vector)
                if err := idx.hnsw.Add(node); err != nil </span><span class="cov0" title="0">{
                        // Log the error but continue with other operations
                        // This is a non-fatal error as we can still use the vector in other ways
                        idx.logger.Warn("Failed to add node to HNSW graph",
                                zap.Uint64("id", item.id),
                                zap.Error(err))
                }</span>

                // Update in-memory metadata and cache
                <span class="cov8" title="140">idx.metadata[item.id] = item.meta
                idx.cache.Store(item.id, item.meta)

                // Store vector for negative example searches
                idx.vectors[item.id] = item.vector</span>
        }

        <span class="cov4" title="10">idx.logger.Debug("flushed batch", zap.Int("count", n))
        return nil</span>
}

// Add adds a vector to the index with the given ID and metadata.
func (idx *Index) Add(id uint64, vector []float32, metadata map[string]interface{}) error <span class="cov8" title="140">{
        // Validate vector dimension
        if !idx.config.EnableDimReduction || idx.dimReducer == nil </span><span class="cov8" title="140">{
                if len(vector) != idx.config.Dimension </span><span class="cov0" title="0">{
                        return fmt.Errorf("vector dimension (%d) does not match index dimension (%d)", len(vector), idx.config.Dimension)
                }</span>
        } else<span class="cov0" title="0"> {
                // If dimensionality reduction is enabled, check against original dimension
                if len(vector) != idx.originalDimension </span><span class="cov0" title="0">{
                        return fmt.Errorf("vector dimension (%d) does not match original dimension (%d)", len(vector), idx.originalDimension)
                }</span>
        }

        // Make a copy of the metadata to avoid modifying the caller's map
        <span class="cov8" title="140">metaCopy := make(map[string]interface{}, len(metadata))
        for k, v := range metadata </span><span class="cov10" title="406">{
                metaCopy[k] = v
        }</span>

        // We store vectors for use with negative example searches
        <span class="cov8" title="140">vectorCopy := make([]float32, len(vector))
        copy(vectorCopy, vector)

        // Add to batch for deferred insertion
        idx.batchLock.Lock()
        idx.batchBuffer = append(idx.batchBuffer, vectorMeta{
                id:     id,
                vector: vectorCopy,
                meta:   metaCopy,
        })

        // Check if batch buffer has reached the configured size
        needsFlush := len(idx.batchBuffer) &gt;= idx.config.BatchSize
        idx.batchLock.Unlock()

        // If batch buffer is full, flush it immediately in a separate goroutine
        // to avoid blocking the caller
        if needsFlush </span><span class="cov3" title="4">{
                // Use a separate goroutine with a semaphore to limit concurrent flushes
                select </span>{
                case idx.flushSemaphore &lt;- struct{}{}:<span class="cov2" title="3">
                        go func() </span><span class="cov2" title="3">{
                                defer func() </span><span class="cov2" title="3">{ &lt;-idx.flushSemaphore }</span>()
                                <span class="cov2" title="3">if err := idx.flushBatch(); err != nil </span><span class="cov0" title="0">{
                                        idx.logger.Error("failed to flush batch", zap.Error(err))
                                }</span>
                        }()
                default:<span class="cov1" title="1">
                        // If we can't acquire the semaphore, just continue without flushing
                        // The batch will be flushed by another goroutine or during the next Add
                        idx.logger.Debug("skipping flush due to too many concurrent flushes")</span>
                }
        }

        <span class="cov8" title="140">return nil</span>
}

// Search performs a vector similarity search and returns the k most similar vectors.
// Supports pagination with page and pageSize parameters.
func (idx *Index) Search(query []float32, k, page, pageSize int) ([]SearchResult, error) <span class="cov4" title="13">{
        // Validate query dimension
        if !idx.config.EnableDimReduction || idx.dimReducer == nil </span><span class="cov4" title="13">{
                if len(query) != idx.config.Dimension </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("query dimension (%d) does not match index dimension (%d)", len(query), idx.config.Dimension)
                }</span>
        } else<span class="cov0" title="0"> {
                // If dimensionality reduction is enabled, check against original dimension
                if len(query) != idx.originalDimension </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("query dimension (%d) does not match original dimension (%d)", len(query), idx.originalDimension)
                }</span>
        }

        <span class="cov4" title="13">idx.lock.RLock()
        defer idx.lock.RUnlock()

        // Validate parameters
        if k &lt;= 0 </span><span class="cov0" title="0">{
                return nil, errors.New("k must be positive")
        }</span>
        <span class="cov4" title="13">if page &lt;= 0 </span><span class="cov2" title="2">{
                page = 1 // Default to first page
        }</span>
        <span class="cov4" title="13">if pageSize &lt;= 0 </span><span class="cov0" title="0">{
                pageSize = 10 // Default page size
        }</span>

        // Ensure we have enough elements in the index
        <span class="cov4" title="13">currentCount := idx.hnsw.Len()
        if currentCount == 0 </span><span class="cov0" title="0">{
                return []SearchResult{}, nil
        }</span>

        // If k is too large relative to the number of elements, adjust it
        <span class="cov4" title="13">if k &gt; currentCount </span><span class="cov2" title="2">{
                k = currentCount
        }</span>

        // Use a higher ef value for better recall
        <span class="cov4" title="13">efSearch := idx.config.HNSWEfSearch * 2
        if efSearch &lt; k*4 </span><span class="cov0" title="0">{
                efSearch = k * 4
        }</span>

        // Ensure M is large enough
        <span class="cov4" title="13">if idx.config.HNSWM &lt; 16 </span><span class="cov0" title="0">{
                idx.logger.Warn("HNSW M parameter is too small, search may fail",
                        zap.Int("current_m", idx.config.HNSWM),
                        zap.Int("recommended_min", 16))
        }</span>

        // Perform search with proper error handling and recovery
        <span class="cov4" title="13">var results []hnsw.Node[uint64]
        var err error

        // Add debugging information
        idx.logger.Debug("Starting HNSW search",
                zap.Int("k", k),
                zap.Int("pageSize", pageSize),
                zap.Int("efSearch", efSearch),
                zap.Int("currentCount", currentCount),
                zap.Float32s("query", query))

        // Use a recovery function to catch exceptions
        func() </span><span class="cov4" title="13">{
                defer func() </span><span class="cov4" title="13">{
                        if r := recover(); r != nil </span><span class="cov0" title="0">{
                                err = fmt.Errorf("HNSW search panicked: %v", r)
                        }</span>
                }()

                // Set the ef parameter for the graph before searching
                // Store the original value so we can restore it after the search
                <span class="cov4" title="13">originalEf := idx.hnsw.EfSearch

                idx.hnsw.EfSearch = efSearch

                // Determine whether to use parallel search
                useParallelSearch := idx.config.EnableParallelSearch &amp;&amp;
                        (len(query) &gt;= 512 || currentCount &gt;= 5000)

                // Perform the search
                if useParallelSearch </span><span class="cov0" title="0">{
                        results, err = idx.hnsw.ParallelSearch(query, k*pageSize, idx.config.NumSearchWorkers)
                }</span> else<span class="cov4" title="13"> {
                        results, err = idx.hnsw.Search(query, k*pageSize)
                }</span>

                // Restore the original efSearch value
                <span class="cov4" title="13">idx.hnsw.EfSearch = originalEf</span>
        }()

        <span class="cov4" title="13">if err != nil </span><span class="cov0" title="0">{
                idx.logger.Error("HNSW search failed", zap.Error(err))
                return nil, fmt.Errorf("HNSW search failed: %w", err)
        }</span>

        <span class="cov4" title="13">start := (page - 1) * pageSize
        end := start + pageSize
        if start &gt;= len(results) </span><span class="cov0" title="0">{
                return nil, nil // No more results
        }</span>
        <span class="cov4" title="13">if end &gt; len(results) </span><span class="cov3" title="5">{
                end = len(results)
        }</span>

        <span class="cov4" title="13">var searchResults []SearchResult
        for _, r := range results[start:end] </span><span class="cov7" title="57">{
                // Calculate distance between query and result vector
                distance := computeDistance(query, r.Value, idx.config.Distance)
                meta := idx.getMetadata(r.Key)
                searchResults = append(searchResults, SearchResult{
                        ID:       r.Key,
                        Distance: distance,
                        Metadata: meta,
                })
        }</span>
        <span class="cov4" title="13">return searchResults, nil</span>
}

// SearchWithFilter performs a search and filters results based on a metadata query.
func (idx *Index) SearchWithFilter(query []float32, k int, filter string) ([]SearchResult, error) <span class="cov1" title="1">{

        // First, query metadata to get matching IDs
        metadataResults, err := idx.QueryMetadata(filter)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("metadata query failed: %w", err)
        }</span>

        // Extract IDs from metadata results
        <span class="cov1" title="1">matchingIDs := make(map[uint64]bool)
        for _, meta := range metadataResults </span><span class="cov1" title="1">{
                id, ok := meta["id"].(uint64)
                if !ok </span><span class="cov1" title="1">{
                        // Try to convert from float64 (common in JSON unmarshaling)
                        if idFloat, ok := meta["id"].(float64); ok </span><span class="cov0" title="0">{
                                id = uint64(idFloat)
                        }</span> else<span class="cov1" title="1"> {
                                continue</span>
                        }
                }
                <span class="cov0" title="0">matchingIDs[id] = true</span>
        }

        // If no matching IDs, return empty results
        <span class="cov1" title="1">if len(matchingIDs) == 0 </span><span class="cov1" title="1">{
                return []SearchResult{}, nil
        }</span>

        // Perform vector search
        <span class="cov0" title="0">results, err := idx.Search(query, k*10, 1, k*10) // Get more results to filter
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Filter results by matching IDs
        <span class="cov0" title="0">var filteredResults []SearchResult
        for _, result := range results </span><span class="cov0" title="0">{
                if matchingIDs[result.ID] </span><span class="cov0" title="0">{
                        filteredResults = append(filteredResults, result)
                        if len(filteredResults) &gt;= k </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
        }

        <span class="cov0" title="0">return filteredResults, nil</span>
}

// getMetadata retrieves metadata for a vector by ID.
func (idx *Index) getMetadata(id uint64) map[string]interface{} <span class="cov7" title="62">{
        // Check cache first
        if cached, ok := idx.cache.Load(id); ok </span><span class="cov7" title="57">{
                if meta, ok := cached.(map[string]interface{}); ok </span><span class="cov7" title="57">{
                        return meta
                }</span>
        }

        // Fall back to metadata map
        <span class="cov3" title="5">meta, ok := idx.metadata[id]
        if !ok </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov3" title="5">return meta</span>
}

// Save saves the index to the specified directory.
func (idx *Index) Save(saveDir string) error <span class="cov0" title="0">{
        idx.lock.Lock()
        defer idx.lock.Unlock()

        // Ensure save directory exists.
        if err := os.MkdirAll(saveDir, 0755); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create save directory: %w", err)
        }</span>

        // Flush any pending changes.
        <span class="cov0" title="0">if err := idx.flushBatch(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // TODO: Implement serialization for the HNSW graph
        // The coder/hnsw library doesn't provide a Save method, so we need to implement our own
        // serialization logic here

        // Export metadata.
        <span class="cov0" title="0">if err := idx.exportMetadata(filepath.Join(saveDir, "metadata.json"), false); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to export metadata: %w", err)
        }</span>

        <span class="cov0" title="0">idx.logger.Info("index saved", zap.String("path", saveDir))
        return nil</span>
}

// Load loads an index from the specified directory.
func Load(config Config, logger *zap.Logger) (*Index, error) <span class="cov0" title="0">{
        storageDir := filepath.Dir(config.StoragePath)

        // If dimensionality reduction is enabled, validate the configuration
        originalDimension := config.Dimension
        if config.EnableDimReduction </span><span class="cov0" title="0">{
                if config.DimReductionTarget &lt;= 0 || config.DimReductionTarget &gt;= config.Dimension </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("invalid target dimension for reduction: %d (must be &gt; 0 and &lt; %d)",
                                config.DimReductionTarget, config.Dimension)
                }</span>

                <span class="cov0" title="0">if config.DimReductionMethod == "" </span><span class="cov0" title="0">{
                        config.DimReductionMethod = "PCA" // Default to PCA
                }</span>

                <span class="cov0" title="0">if config.DimReductionAdaptive &amp;&amp; (config.DimReductionMinVariance &lt;= 0 || config.DimReductionMinVariance &gt; 1.0) </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("invalid minimum variance for adaptive reduction: %f (must be &gt; 0 and &lt;= 1.0)",
                                config.DimReductionMinVariance)
                }</span>

                // Update the dimension to the target dimension for the HNSW graph
                <span class="cov0" title="0">config.Dimension = config.DimReductionTarget
                logger.Info("Dimensionality reduction enabled",
                        zap.Int("original_dimension", originalDimension),
                        zap.Int("reduced_dimension", config.Dimension),
                        zap.String("method", config.DimReductionMethod))</span>
        }

        // Configure the distance function based on the selected metric
        <span class="cov0" title="0">var distanceFunc hnsw.DistanceFunc
        switch config.Distance </span>{
        case Cosine:<span class="cov0" title="0">
                distanceFunc = hnsw.CosineDistance</span>
        case L2:<span class="cov0" title="0">
                distanceFunc = hnsw.EuclideanDistance</span>
        default:<span class="cov0" title="0">
                distanceFunc = hnsw.CosineDistance</span> // Default to cosine distance
        }

        // Create a new HNSW graph with the specified configuration
        <span class="cov0" title="0">graph, err := hnsw.NewGraphWithConfig[uint64](
                config.HNSWM,
                0.5, // Default Ml value (layer size ratio)
                config.HNSWEfSearch,
                distanceFunc,
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create HNSW graph: %w", err)
        }</span>

        // Open DuckDB connection
        <span class="cov0" title="0">duckdb, err := NewDuckDB(WithPath(config.StoragePath))
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to open DuckDB: %w", err)
        }</span>

        // Open a connection to the database
        <span class="cov0" title="0">dbConn, err := duckdb.OpenConnection()
        if err != nil </span><span class="cov0" title="0">{
                duckdb.Close()
                return nil, fmt.Errorf("failed to open DuckDB connection: %w", err)
        }</span>

        // Create metadata table if it doesn't exist.
        <span class="cov0" title="0">_, err = dbConn.Exec(context.Background(), `CREATE TABLE IF NOT EXISTS metadata (
                id BIGINT PRIMARY KEY,
                json VARCHAR
        )`)
        if err != nil </span><span class="cov0" title="0">{
                dbConn.Close()
                duckdb.Close()
                return nil, fmt.Errorf("failed to create metadata table: %w", err)
        }</span>

        // Load metadata from the database.
        <span class="cov0" title="0">rr, stmt, _, err := dbConn.Query(context.Background(), "SELECT id, json FROM metadata")
        if err != nil </span><span class="cov0" title="0">{
                dbConn.Close()
                duckdb.Close()
                return nil, fmt.Errorf("failed to query metadata: %w", err)
        }</span>
        <span class="cov0" title="0">defer stmt.Close()

        metadata := make(map[uint64]map[string]interface{})
        vectors := make(map[uint64][]float32)

        // Process the query results
        for rr.Next() </span><span class="cov0" title="0">{
                record := rr.Record()
                idCol := record.Column(0).(*array.Uint64)
                jsonCol := record.Column(1).(*array.String)

                for i := 0; i &lt; int(record.NumRows()); i++ </span><span class="cov0" title="0">{
                        id := idCol.Value(i)
                        jsonStr := jsonCol.Value(i)

                        var meta map[string]interface{}
                        if err := sonic.Unmarshal([]byte(jsonStr), &amp;meta); err != nil </span><span class="cov0" title="0">{
                                logger.Warn("failed to unmarshal metadata, storing raw JSON", zap.Uint64("id", id), zap.Error(err))
                                meta = map[string]interface{}{"metadata": jsonStr}
                        }</span>

                        <span class="cov0" title="0">metadata[id] = meta</span>
                }
        }

        <span class="cov0" title="0">if err := rr.Err(); err != nil </span><span class="cov0" title="0">{
                dbConn.Close()
                duckdb.Close()
                return nil, fmt.Errorf("error iterating metadata rows: %w", err)
        }</span>

        // Set persist interval.
        <span class="cov0" title="0">persistInterval := 5 * time.Minute
        if config.PersistInterval &gt; 0 </span><span class="cov0" title="0">{
                persistInterval = config.PersistInterval
        }</span>

        <span class="cov0" title="0">idx := &amp;Index{
                config:            config,
                hnsw:              graph,
                metadata:          metadata,
                vectors:           vectors,
                duckdb:            duckdb,
                dbConn:            dbConn,
                batchBuffer:       make([]vectorMeta, 0, config.BatchSize),
                logger:            logger,
                batchTicker:       time.NewTicker(time.Second),
                batchDone:         make(chan struct{}),
                persistInterval:   persistInterval,
                persistTicker:     time.NewTicker(persistInterval),
                persistDone:       make(chan struct{}),
                backupTicker:      time.NewTicker(config.BackupInterval),
                backupDone:        make(chan struct{}),
                originalDimension: originalDimension,
                allocator:         memory.NewGoAllocator(),
                flushSemaphore:    make(chan struct{}, 1),
        }

        // Restart background workers.
        idx.bgWG.Add(1)
        go func() </span><span class="cov0" title="0">{
                defer idx.bgWG.Done()
                idx.batchProcessor()
        }</span>()

        <span class="cov0" title="0">idx.bgWG.Add(1)
        go func() </span><span class="cov0" title="0">{
                defer idx.bgWG.Done()
                idx.persistenceWorker()
        }</span>()

        <span class="cov0" title="0">idx.bgWG.Add(1)
        go func() </span><span class="cov0" title="0">{
                defer idx.bgWG.Done()
                idx.backupWorker()
        }</span>()

        <span class="cov0" title="0">logger.Info("index loaded successfully", zap.String("path", storageDir))
        return idx, nil</span>
}

// persistenceWorker runs in the background and periodically persists new vectors.
func (idx *Index) persistenceWorker() <span class="cov4" title="12">{
        for </span><span class="cov4" title="12">{
                select </span>{
                case &lt;-idx.persistTicker.C:<span class="cov0" title="0">
                        if err := idx.persistToStorage(); err != nil </span><span class="cov0" title="0">{
                                idx.logger.Error("failed to persist index", zap.Error(err))
                        }</span>
                case &lt;-idx.persistDone:<span class="cov3" title="7">
                        idx.logger.Info("persistence worker shutting down")
                        return</span>
                }
        }
}

// persistToStorage persists new vectors by flushing pending batches and saving the HNSW index.
// The new index file is first written to a temporary file and then renamed atomically.
func (idx *Index) persistToStorage() error <span class="cov0" title="0">{
        idx.lock.Lock()
        defer idx.lock.Unlock()

        if err := idx.flushBatch(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Get new IDs since last persist (for logging or incremental processing).
        <span class="cov0" title="0">newIDs := idx.getIDsSinceLastPersist()

        // Save to a temporary file first
        indexFile := filepath.Join(idx.config.StoragePath, "index.hnsw")
        tmpIndexFile := indexFile + ".tmp"

        // Create a file to write to
        file, err := os.Create(tmpIndexFile)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create temporary index file: %w", err)
        }</span>
        <span class="cov0" title="0">defer file.Close()

        // Export the HNSW graph to the file
        if err := idx.hnsw.Export(file); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to export HNSW graph: %w", err)
        }</span>

        // If encryption is enabled, read the file, encrypt it, and write it back
        <span class="cov0" title="0">if idx.config.EncryptionEnabled </span><span class="cov0" title="0">{
                // Read the saved file
                data, err := os.ReadFile(tmpIndexFile)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to read temporary index file: %w", err)
                }</span>

                // Write encrypted data
                <span class="cov0" title="0">if err := idx.writeEncrypted(data, tmpIndexFile+".enc"); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to encrypt index file: %w", err)
                }</span>

                // Remove the unencrypted temp file
                <span class="cov0" title="0">if err := os.Remove(tmpIndexFile); err != nil </span><span class="cov0" title="0">{
                        idx.logger.Warn("failed to remove temporary unencrypted file", zap.Error(err))
                }</span>

                // Rename the encrypted file to the temp file
                <span class="cov0" title="0">if err := os.Rename(tmpIndexFile+".enc", tmpIndexFile); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to rename encrypted index file: %w", err)
                }</span>
        }

        // Atomically replace the old index file with the new one
        <span class="cov0" title="0">if err := os.Rename(tmpIndexFile, indexFile); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to rename index file: %w", err)
        }</span>

        // Update the last persisted ID
        <span class="cov0" title="0">if len(newIDs) &gt; 0 </span><span class="cov0" title="0">{
                maxID := uint64(0)
                for _, id := range newIDs </span><span class="cov0" title="0">{
                        if id &gt; maxID </span><span class="cov0" title="0">{
                                maxID = id
                        }</span>
                }
                <span class="cov0" title="0">idx.lastPersistID = maxID</span>
        }

        <span class="cov0" title="0">idx.logger.Info("index persisted successfully",
                zap.Int("new_vectors", len(newIDs)),
                zap.String("path", indexFile))
        return nil</span>
}

// getIDsSinceLastPersist retrieves IDs added since the last persist.
func (idx *Index) getIDsSinceLastPersist() []uint64 <span class="cov0" title="0">{
        var newIDs []uint64
        for id := range idx.metadata </span><span class="cov0" title="0">{
                if id &gt; idx.lastPersistID </span><span class="cov0" title="0">{
                        newIDs = append(newIDs, id)
                }</span>
        }
        <span class="cov0" title="0">return newIDs</span>
}

// Backup creates a backup of the current index and metadata to the specified directory.
// If incremental is true, only changes since the last backup are included.
func (idx *Index) Backup(path string, incremental bool, compress bool) error <span class="cov1" title="1">{
        idx.lock.RLock()
        defer idx.lock.RUnlock()

        // Ensure backup directory exists.
        if err := os.MkdirAll(path, 0755); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create backup directory: %w", err)
        }</span>

        // Flush pending batches before backup
        <span class="cov1" title="1">if err := idx.flushBatch(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to flush batch before backup: %w", err)
        }</span>

        // Export HNSW graph directly using the Export method
        <span class="cov1" title="1">indexFile := filepath.Join(path, "index.hnsw")
        var indexBuffer bytes.Buffer

        // Use the Export method to write the graph to our buffer
        if err := idx.hnsw.Export(&amp;indexBuffer); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to export HNSW graph: %w", err)
        }</span>

        // Calculate checksum for verification
        <span class="cov1" title="1">indexData := indexBuffer.Bytes()
        checksum := sha256.Sum256(indexData)

        // Handle compression if requested
        if compress </span><span class="cov0" title="0">{
                indexFile += ".gz"
                var compressedData bytes.Buffer
                gzWriter := gzip.NewWriter(&amp;compressedData)
                if _, err := gzWriter.Write(indexData); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to compress index file: %w", err)
                }</span>
                <span class="cov0" title="0">if err := gzWriter.Close(); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to finalize compression: %w", err)
                }</span>
                <span class="cov0" title="0">indexData = compressedData.Bytes()</span>
        }

        // Write to backup location
        <span class="cov1" title="1">if err := os.WriteFile(indexFile, indexData, 0644); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write backup index file: %w", err)
        }</span>

        // Export vectors for complete backup
        <span class="cov1" title="1">vectorsFile := filepath.Join(path, "vectors.json")
        if err := idx.exportVectors(vectorsFile, compress); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to export vectors: %w", err)
        }</span>

        // Export metadata
        <span class="cov1" title="1">metadataFile := filepath.Join(path, "metadata.json")
        if err := idx.exportMetadata(metadataFile, compress); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to export metadata: %w", err)
        }</span>

        // Create backup manifest with integrity verification info
        <span class="cov1" title="1">manifest := map[string]interface{}{
                "timestamp":      time.Now().Format(time.RFC3339),
                "index_checksum": hex.EncodeToString(checksum[:]),
                "compressed":     compress,
                "incremental":    incremental,
                "vector_count":   idx.hnsw.Len(),
                "metadata_count": len(idx.metadata),
                "format_version": "1.0",
                "quiver_version": "1.0.0", // This should be dynamic in the future
                "config":         idx.config,
                "index_path":     "index.hnsw",
                "metadata_path":  "metadata.json",
                "vectors_path":   "vectors.json",
        }

        // Create a manifest file with backup metadata
        manifestData, err := sonic.MarshalIndent(manifest, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal manifest: %w", err)
        }</span>

        // Write manifest to both manifest.json (for backward compatibility) and backup.json (for restore)
        <span class="cov1" title="1">manifestFile := filepath.Join(path, "manifest.json")
        if err := os.WriteFile(manifestFile, manifestData, 0644); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write manifest: %w", err)
        }</span>

        <span class="cov1" title="1">backupFile := filepath.Join(path, "backup.json")
        if err := os.WriteFile(backupFile, manifestData, 0644); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write backup.json: %w", err)
        }</span>

        <span class="cov1" title="1">idx.logger.Info("backup completed successfully",
                zap.String("path", path),
                zap.Bool("incremental", incremental),
                zap.Bool("compressed", compress),
                zap.String("checksum", hex.EncodeToString(checksum[:])))
        return nil</span>
}

// exportVectors exports the vectors to a JSON file
func (idx *Index) exportVectors(filePath string, compress bool) error <span class="cov1" title="1">{
        // Create a slice to hold all vectors
        type vectorEntry struct {
                ID     uint64    `json:"id"`
                Vector []float32 `json:"vector"`
        }

        vectorsArray := make([]vectorEntry, 0, len(idx.vectors))

        // Add all vectors to the array
        for id, vector := range idx.vectors </span><span class="cov5" title="20">{
                vectorsArray = append(vectorsArray, vectorEntry{
                        ID:     id,
                        Vector: vector,
                })
        }</span>

        // Marshal to JSON
        <span class="cov1" title="1">jsonData, err := sonic.MarshalIndent(vectorsArray, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal vectors: %w", err)
        }</span>

        // Handle compression if requested
        <span class="cov1" title="1">if compress </span><span class="cov0" title="0">{
                filePath += ".gz"
                var compressedData bytes.Buffer
                gzWriter := gzip.NewWriter(&amp;compressedData)
                if _, err := gzWriter.Write(jsonData); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to compress vectors: %w", err)
                }</span>
                <span class="cov0" title="0">if err := gzWriter.Close(); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to finalize compression: %w", err)
                }</span>
                <span class="cov0" title="0">jsonData = compressedData.Bytes()</span>
        }

        // Write to file
        <span class="cov1" title="1">if err := os.WriteFile(filePath, jsonData, 0644); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write vectors file: %w", err)
        }</span>

        <span class="cov1" title="1">return nil</span>
}

// importVectors imports vectors from a JSON file
func (idx *Index) importVectors(filePath string, compressed bool) error <span class="cov1" title="1">{
        // Read the file
        var jsonData []byte
        var err error

        if compressed </span><span class="cov0" title="0">{
                // Read compressed file
                file, err := os.Open(filePath)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to open compressed vectors file: %w", err)
                }</span>
                <span class="cov0" title="0">defer file.Close()

                gzReader, err := gzip.NewReader(file)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to create gzip reader: %w", err)
                }</span>
                <span class="cov0" title="0">defer gzReader.Close()

                jsonData, err = io.ReadAll(gzReader)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to read compressed vectors file: %w", err)
                }</span>
        } else<span class="cov1" title="1"> {
                // Read uncompressed file
                jsonData, err = os.ReadFile(filePath)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to read vectors file: %w", err)
                }</span>
        }

        // Parse vectors
        <span class="cov1" title="1">type vectorEntry struct {
                ID     uint64    `json:"id"`
                Vector []float32 `json:"vector"`
        }

        var vectorsArray []vectorEntry
        if err := sonic.Unmarshal(jsonData, &amp;vectorsArray); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to unmarshal vectors: %w", err)
        }</span>

        // Clear existing vectors
        <span class="cov1" title="1">idx.vectors = make(map[uint64][]float32, len(vectorsArray))

        // Add vectors to the map
        for _, entry := range vectorsArray </span><span class="cov5" title="20">{
                // Make a copy of the vector to ensure it's not shared
                vector := make([]float32, len(entry.Vector))
                copy(vector, entry.Vector)
                idx.vectors[entry.ID] = vector
        }</span>

        <span class="cov1" title="1">return nil</span>
}

// Restore restores the index from a backup file.
func (idx *Index) Restore(backupPath string) error <span class="cov1" title="1">{
        idx.lock.Lock()
        defer idx.lock.Unlock()

        // Extract backup to a temporary directory
        tempDir, err := os.MkdirTemp("", "quiver-restore-*")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create temp directory: %w", err)
        }</span>
        <span class="cov1" title="1">defer os.RemoveAll(tempDir)

        // Check if the backup is compressed
        isCompressed := strings.HasSuffix(backupPath, ".gz") || strings.HasSuffix(backupPath, ".zip")

        // Extract the backup
        if isCompressed </span><span class="cov0" title="0">{
                if err := extractCompressedBackup(backupPath, tempDir); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to extract backup: %w", err)
                }</span>
        } else<span class="cov1" title="1"> {
                // If backupPath is a directory, copy all files from it
                fileInfo, err := os.Stat(backupPath)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to stat backup path: %w", err)
                }</span>

                <span class="cov1" title="1">if fileInfo.IsDir() </span><span class="cov1" title="1">{
                        // Copy all files from the backup directory to the temp directory
                        entries, err := os.ReadDir(backupPath)
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to read backup directory: %w", err)
                        }</span>

                        <span class="cov1" title="1">for _, entry := range entries </span><span class="cov3" title="5">{
                                srcPath := filepath.Join(backupPath, entry.Name())
                                dstPath := filepath.Join(tempDir, entry.Name())
                                if err := copyFile(srcPath, dstPath); err != nil </span><span class="cov0" title="0">{
                                        return fmt.Errorf("failed to copy file %s: %w", entry.Name(), err)
                                }</span>
                        }
                } else<span class="cov0" title="0"> {
                        // Just copy the backup file
                        if err := copyFile(backupPath, filepath.Join(tempDir, "backup.json")); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to copy backup file: %w", err)
                        }</span>
                }
        }

        // Read backup metadata
        <span class="cov1" title="1">metaFile := filepath.Join(tempDir, "backup.json")
        metaData, err := os.ReadFile(metaFile)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to read backup metadata: %w", err)
        }</span>

        <span class="cov1" title="1">var backupInfo map[string]interface{}
        if err := sonic.Unmarshal(metaData, &amp;backupInfo); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to unmarshal backup metadata: %w", err)
        }</span>

        // Check backup format version
        <span class="cov1" title="1">version, ok := backupInfo["format_version"].(string)
        if !ok || version != "1.0" </span><span class="cov0" title="0">{
                return fmt.Errorf("unsupported backup format version: %v", version)
        }</span>

        // Get paths to index and metadata files
        <span class="cov1" title="1">indexPath, ok := backupInfo["index_path"].(string)
        if !ok </span><span class="cov0" title="0">{
                return errors.New("backup metadata missing index_path")
        }</span>
        <span class="cov1" title="1">metadataPath, ok := backupInfo["metadata_path"].(string)
        if !ok </span><span class="cov0" title="0">{
                return errors.New("backup metadata missing metadata_path")
        }</span>
        <span class="cov1" title="1">vectorsPath, ok := backupInfo["vectors_path"].(string) // Optional for backward compatibility
        if !ok </span><span class="cov0" title="0">{
                vectorsPath = "vectors.json" // Default path if not specified
        }</span>

        // Check if the index file is compressed
        <span class="cov1" title="1">indexFilePath := filepath.Join(tempDir, indexPath)
        compress, _ := backupInfo["compressed"].(bool)
        if compress </span><span class="cov0" title="0">{
                indexFilePath += ".gz"
        }</span>

        // Verify the index file exists
        <span class="cov1" title="1">if _, err := os.Stat(indexFilePath); os.IsNotExist(err) </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to read index file: %w", err)
        }</span>

        // Read the index file
        <span class="cov1" title="1">var indexData []byte
        if strings.HasSuffix(indexFilePath, ".gz") </span><span class="cov0" title="0">{
                // Decompress the index file
                file, err := os.Open(indexFilePath)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to open compressed index file: %w", err)
                }</span>
                <span class="cov0" title="0">defer file.Close()

                gzReader, err := gzip.NewReader(file)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to create gzip reader: %w", err)
                }</span>
                <span class="cov0" title="0">defer gzReader.Close()

                indexData, err = io.ReadAll(gzReader)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to read compressed index file: %w", err)
                }</span>
        } else<span class="cov1" title="1"> {
                // Read uncompressed index file
                indexData, err = os.ReadFile(indexFilePath)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to read index file: %w", err)
                }</span>
        }

        // Create a new graph
        <span class="cov1" title="1">newGraph := hnsw.NewGraph[uint64]()

        // Import the graph data using the Import method
        if err := newGraph.Import(bytes.NewReader(indexData)); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to import HNSW graph: %w", err)
        }</span>

        // Update the index with the restored HNSW
        <span class="cov1" title="1">idx.hnsw = newGraph

        // Import metadata
        metadataFilePath := filepath.Join(tempDir, metadataPath)
        if compress &amp;&amp; !strings.HasSuffix(metadataFilePath, ".gz") </span><span class="cov0" title="0">{
                metadataFilePath += ".gz"
        }</span>

        // Verify the metadata file exists
        <span class="cov1" title="1">if _, err := os.Stat(metadataFilePath); os.IsNotExist(err) </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to read metadata file: %w", err)
        }</span>

        <span class="cov1" title="1">if err := idx.importMetadata(metadataFilePath, strings.HasSuffix(metadataFilePath, ".gz")); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to import metadata: %w", err)
        }</span>

        // Import vectors if available
        <span class="cov1" title="1">vectorsFilePath := filepath.Join(tempDir, vectorsPath)
        if compress &amp;&amp; !strings.HasSuffix(vectorsFilePath, ".gz") </span><span class="cov0" title="0">{
                vectorsFilePath += ".gz"
        }</span>

        // Verify the vectors file exists
        <span class="cov1" title="1">if _, err := os.Stat(vectorsFilePath); os.IsNotExist(err) </span><span class="cov0" title="0">{
                idx.logger.Warn("vectors file not found, creating empty vectors", zap.String("path", vectorsFilePath))
                idx.vectors = make(map[uint64][]float32)
                for id := range idx.metadata </span><span class="cov0" title="0">{
                        idx.vectors[id] = make([]float32, idx.config.Dimension)
                }</span>
        } else<span class="cov1" title="1"> {
                if err := idx.importVectors(vectorsFilePath, strings.HasSuffix(vectorsFilePath, ".gz")); err != nil </span><span class="cov0" title="0">{
                        // If vectors file is not available, create empty vectors
                        idx.logger.Warn("failed to import vectors, creating empty vectors", zap.Error(err))
                        idx.vectors = make(map[uint64][]float32)
                        for id := range idx.metadata </span><span class="cov0" title="0">{
                                idx.vectors[id] = make([]float32, idx.config.Dimension)
                        }</span>
                }
        }

        <span class="cov1" title="1">idx.logger.Info("index restored successfully",
                zap.String("backup_path", backupPath),
                zap.String("storage_path", idx.config.StoragePath),
                zap.Int("vector_count", idx.hnsw.Len()),
                zap.Int("metadata_count", len(idx.metadata)),
                zap.Int("vectors_count", len(idx.vectors)))
        return nil</span>
}

// writeEncrypted writes data to a file with optional encryption
func (idx *Index) writeEncrypted(data []byte, filePath string) error <span class="cov1" title="1">{
        if !idx.config.EncryptionEnabled </span><span class="cov1" title="1">{
                return os.WriteFile(filePath, data, 0644)
        }</span>

        // Validate encryption key
        <span class="cov0" title="0">if len(idx.config.EncryptionKey) &lt; 32 </span><span class="cov0" title="0">{
                return fmt.Errorf("encryption key must be at least 32 bytes long")
        }</span>

        // Create a 32-byte key from the provided key
        <span class="cov0" title="0">key := []byte(idx.config.EncryptionKey)
        if len(key) &gt; 32 </span><span class="cov0" title="0">{
                key = key[:32]
        }</span>

        // Create a new AES cipher block
        <span class="cov0" title="0">block, err := aes.NewCipher(key)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create cipher: %w", err)
        }</span>

        // Generate a random nonce
        <span class="cov0" title="0">nonce := make([]byte, 12)
        if _, err := io.ReadFull(rand.Reader, nonce); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to generate nonce: %w", err)
        }</span>

        // Create the GCM cipher
        <span class="cov0" title="0">aesgcm, err := cipher.NewGCM(block)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create GCM cipher: %w", err)
        }</span>

        // Encrypt the data
        <span class="cov0" title="0">encryptedData := aesgcm.Seal(nil, nonce, data, nil)

        // Create the final data: nonce + encrypted data
        finalData := make([]byte, len(nonce)+len(encryptedData))
        copy(finalData[:len(nonce)], nonce)
        copy(finalData[len(nonce):], encryptedData)

        // Write the encrypted data
        return os.WriteFile(filePath, finalData, 0644)</span>
}

// readEncrypted reads data from a file with optional decryption
func (idx *Index) readEncrypted(filePath string) ([]byte, error) <span class="cov1" title="1">{
        // Read the file
        data, err := os.ReadFile(filePath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read file: %w", err)
        }</span>

        // If encryption is not enabled, return the raw data
        <span class="cov1" title="1">if !idx.config.EncryptionEnabled </span><span class="cov1" title="1">{
                return data, nil
        }</span>

        // Validate encryption key
        <span class="cov0" title="0">if len(idx.config.EncryptionKey) &lt; 32 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("encryption key must be at least 32 bytes long")
        }</span>

        // Create a 32-byte key from the provided key
        <span class="cov0" title="0">key := []byte(idx.config.EncryptionKey)
        if len(key) &gt; 32 </span><span class="cov0" title="0">{
                key = key[:32]
        }</span>

        // The nonce is the first 12 bytes
        <span class="cov0" title="0">if len(data) &lt; 12 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("encrypted data is too short")
        }</span>
        <span class="cov0" title="0">nonce := data[:12]
        encryptedData := data[12:]

        // Create the cipher block
        block, err := aes.NewCipher(key)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create cipher: %w", err)
        }</span>

        // Create the GCM cipher
        <span class="cov0" title="0">aesgcm, err := cipher.NewGCM(block)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create GCM cipher: %w", err)
        }</span>

        // Decrypt the data
        <span class="cov0" title="0">decryptedData, err := aesgcm.Open(nil, nonce, encryptedData, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to decrypt data: %w", err)
        }</span>

        <span class="cov0" title="0">return decryptedData, nil</span>
}

// exportMetadata exports the metadata to a JSON file with optional encryption
func (idx *Index) exportMetadata(filePath string, compress bool) error <span class="cov1" title="1">{
        // Convert metadata map to an array for serialization
        metadataArray := make([]map[string]interface{}, 0, len(idx.metadata))
        for id, meta := range idx.metadata </span><span class="cov5" title="20">{
                // Add ID to metadata for restoration
                itemMeta := make(map[string]interface{})
                for k, v := range meta </span><span class="cov7" title="60">{
                        itemMeta[k] = v
                }</span>
                <span class="cov5" title="20">itemMeta["_id"] = id
                metadataArray = append(metadataArray, itemMeta)</span>
        }

        // Marshal metadata to JSON
        <span class="cov1" title="1">jsonData, err := sonic.MarshalIndent(metadataArray, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal metadata: %w", err)
        }</span>

        <span class="cov1" title="1">var finalData []byte
        finalPath := filePath

        // Apply compression if requested
        if compress </span><span class="cov0" title="0">{
                finalPath += ".gz"
                var compressedData bytes.Buffer
                gzWriter := gzip.NewWriter(&amp;compressedData)
                if _, err := gzWriter.Write(jsonData); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to compress metadata: %w", err)
                }</span>
                <span class="cov0" title="0">if err := gzWriter.Close(); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to finalize metadata compression: %w", err)
                }</span>
                <span class="cov0" title="0">finalData = compressedData.Bytes()</span>
        } else<span class="cov1" title="1"> {
                finalData = jsonData
        }</span>

        // Write data with optional encryption
        <span class="cov1" title="1">if err := idx.writeEncrypted(finalData, finalPath); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write metadata file: %w", err)
        }</span>

        <span class="cov1" title="1">return nil</span>
}

// importMetadata imports metadata from a JSON file with optional decryption
func (idx *Index) importMetadata(filePath string, compressed bool) error <span class="cov1" title="1">{
        // Read and decrypt file
        fileData, err := idx.readEncrypted(filePath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to read metadata file: %w", err)
        }</span>

        // Decompress if needed
        <span class="cov1" title="1">var jsonData []byte
        if compressed </span><span class="cov0" title="0">{
                gzReader, err := gzip.NewReader(bytes.NewReader(fileData))
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to create gzip reader for metadata: %w", err)
                }</span>
                <span class="cov0" title="0">jsonData, err = io.ReadAll(gzReader)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to decompress metadata: %w", err)
                }</span>
                <span class="cov0" title="0">if err := gzReader.Close(); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to close gzip reader: %w", err)
                }</span>
        } else<span class="cov1" title="1"> {
                jsonData = fileData
        }</span>

        // Parse metadata
        <span class="cov1" title="1">var metadataArray []map[string]interface{}
        if err := sonic.Unmarshal(jsonData, &amp;metadataArray); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to unmarshal metadata: %w", err)
        }</span>

        // Rebuild metadata map
        <span class="cov1" title="1">idx.metadata = make(map[uint64]map[string]interface{})
        for _, item := range metadataArray </span><span class="cov5" title="20">{
                id, ok := item["_id"].(float64)
                if !ok </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov5" title="20">delete(item, "_id")

                // Convert float64 values back to int when appropriate
                for k, v := range item </span><span class="cov7" title="60">{
                        if floatVal, ok := v.(float64); ok &amp;&amp; floatVal == float64(int(floatVal)) </span><span class="cov5" title="20">{
                                item[k] = int(floatVal)
                        }</span>
                }

                <span class="cov5" title="20">idx.metadata[uint64(id)] = item</span>
        }

        <span class="cov1" title="1">return nil</span>
}

// Close releases resources associated with the index and stops background workers.
func (idx *Index) Close() error <span class="cov3" title="7">{
        // Stop background workers.
        idx.batchTicker.Stop()
        close(idx.batchDone)
        idx.persistTicker.Stop()
        close(idx.persistDone)
        idx.backupTicker.Stop()
        close(idx.backupDone)
        // Wait for background goroutines to exit.
        idx.bgWG.Wait()

        if err := idx.flushBatch(); err != nil </span><span class="cov0" title="0">{
                idx.logger.Error("failed to flush batch during close", zap.Error(err))
        }</span>

        // Close DuckDB connection and database
        <span class="cov3" title="7">if idx.dbConn != nil </span><span class="cov3" title="7">{
                idx.dbConn.Close()
        }</span>
        <span class="cov3" title="7">if idx.duckdb != nil </span><span class="cov3" title="7">{
                idx.duckdb.Close()
        }</span>

        <span class="cov3" title="7">idx.logger.Info("index closed successfully")
        return nil</span>
}

// QueryMetadata executes a metadata query against DuckDB and returns the matching metadata.
func (idx *Index) QueryMetadata(query string) ([]map[string]interface{}, error) <span class="cov4" title="8">{
        rr, stmt, _, err := idx.dbConn.Query(context.Background(), query)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("metadata query failed: %w", err)
        }</span>
        <span class="cov4" title="8">defer stmt.Close()

        var results []map[string]interface{}

        // Process the query results
        for rr.Next() </span><span class="cov3" title="6">{
                record := rr.Record()
                numCols := int(record.NumCols())
                numRows := int(record.NumRows())

                // Get column names from schema
                schema := record.Schema()
                colNames := make([]string, numCols)
                for i := 0; i &lt; numCols; i++ </span><span class="cov4" title="12">{
                        colNames[i] = schema.Field(i).Name
                }</span>

                // Process each row
                <span class="cov3" title="6">for rowIdx := 0; rowIdx &lt; numRows; rowIdx++ </span><span class="cov4" title="10">{
                        result := make(map[string]interface{})

                        // Extract values for each column
                        for colIdx := 0; colIdx &lt; numCols; colIdx++ </span><span class="cov5" title="20">{
                                col := record.Column(colIdx)

                                // Check if the value is null
                                isNull := false
                                switch c := col.(type) </span>{
                                case *array.String:<span class="cov4" title="10">
                                        isNull = c.IsNull(rowIdx)</span>
                                case *array.Int64:<span class="cov4" title="10">
                                        isNull = c.IsNull(rowIdx)</span>
                                case *array.Uint64:<span class="cov0" title="0">
                                        isNull = c.IsNull(rowIdx)</span>
                                case *array.Float64:<span class="cov0" title="0">
                                        isNull = c.IsNull(rowIdx)</span>
                                case *array.Boolean:<span class="cov0" title="0">
                                        isNull = c.IsNull(rowIdx)</span>
                                default:<span class="cov0" title="0">
                                        // For other types, assume not null
                                        isNull = false</span>
                                }

                                <span class="cov5" title="20">if !isNull </span><span class="cov5" title="20">{
                                        // Extract value based on column type
                                        switch col := col.(type) </span>{
                                        case *array.String:<span class="cov4" title="10">
                                                result[colNames[colIdx]] = col.Value(rowIdx)</span>
                                        case *array.Int64:<span class="cov4" title="10">
                                                result[colNames[colIdx]] = col.Value(rowIdx)</span>
                                        case *array.Uint64:<span class="cov0" title="0">
                                                result[colNames[colIdx]] = col.Value(rowIdx)</span>
                                        case *array.Float64:<span class="cov0" title="0">
                                                result[colNames[colIdx]] = col.Value(rowIdx)</span>
                                        case *array.Boolean:<span class="cov0" title="0">
                                                result[colNames[colIdx]] = col.Value(rowIdx)</span>
                                        default:<span class="cov0" title="0">
                                                // For other types, convert to string
                                                result[colNames[colIdx]] = fmt.Sprintf("%v", col)</span>
                                        }
                                }
                        }

                        <span class="cov4" title="10">results = append(results, result)</span>
                }
        }

        <span class="cov4" title="8">if err := rr.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error iterating query results: %w", err)
        }</span>

        <span class="cov4" title="8">return results, nil</span>
}

// validateMetadataSchema performs basic schema validation on the metadata.
func validateMetadataSchema(meta map[string]interface{}) error <span class="cov2" title="2">{
        // Example: require the "category" field.
        if _, ok := meta["category"]; !ok </span><span class="cov0" title="0">{
                return errors.New("missing required field: category")
        }</span>
        <span class="cov2" title="2">return nil</span>
}

// HealthCheck performs a simple health check on the index.
func (idx *Index) HealthCheck() error <span class="cov1" title="1">{
        if idx.hnsw == nil || idx.dbConn == nil </span><span class="cov0" title="0">{
                return errors.New("index or database not initialized")
        }</span>
        <span class="cov1" title="1">return nil</span>
}

// CollectMetrics returns a map of metrics about the index.
func (idx *Index) CollectMetrics() map[string]interface{} <span class="cov1" title="1">{
        metrics := make(map[string]interface{})
        metrics["vector_count"] = idx.hnsw.Len()
        metrics["batch_size"] = len(idx.batchBuffer)
        metrics["cache_size"] = idx.cacheSize()
        metrics["db_connections"] = idx.duckdb.ConnCount()
        metrics["last_persist_id"] = idx.lastPersistID
        metrics["persist_interval"] = idx.persistInterval.Seconds()

        // Add backup metrics
        if !idx.lastBackupTime.IsZero() </span><span class="cov0" title="0">{
                metrics["last_backup_time"] = idx.lastBackupTime.Format(time.RFC3339)
                metrics["backup_age_seconds"] = time.Since(idx.lastBackupTime).Seconds()
        }</span>

        <span class="cov1" title="1">return metrics</span>
}

// cacheSize returns the number of items in the cache.
func (idx *Index) cacheSize() int <span class="cov1" title="1">{
        size := 0
        idx.cache.Range(func(_, _ interface{}) bool </span><span class="cov1" title="1">{
                size++
                return true
        }</span>)
        <span class="cov1" title="1">return size</span>
}

// LogQuery logs the executed query along with its duration.
func (idx *Index) LogQuery(query string, duration time.Duration) <span class="cov0" title="0">{
        idx.logger.Info("query executed", zap.String("query", query), zap.Duration("duration", duration))
}</span>

// FacetedSearch performs a search and filters results based on provided facet key/values.
func (idx *Index) FacetedSearch(query []float32, k int, facets map[string]string) ([]SearchResult, error) <span class="cov1" title="1">{

        results, err := idx.Search(query, k, 1, k)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">var filteredResults []SearchResult
        for _, res := range results </span><span class="cov1" title="1">{
                match := true
                for key, value := range facets </span><span class="cov1" title="1">{
                        if metaValue, ok := res.Metadata[key]; !ok || metaValue != value </span><span class="cov0" title="0">{
                                match = false
                                break</span>
                        }
                }
                <span class="cov1" title="1">if match </span><span class="cov1" title="1">{
                        filteredResults = append(filteredResults, res)
                }</span>
        }
        <span class="cov1" title="1">return filteredResults, nil</span>
}

// MultiVectorSearch performs searches for multiple query vectors.
func (idx *Index) MultiVectorSearch(queries [][]float32, k int) ([][]SearchResult, error) <span class="cov2" title="2">{
        if len(queries) == 0 </span><span class="cov0" title="0">{
                return nil, errors.New("no query vectors provided")
        }</span>

        // Validate dimensions for all queries
        <span class="cov2" title="2">for i, query := range queries </span><span class="cov3" title="6">{
                if !idx.config.EnableDimReduction || idx.dimReducer == nil </span><span class="cov3" title="6">{
                        if len(query) != idx.config.Dimension </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("query %d dimension (%d) does not match index dimension (%d)",
                                        i, len(query), idx.config.Dimension)
                        }</span>
                } else<span class="cov0" title="0"> {
                        if len(query) != idx.originalDimension </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("query %d dimension (%d) does not match original dimension (%d)",
                                        i, len(query), idx.originalDimension)
                        }</span>
                }
        }

        // For small number of queries, process sequentially
        <span class="cov2" title="2">if len(queries) &lt;= 4 </span><span class="cov1" title="1">{
                return idx.sequentialMultiVectorSearch(queries, k)
        }</span>

        // For larger number of queries, process in parallel
        <span class="cov1" title="1">return idx.parallelMultiVectorSearch(queries, k)</span>
}

// sequentialMultiVectorSearch processes multiple query vectors sequentially.
func (idx *Index) sequentialMultiVectorSearch(queries [][]float32, k int) ([][]SearchResult, error) <span class="cov1" title="1">{
        results := make([][]SearchResult, len(queries))

        for i, query := range queries </span><span class="cov1" title="1">{
                searchResults, err := idx.Search(query, k, 1, k)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("error searching for query %d: %w", i, err)
                }</span>
                <span class="cov1" title="1">results[i] = searchResults</span>
        }

        <span class="cov1" title="1">return results, nil</span>
}

// parallelMultiVectorSearch processes multiple query vectors in parallel.
func (idx *Index) parallelMultiVectorSearch(queries [][]float32, k int) ([][]SearchResult, error) <span class="cov1" title="1">{
        results := make([][]SearchResult, len(queries))
        errChan := make(chan error, len(queries))

        // Use a wait group to synchronize goroutines
        var wg sync.WaitGroup

        // Determine number of workers
        numWorkers := runtime.NumCPU()
        if idx.config.NumSearchWorkers &gt; 0 </span><span class="cov1" title="1">{
                numWorkers = idx.config.NumSearchWorkers
        }</span>

        // Create a semaphore to limit concurrency
        <span class="cov1" title="1">sem := make(chan struct{}, numWorkers)

        // Create a mutex to synchronize access to the HNSW graph
        // This prevents data races when multiple goroutines try to search simultaneously
        var searchMutex sync.Mutex

        for i, query := range queries </span><span class="cov3" title="5">{
                wg.Add(1)

                go func(index int, q []float32) </span><span class="cov3" title="5">{
                        defer wg.Done()

                        // Acquire semaphore
                        sem &lt;- struct{}{}
                        defer func() </span><span class="cov3" title="5">{ &lt;-sem }</span>()

                        // Synchronize access to the Search method
                        <span class="cov3" title="5">searchMutex.Lock()
                        searchResults, err := idx.Search(q, k, 1, k)
                        searchMutex.Unlock()

                        if err != nil </span><span class="cov0" title="0">{
                                errChan &lt;- fmt.Errorf("error searching for query %d: %w", index, err)
                                return
                        }</span>

                        // Store results
                        <span class="cov3" title="5">results[index] = searchResults</span>
                }(i, query)
        }

        // Wait for all searches to complete
        <span class="cov1" title="1">wg.Wait()
        close(errChan)

        // Check for errors
        select </span>{
        case err := &lt;-errChan:<span class="cov1" title="1">
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        default:<span class="cov0" title="0"></span>
                // No errors
        }

        <span class="cov1" title="1">return results, nil</span>
}

// copyFile copies a file from src to dst.
func copyFile(src, dst string) error <span class="cov3" title="5">{
        sourceFile, err := os.Open(src)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov3" title="5">defer sourceFile.Close()

        destinationFile, err := os.Create(dst)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov3" title="5">defer destinationFile.Close()

        if _, err := io.Copy(destinationFile, sourceFile); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov3" title="5">return nil</span>
}

// backupWorker runs in the background and periodically creates backups
func (idx *Index) backupWorker() <span class="cov4" title="12">{
        if idx.config.BackupInterval &lt;= 0 </span><span class="cov4" title="11">{
                // Backup is disabled
                idx.logger.Info("Scheduled backups are disabled")
                return
        }</span>

        <span class="cov1" title="1">idx.logger.Info("Backup worker started",
                zap.Duration("interval", idx.config.BackupInterval),
                zap.String("path", idx.config.BackupPath),
                zap.Bool("compression", idx.config.BackupCompression))

        for </span><span class="cov1" title="1">{
                select </span>{
                case &lt;-idx.backupTicker.C:<span class="cov0" title="0">
                        // Create a timestamped backup directory
                        timestamp := time.Now().Format("20060102-150405")
                        backupDir := filepath.Join(idx.config.BackupPath, timestamp)

                        idx.logger.Info("Starting scheduled backup", zap.String("backup_dir", backupDir))

                        if err := idx.Backup(backupDir, true, idx.config.BackupCompression); err != nil </span><span class="cov0" title="0">{
                                idx.logger.Error("Scheduled backup failed", zap.Error(err))
                        }</span> else<span class="cov0" title="0"> {
                                idx.lastBackupTime = time.Now()
                                idx.pruneOldBackups()
                        }</span>
                case &lt;-idx.backupDone:<span class="cov1" title="1">
                        idx.logger.Info("Backup worker shutting down")
                        return</span>
                }
        }
}

// pruneOldBackups removes old backups to maintain the max number of backups
func (idx *Index) pruneOldBackups() <span class="cov0" title="0">{
        if idx.config.MaxBackups &lt;= 0 </span><span class="cov0" title="0">{
                return // No limit
        }</span>

        // List all backup directories
        <span class="cov0" title="0">entries, err := os.ReadDir(idx.config.BackupPath)
        if err != nil </span><span class="cov0" title="0">{
                idx.logger.Error("Failed to read backup directory", zap.Error(err))
                return
        }</span>

        // Filter and sort backup directories
        <span class="cov0" title="0">var backups []string
        for _, entry := range entries </span><span class="cov0" title="0">{
                if entry.IsDir() </span><span class="cov0" title="0">{
                        // Check if it's a valid backup (has a manifest)
                        manifestPath := filepath.Join(idx.config.BackupPath, entry.Name(), "manifest.json")
                        if _, err := os.Stat(manifestPath); err == nil </span><span class="cov0" title="0">{
                                backups = append(backups, entry.Name())
                        }</span>
                }
        }

        // Sort by name (timestamp format ensures chronological order)
        <span class="cov0" title="0">sort.Strings(backups)

        // Remove oldest backups if we have more than the limit
        if len(backups) &gt; idx.config.MaxBackups </span><span class="cov0" title="0">{
                for i := 0; i &lt; len(backups)-idx.config.MaxBackups; i++ </span><span class="cov0" title="0">{
                        backupToRemove := filepath.Join(idx.config.BackupPath, backups[i])
                        idx.logger.Info("Removing old backup", zap.String("path", backupToRemove))
                        if err := os.RemoveAll(backupToRemove); err != nil </span><span class="cov0" title="0">{
                                idx.logger.Error("Failed to remove old backup",
                                        zap.String("path", backupToRemove),
                                        zap.Error(err))
                        }</span>
                }
        }
}

// SearchWithNegatives performs a search with positive and negative examples.
func (idx *Index) SearchWithNegatives(positiveQuery []float32, negativeQueries [][]float32, k, page, pageSize int) ([]SearchResult, error) <span class="cov2" title="2">{

        idx.lock.RLock()
        defer idx.lock.RUnlock()

        // Validate parameters
        if k &lt;= 0 </span><span class="cov0" title="0">{
                return nil, errors.New("k must be positive")
        }</span>
        <span class="cov2" title="2">if page &lt;= 0 </span><span class="cov0" title="0">{
                page = 1 // Default to first page
        }</span>
        <span class="cov2" title="2">if pageSize &lt;= 0 </span><span class="cov0" title="0">{
                pageSize = 10 // Default page size
        }</span>
        <span class="cov2" title="2">if len(negativeQueries) == 0 </span><span class="cov0" title="0">{
                // If no negative examples, just do a regular search
                return idx.Search(positiveQuery, k, page, pageSize)
        }</span>

        // Ensure we have enough elements in the index
        <span class="cov2" title="2">currentCount := idx.hnsw.Len()
        if currentCount == 0 </span><span class="cov0" title="0">{
                return []SearchResult{}, nil
        }</span>

        // Get more results than needed for reranking
        <span class="cov2" title="2">searchK := k * 10 // Get 10x more results for reranking
        if searchK &gt; currentCount </span><span class="cov2" title="2">{
                searchK = currentCount
        }</span>

        // Perform search for positive query
        <span class="cov2" title="2">var results []hnsw.Node[uint64]
        var err error

        // Use a recovery function to catch exceptions
        func() </span><span class="cov2" title="2">{
                defer func() </span><span class="cov2" title="2">{
                        if r := recover(); r != nil </span><span class="cov0" title="0">{
                                err = fmt.Errorf("HNSW search panicked: %v", r)
                        }</span>
                }()

                // Set efSearch parameter for better recall
                <span class="cov2" title="2">efSearch := idx.config.HNSWEfSearch * 2
                if efSearch &lt; searchK*4 </span><span class="cov0" title="0">{
                        efSearch = searchK * 4
                }</span>

                // Store the original value so we can restore it after the search
                <span class="cov2" title="2">originalEf := idx.hnsw.EfSearch
                idx.hnsw.EfSearch = efSearch
                idx.logger.Debug("Setting efSearch parameter for negative search", zap.Int("efSearch", efSearch))

                // Perform the search
                results, err = idx.hnsw.Search(positiveQuery, searchK)
                if err != nil </span><span class="cov0" title="0">{
                        idx.logger.Error("HNSW search failed", zap.Error(err))
                        return
                }</span>

                // Restore the original efSearch value
                <span class="cov2" title="2">idx.hnsw.EfSearch = originalEf</span>
        }()

        <span class="cov2" title="2">if err != nil </span><span class="cov0" title="0">{
                idx.logger.Error("HNSW search failed", zap.Error(err))
                return nil, fmt.Errorf("HNSW search failed: %w", err)
        }</span>

        <span class="cov2" title="2">if len(results) == 0 </span><span class="cov0" title="0">{
                return []SearchResult{}, nil
        }</span>

        // If no negative examples, just return the results with pagination
        <span class="cov2" title="2">if len(negativeQueries) == 0 </span><span class="cov0" title="0">{
                start := (page - 1) * pageSize
                end := start + pageSize
                if start &gt;= len(results) </span><span class="cov0" title="0">{
                        return nil, nil // No more results
                }</span>
                <span class="cov0" title="0">if end &gt; len(results) </span><span class="cov0" title="0">{
                        end = len(results)
                }</span>

                <span class="cov0" title="0">var searchResults []SearchResult
                for _, r := range results[start:end] </span><span class="cov0" title="0">{
                        // Calculate distance between query and result vector
                        distance := computeDistance(positiveQuery, r.Value, idx.config.Distance)
                        meta := idx.getMetadata(r.Key)
                        searchResults = append(searchResults, SearchResult{
                                ID:       r.Key,
                                Distance: distance,
                                Metadata: meta,
                        })
                }</span>
                <span class="cov0" title="0">return searchResults, nil</span>
        }

        // Rerank results based on negative examples
        <span class="cov2" title="2">candidates := results
        rerankedResults := idx.rerankWithNegatives(candidates, positiveQuery, negativeQueries)

        // Apply pagination to reranked results
        start := (page - 1) * pageSize
        end := start + pageSize
        if start &gt;= len(rerankedResults) </span><span class="cov0" title="0">{
                return nil, nil // No more results
        }</span>
        <span class="cov2" title="2">if end &gt; len(rerankedResults) </span><span class="cov2" title="2">{
                end = len(rerankedResults)
        }</span>

        <span class="cov2" title="2">var searchResults []SearchResult
        for _, r := range rerankedResults[start:end] </span><span class="cov3" title="5">{
                meta := idx.getMetadata(r.ID)
                searchResults = append(searchResults, SearchResult{
                        ID:       r.ID,
                        Distance: r.Distance,
                        Metadata: meta,
                })
        }</span>
        <span class="cov2" title="2">return searchResults, nil</span>
}

// rerankWithNegatives reranks search results based on negative examples
func (idx *Index) rerankWithNegatives(candidates []hnsw.Node[uint64], positiveQuery []float32, negativeQueries [][]float32) []SearchResult <span class="cov2" title="2">{
        // Weights for positive and negative influences
        posWeight := 1.0
        negWeight := 0.5 / float64(len(negativeQueries))

        // Rerank candidates based on both positive and negative examples
        reranked := make([]SearchResult, 0, len(candidates))
        for _, candidate := range candidates </span><span class="cov3" title="5">{
                id := candidate.Key
                vector := candidate.Value
                if vector == nil </span><span class="cov0" title="0">{
                        // If vector is not available, get it from storage
                        vector = idx.getVector(id)
                        if vector == nil </span><span class="cov0" title="0">{
                                continue</span> // Skip if vector not found
                        }
                }

                // Calculate base score from positive query
                <span class="cov3" title="5">posDistance := computeDistance(vector, positiveQuery, idx.config.Distance)

                // Initialize final score based on positive query
                var finalScore float64

                // For distance metrics (like L2), lower means more similar
                if idx.config.Distance == Cosine </span><span class="cov3" title="5">{
                        // For Cosine, higher means more similar
                        finalScore = float64(posDistance) * posWeight
                }</span> else<span class="cov0" title="0"> {
                        // For L2, lower means more similar, so we invert
                        finalScore = posWeight * (1.0 / (1.0 + float64(posDistance)))
                }</span>

                // For each negative query, compute distance and adjust the score
                <span class="cov3" title="5">for _, negQuery := range negativeQueries </span><span class="cov3" title="5">{
                        negDistance := computeDistance(vector, negQuery, idx.config.Distance)

                        // For similarity metrics, higher means more similar
                        // We want to penalize vectors similar to negative examples
                        if idx.config.Distance == Cosine </span><span class="cov3" title="5">{
                                // For Cosine, we penalize by subtracting the similarity
                                finalScore -= negWeight * float64(negDistance)
                        }</span> else<span class="cov0" title="0"> {
                                // For L2, we penalize by adding the inverse of distance
                                // (closer to negative example = higher penalty)
                                finalScore -= negWeight * (1.0 / (1.0 + float64(negDistance)))
                        }</span>
                }

                // Add to reranked results
                <span class="cov3" title="5">reranked = append(reranked, SearchResult{
                        ID:       id,
                        Distance: float32(finalScore), // Store the combined score as distance
                        Metadata: nil,                 // Will be filled in later
                })</span>
        }

        // Sort by final score (higher is better)
        <span class="cov2" title="2">sort.Slice(reranked, func(i, j int) bool </span><span class="cov2" title="3">{
                return reranked[i].Distance &gt; reranked[j].Distance
        }</span>)

        <span class="cov2" title="2">return reranked</span>
}

// getVector retrieves the vector for a given ID
func (idx *Index) getVector(id uint64) []float32 <span class="cov0" title="0">{
        vector, ok := idx.vectors[id]
        if !ok </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Return a copy to avoid external modification
        <span class="cov0" title="0">result := make([]float32, len(vector))
        copy(result, vector)
        return result</span>
}

// computeDistance calculates the distance between two vectors
func computeDistance(a, b []float32, metric DistanceMetric) float32 <span class="cov7" title="67">{
        if len(a) != len(b) </span><span class="cov0" title="0">{
                return 0.0
        }</span>

        <span class="cov7" title="67">switch metric </span>{
        case Cosine:<span class="cov7" title="67">
                return cosineDistance(a, b)</span>
        case L2:<span class="cov0" title="0">
                return l2Distance(a, b)</span>
        default:<span class="cov0" title="0">
                return 0.0</span>
        }
}

// cosineDistance computes cosine similarity between vectors
func cosineDistance(a, b []float32) float32 <span class="cov7" title="67">{
        var dotProduct float32
        var normA, normB float32

        for i := 0; i &lt; len(a); i++ </span><span class="cov8" title="201">{
                dotProduct += a[i] * b[i]
                normA += a[i] * a[i]
                normB += b[i] * b[i]
        }</span>

        <span class="cov7" title="67">return dotProduct / (float32(math.Sqrt(float64(normA))) * float32(math.Sqrt(float64(normB))))</span>
}

// l2Distance computes Euclidean (L2) distance between vectors
func l2Distance(a, b []float32) float32 <span class="cov0" title="0">{
        var sum float32
        for i := 0; i &lt; len(a); i++ </span><span class="cov0" title="0">{
                diff := a[i] - b[i]
                sum += diff * diff
        }</span>
        <span class="cov0" title="0">return float32(math.Sqrt(float64(sum)))</span>
}

// extractCompressedBackup extracts a compressed backup file to the specified directory.
func extractCompressedBackup(backupPath, destDir string) error <span class="cov0" title="0">{
        // Check if it's a gzip file
        if strings.HasSuffix(backupPath, ".gz") </span><span class="cov0" title="0">{
                // Open the gzip file
                file, err := os.Open(backupPath)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to open gzip file: %w", err)
                }</span>
                <span class="cov0" title="0">defer file.Close()

                // Create a gzip reader
                gzReader, err := gzip.NewReader(file)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to create gzip reader: %w", err)
                }</span>
                <span class="cov0" title="0">defer gzReader.Close()

                // Create the output file
                outFile, err := os.Create(filepath.Join(destDir, "backup.json"))
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to create output file: %w", err)
                }</span>
                <span class="cov0" title="0">defer outFile.Close()

                // Copy the decompressed data to the output file
                if _, err := io.Copy(outFile, gzReader); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to decompress data: %w", err)
                }</span>

                <span class="cov0" title="0">return nil</span>
        } else<span class="cov0" title="0"> if strings.HasSuffix(backupPath, ".zip") </span><span class="cov0" title="0">{
                // Open the zip file
                zipReader, err := zip.OpenReader(backupPath)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to open zip file: %w", err)
                }</span>
                <span class="cov0" title="0">defer zipReader.Close()

                // Extract each file
                for _, file := range zipReader.File </span><span class="cov0" title="0">{
                        // Open the file inside the zip
                        rc, err := file.Open()
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to open file in zip: %w", err)
                        }</span>

                        // Create the output file
                        <span class="cov0" title="0">outPath := filepath.Join(destDir, file.Name)
                        outFile, err := os.Create(outPath)
                        if err != nil </span><span class="cov0" title="0">{
                                rc.Close()
                                return fmt.Errorf("failed to create output file: %w", err)
                        }</span>

                        // Copy the file data
                        <span class="cov0" title="0">if _, err := io.Copy(outFile, rc); err != nil </span><span class="cov0" title="0">{
                                outFile.Close()
                                rc.Close()
                                return fmt.Errorf("failed to extract file: %w", err)
                        }</span>

                        <span class="cov0" title="0">outFile.Close()
                        rc.Close()</span>
                }

                <span class="cov0" title="0">return nil</span>
        }

        <span class="cov0" title="0">return fmt.Errorf("unsupported compression format: %s", backupPath)</span>
}

// NewVectorSchema creates an Arrow schema for vector data.
func NewVectorSchema(dimension int) *arrow.Schema <span class="cov1" title="1">{
        return arrow.NewSchema(
                []arrow.Field{
                        {Name: "id", Type: arrow.PrimitiveTypes.Uint64, Nullable: false},
                        {Name: "vector", Type: arrow.FixedSizeListOf(int32(dimension), arrow.PrimitiveTypes.Float32), Nullable: false},
                        {Name: "metadata", Type: arrow.BinaryTypes.String, Nullable: true},
                },
                nil,
        )
}</span>

// AppendFromArrow appends vectors and metadata from an Arrow record to the index.
func (idx *Index) AppendFromArrow(rec arrow.Record) error <span class="cov1" title="1">{
        // Just delegate to BatchAppendFromArrow for consistency
        return idx.BatchAppendFromArrow([]arrow.Record{rec})
}</span>

// BatchAppendFromArrow efficiently appends vectors and metadata from multiple Arrow records.
func (idx *Index) BatchAppendFromArrow(records []arrow.Record) error <span class="cov1" title="1">{
        if len(records) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Calculate total number of rows across all records
        <span class="cov1" title="1">totalRows := 0
        for _, rec := range records </span><span class="cov1" title="1">{
                totalRows += int(rec.NumRows())
        }</span>

        // Prepare all vectors and metadata before acquiring the lock
        <span class="cov1" title="1">allBatchItems := make([]vectorMeta, 0, totalRows)

        // Process each record
        for _, rec := range records </span><span class="cov1" title="1">{
                if rec.NumCols() &lt; 3 </span><span class="cov0" title="0">{
                        return errors.New("arrow record must have at least 3 columns: id, vector, metadata")
                }</span>

                <span class="cov1" title="1">idCol, ok := rec.Column(0).(*array.Uint64)
                if !ok </span><span class="cov0" title="0">{
                        return errors.New("expected column 0 (id) to be an Uint64 array")
                }</span>
                <span class="cov1" title="1">vectorCol, ok := rec.Column(1).(*array.FixedSizeList)
                if !ok </span><span class="cov0" title="0">{
                        return errors.New("expected column 1 (vector) to be a FixedSizeList array")
                }</span>
                <span class="cov1" title="1">metadataCol, ok := rec.Column(2).(*array.String)
                if !ok </span><span class="cov0" title="0">{
                        return errors.New("expected column 2 (metadata) to be a String array")
                }</span>

                <span class="cov1" title="1">fsType, ok := vectorCol.DataType().(*arrow.FixedSizeListType)
                if !ok </span><span class="cov0" title="0">{
                        return errors.New("failed to get FixedSizeList type from vector column")
                }</span>
                <span class="cov1" title="1">dim := int(fsType.Len())

                valuesArr, ok := vectorCol.ListValues().(*array.Float32)
                if !ok </span><span class="cov0" title="0">{
                        return errors.New("expected underlying vector array to be of type Float32")
                }</span>

                <span class="cov1" title="1">numRows := int(rec.NumRows())

                // Process all vectors in this record
                for i := 0; i &lt; numRows; i++ </span><span class="cov2" title="2">{
                        if idCol.IsNull(i) </span><span class="cov0" title="0">{
                                return fmt.Errorf("id column contains null value at row %d", i)
                        }</span>
                        <span class="cov2" title="2">id := idCol.Value(i)

                        if vectorCol.IsNull(i) </span><span class="cov0" title="0">{
                                return fmt.Errorf("vector column contains null value at row %d", i)
                        }</span>

                        // Extract vector
                        <span class="cov2" title="2">start := i * dim
                        vector := make([]float32, dim)
                        for j := 0; j &lt; dim; j++ </span><span class="cov3" title="6">{
                                vector[j] = valuesArr.Value(start + j)
                        }</span>

                        // Process metadata
                        <span class="cov2" title="2">var meta map[string]interface{}
                        if !metadataCol.IsNull(i) </span><span class="cov2" title="2">{
                                metaJSON := metadataCol.Value(i)
                                meta = make(map[string]interface{})

                                err := sonic.Unmarshal([]byte(metaJSON), &amp;meta)
                                if err != nil </span><span class="cov0" title="0">{
                                        idx.logger.Warn("failed to unmarshal metadata, storing raw JSON", zap.Uint64("id", id), zap.Error(err))
                                        meta = map[string]interface{}{"metadata": metaJSON}
                                }</span>

                                // Validate metadata schema
                                <span class="cov2" title="2">if err := validateMetadataSchema(meta); err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                        } else<span class="cov0" title="0"> {
                                meta = make(map[string]interface{})
                        }</span>

                        // Add to our batch items
                        <span class="cov2" title="2">allBatchItems = append(allBatchItems, vectorMeta{
                                id:     id,
                                vector: vector,
                                meta:   meta,
                        })</span>
                }
        }

        // If we have a large number of items, process them in smaller batches
        // to avoid holding the lock for too long
        <span class="cov1" title="1">batchSize := idx.config.BatchSize
        if batchSize &lt;= 0 </span><span class="cov0" title="0">{
                batchSize = 100 // Default batch size
        }</span>

        // For benchmarks and tests, we'll directly add items to the index
        // This avoids potential deadlocks with background workers
        <span class="cov1" title="1">if len(allBatchItems) &gt; 0 </span><span class="cov1" title="1">{
                // Lock the index for updating shared metadata and cache
                idx.lock.Lock()

                // Check if HNSW is initialized
                if idx.hnsw == nil </span><span class="cov0" title="0">{
                        idx.lock.Unlock()
                        return errors.New("HNSW graph is not initialized")
                }</span>

                // Process sequentially to avoid data races in HNSW
                <span class="cov1" title="1">for _, item := range allBatchItems </span><span class="cov2" title="2">{
                        // Add to HNSW graph
                        node := hnsw.MakeNode(item.id, item.vector)
                        if err := idx.hnsw.Add(node); err != nil </span><span class="cov0" title="0">{
                                // Log the error but continue with other operations
                                idx.logger.Warn("Failed to add node to HNSW graph during batch append",
                                        zap.Uint64("id", item.id),
                                        zap.Error(err))
                        }</span>

                        // Update in-memory metadata and cache
                        <span class="cov2" title="2">idx.metadata[item.id] = item.meta
                        idx.cache.Store(item.id, item.meta)

                        // Store vector for negative example searches
                        idx.vectors[item.id] = item.vector</span>
                }

                // If we have a database connection, store metadata there too
                <span class="cov1" title="1">if idx.dbConn != nil </span><span class="cov1" title="1">{
                        // Use the index's allocator if available, otherwise create a new one
                        var pool memory.Allocator
                        if idx.allocator != nil </span><span class="cov1" title="1">{
                                pool = idx.allocator
                        }</span> else<span class="cov0" title="0"> {
                                pool = memory.NewGoAllocator()
                        }</span>

                        // Create schema for metadata table
                        <span class="cov1" title="1">schema := arrow.NewSchema(
                                []arrow.Field{
                                        {Name: "id", Type: arrow.PrimitiveTypes.Uint64, Nullable: false},
                                        {Name: "json", Type: arrow.BinaryTypes.String, Nullable: true},
                                },
                                nil,
                        )

                        // Process in batches to avoid overwhelming the database
                        for i := 0; i &lt; len(allBatchItems); i += batchSize </span><span class="cov1" title="1">{
                                end := i + batchSize
                                if end &gt; len(allBatchItems) </span><span class="cov1" title="1">{
                                        end = len(allBatchItems)
                                }</span>

                                // Create record builder
                                <span class="cov1" title="1">builder := array.NewRecordBuilder(pool, schema)

                                // Get builders for each column
                                idBuilder := builder.Field(0).(*array.Uint64Builder)
                                jsonBuilder := builder.Field(1).(*array.StringBuilder)

                                // Pre-allocate capacity for better performance
                                idBuilder.Reserve(end - i)
                                jsonBuilder.Reserve(end - i)

                                // Add data to builders
                                for _, item := range allBatchItems[i:end] </span><span class="cov2" title="2">{
                                        // Convert metadata to JSON
                                        metaJSON, err := sonic.Marshal(item.meta)
                                        if err != nil </span><span class="cov0" title="0">{
                                                idx.logger.Error("failed to marshal metadata", zap.Error(err), zap.Uint64("id", item.id))
                                                metaJSON = []byte("{}")
                                        }</span>

                                        // Append values
                                        <span class="cov2" title="2">idBuilder.Append(item.id)
                                        jsonBuilder.Append(string(metaJSON))</span>
                                }

                                // Build the record
                                <span class="cov1" title="1">record := builder.NewRecord()

                                // Insert using ADBC
                                _, err := idx.dbConn.IngestCreateAppend(context.Background(), "metadata", record)

                                // Clean up
                                record.Release()
                                builder.Release()

                                if err != nil </span><span class="cov0" title="0">{
                                        idx.lock.Unlock()
                                        return fmt.Errorf("failed to insert metadata: %w", err)
                                }</span>
                        }
                }

                <span class="cov1" title="1">idx.lock.Unlock()</span>
        }

        <span class="cov1" title="1">return nil</span>
}

// DeleteVector deletes a vector from the index.
func (idx *Index) DeleteVector(id uint64) error <span class="cov1" title="1">{
        idx.lock.Lock()
        defer idx.lock.Unlock()

        if _, ok := idx.vectors[id]; !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("vector with id %d not found", id)
        }</span>

        // Remove from all relevant maps
        <span class="cov1" title="1">delete(idx.vectors, id)
        delete(idx.metadata, id)
        idx.cache.Delete(id)

        // Remove from HNSW graph
        idx.hnsw.Delete(id)

        // Remove from database if available
        if idx.dbConn != nil </span><span class="cov1" title="1">{
                ctx := context.Background()

                // Create a parameterized query
                query := "DELETE FROM metadata WHERE id = ?"

                // Create a statement
                stmt, err := idx.dbConn.conn.NewStatement()
                if err != nil </span><span class="cov0" title="0">{
                        idx.logger.Error("failed to create statement", zap.Error(err))
                        return fmt.Errorf("failed to create statement: %w", err)
                }</span>
                <span class="cov1" title="1">defer stmt.Close()

                if err := stmt.SetSqlQuery(query); err != nil </span><span class="cov0" title="0">{
                        idx.logger.Error("failed to set SQL query", zap.Error(err))
                        return fmt.Errorf("failed to set SQL query: %w", err)
                }</span>

                // Create an Arrow record with the ID
                <span class="cov1" title="1">idBuilder := array.NewUint64Builder(idx.allocator)
                defer idBuilder.Release()

                idBuilder.Append(id)
                idArray := idBuilder.NewArray()
                defer idArray.Release()

                // Create the record
                schema := arrow.NewSchema(
                        []arrow.Field{
                                {Name: "id", Type: arrow.PrimitiveTypes.Uint64, Nullable: false},
                        },
                        nil,
                )

                record := array.NewRecord(schema, []arrow.Array{idArray}, 1)
                defer record.Release()

                // Bind the record
                if err := stmt.Bind(ctx, record); err != nil </span><span class="cov0" title="0">{
                        idx.logger.Error("failed to bind parameter", zap.Uint64("id", id), zap.Error(err))
                        return fmt.Errorf("failed to bind parameter: %w", err)
                }</span>

                // Execute the statement
                <span class="cov1" title="1">_, err = stmt.ExecuteUpdate(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        idx.logger.Error("failed to delete from database", zap.Uint64("id", id), zap.Error(err))
                        return fmt.Errorf("failed to delete from database: %w", err)
                }</span>
        }

        <span class="cov1" title="1">return nil</span>
}

// DeleteVectors deletes multiple vectors from the index.
func (idx *Index) DeleteVectors(ids []uint64) error <span class="cov1" title="1">{
        idx.lock.Lock()
        defer idx.lock.Unlock()

        // Check if all vectors exist first
        for _, id := range ids </span><span class="cov2" title="2">{
                if _, ok := idx.vectors[id]; !ok </span><span class="cov0" title="0">{
                        return fmt.Errorf("vector with id %d not found", id)
                }</span>
        }

        // Remove from all relevant maps
        <span class="cov1" title="1">for _, id := range ids </span><span class="cov2" title="2">{
                delete(idx.vectors, id)
                delete(idx.metadata, id)
                idx.cache.Delete(id)

                idx.hnsw.Delete(id)
        }</span>

        // Remove from database if available
        <span class="cov1" title="1">if idx.dbConn != nil &amp;&amp; len(ids) &gt; 0 </span><span class="cov1" title="1">{
                ctx := context.Background()

                // Create a parameterized query
                query := "DELETE FROM metadata WHERE id = ?"

                // Create a statement
                stmt, err := idx.dbConn.conn.NewStatement()
                if err != nil </span><span class="cov0" title="0">{
                        idx.logger.Error("failed to create statement", zap.Error(err))
                        return fmt.Errorf("failed to create statement: %w", err)
                }</span>
                <span class="cov1" title="1">defer stmt.Close()

                if err := stmt.SetSqlQuery(query); err != nil </span><span class="cov0" title="0">{
                        idx.logger.Error("failed to set SQL query", zap.Error(err))
                        return fmt.Errorf("failed to set SQL query: %w", err)
                }</span>

                // Execute delete for each ID using proper Arrow record binding
                <span class="cov1" title="1">for _, id := range ids </span><span class="cov2" title="2">{
                        // Create an Arrow record with the ID
                        idBuilder := array.NewUint64Builder(idx.allocator)
                        defer idBuilder.Release()

                        idBuilder.Append(id)
                        idArray := idBuilder.NewArray()
                        defer idArray.Release()

                        // Create the record
                        schema := arrow.NewSchema(
                                []arrow.Field{
                                        {Name: "id", Type: arrow.PrimitiveTypes.Uint64, Nullable: false},
                                },
                                nil,
                        )

                        record := array.NewRecord(schema, []arrow.Array{idArray}, 1)
                        defer record.Release()

                        // Bind the record
                        if err := stmt.Bind(ctx, record); err != nil </span><span class="cov0" title="0">{
                                idx.logger.Error("failed to bind parameter", zap.Uint64("id", id), zap.Error(err))
                                return fmt.Errorf("failed to bind parameter: %w", err)
                        }</span>

                        // Execute the statement
                        <span class="cov2" title="2">_, err = stmt.ExecuteUpdate(ctx)
                        if err != nil </span><span class="cov0" title="0">{
                                idx.logger.Error("failed to delete from database", zap.Uint64("id", id), zap.Error(err))
                                return fmt.Errorf("failed to delete from database: %w", err)
                        }</span>
                }
        }

        <span class="cov1" title="1">return nil</span>
}

// Config returns a copy of the index configuration
func (idx *Index) Config() Config <span class="cov0" title="0">{
        idx.lock.RLock()
        defer idx.lock.RUnlock()
        return idx.config
}</span>

// AnalyzeGraph returns quality metrics for the HNSW graph.
// This is useful for understanding the health and performance characteristics of the index.
func (idx *Index) AnalyzeGraph() (map[string]interface{}, error) <span class="cov1" title="1">{
        idx.lock.RLock()
        defer idx.lock.RUnlock()

        // Create an analyzer for the graph
        analyzer := &amp;hnsw.Analyzer[uint64]{Graph: idx.hnsw}

        // Get quality metrics
        metrics := analyzer.QualityMetrics()

        // Get connectivity information
        connectivity := analyzer.Connectivity()

        // Get topography information
        topography := analyzer.Topography()

        // Create a map of all metrics
        result := map[string]interface{}{
                "node_count":          metrics.NodeCount,
                "avg_connectivity":    metrics.AvgConnectivity,
                "connectivity_stddev": metrics.ConnectivityStdDev,
                "distortion_ratio":    metrics.DistortionRatio,
                "layer_balance":       metrics.LayerBalance,
                "graph_height":        metrics.GraphHeight,
                "layer_connectivity":  connectivity,
                "layer_topography":    topography,
        }

        return result, nil
}</span>

// GetGraphAnalyzer returns the HNSW graph analyzer for advanced analysis.
// This is intended for advanced users who need direct access to the analyzer.
// Note: This method does not acquire a lock, so the caller must ensure thread safety.
func (idx *Index) GetGraphAnalyzer() *hnsw.Analyzer[uint64] <span class="cov0" title="0">{
        return &amp;hnsw.Analyzer[uint64]{Graph: idx.hnsw}
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">package router

import (
        "context"
        "errors"
        "fmt"
        "math"
        "sync"
        "time"

        "github.com/TFMV/quiver"
        "github.com/google/uuid"
        "go.uber.org/zap"
)

// IndexType represents the type of index for specialized routing
type IndexType string

const (
        // Common index types
        GeneralIndex    IndexType = "general"
        TechnicalIndex  IndexType = "technical"
        CreativeIndex   IndexType = "creative"
        FinancialIndex  IndexType = "financial"
        ScientificIndex IndexType = "scientific"
        LegalIndex      IndexType = "legal"
        MedicalIndex    IndexType = "medical"
)

// RouterConfig contains configuration for the semantic router
type RouterConfig struct {
        // Default index to use when no suitable index is found
        DefaultIndex IndexType
        // Threshold for routing confidence (0.0-1.0)
        ConfidenceThreshold float32
        // Whether to log routing decisions
        EnableLogging bool
        // Whether to cache routing decisions
        EnableCache bool
        // Maximum size of the routing cache
        CacheSize int
        // TTL for cache entries
        CacheTTL time.Duration
        // Whether to use parallel routing
        ParallelRouting bool
        // Timeout for routing decisions
        RoutingTimeout time.Duration
        // Whether to fallback to default index on timeout
        FallbackOnTimeout bool
        // Whether to learn from routing decisions
        EnableLearning bool
        // Learning rate for updating routing models
        LearningRate float32
        // Dimension of the routing embeddings
        RoutingDimension int
}

// DefaultRouterConfig returns a default configuration for the router
func DefaultRouterConfig() RouterConfig <span class="cov0" title="0">{
        return RouterConfig{
                DefaultIndex:        GeneralIndex,
                ConfidenceThreshold: 0.75,
                EnableLogging:       true,
                EnableCache:         true,
                CacheSize:           10000,
                CacheTTL:            time.Hour,
                ParallelRouting:     true,
                RoutingTimeout:      time.Second * 2,
                FallbackOnTimeout:   true,
                EnableLearning:      true,
                LearningRate:        0.01,
                RoutingDimension:    128,
        }
}</span>

// RoutingDecision represents the result of a routing decision
type RoutingDecision struct {
        TargetIndex        IndexType
        Confidence         float32
        AlternativeIndices map[IndexType]float32
        DecisionTime       time.Duration
        DecisionID         string
        Timestamp          time.Time
}

// IndexRegistry maintains a registry of available indices
type IndexRegistry struct {
        indices    map[IndexType]*quiver.Index
        embeddings map[IndexType][]float32
        lock       sync.RWMutex
        logger     *zap.Logger
}

// NewIndexRegistry creates a new index registry
func NewIndexRegistry(logger *zap.Logger) *IndexRegistry <span class="cov0" title="0">{
        return &amp;IndexRegistry{
                indices:    make(map[IndexType]*quiver.Index),
                embeddings: make(map[IndexType][]float32),
                logger:     logger,
        }
}</span>

// RegisterIndex registers an index with the registry
func (r *IndexRegistry) RegisterIndex(indexType IndexType, index *quiver.Index, embedding []float32) error <span class="cov0" title="0">{
        r.lock.Lock()
        defer r.lock.Unlock()

        if index == nil </span><span class="cov0" title="0">{
                return errors.New("cannot register nil index")
        }</span>

        <span class="cov0" title="0">if _, exists := r.indices[indexType]; exists </span><span class="cov0" title="0">{
                return fmt.Errorf("index type %s already registered", indexType)
        }</span>

        <span class="cov0" title="0">r.indices[indexType] = index

        // Store the embedding for this index type
        if embedding != nil </span><span class="cov0" title="0">{
                r.embeddings[indexType] = embedding
        }</span>

        <span class="cov0" title="0">r.logger.Info("Registered index", zap.String("type", string(indexType)))
        return nil</span>
}

// GetIndex retrieves an index from the registry
func (r *IndexRegistry) GetIndex(indexType IndexType) (*quiver.Index, error) <span class="cov0" title="0">{
        r.lock.RLock()
        defer r.lock.RUnlock()

        index, exists := r.indices[indexType]
        if !exists </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("index type %s not found", indexType)
        }</span>

        <span class="cov0" title="0">return index, nil</span>
}

// GetAllIndices returns all registered indices
func (r *IndexRegistry) GetAllIndices() map[IndexType]*quiver.Index <span class="cov0" title="0">{
        r.lock.RLock()
        defer r.lock.RUnlock()

        // Create a copy to avoid race conditions
        result := make(map[IndexType]*quiver.Index, len(r.indices))
        for k, v := range r.indices </span><span class="cov0" title="0">{
                result[k] = v
        }</span>

        <span class="cov0" title="0">return result</span>
}

// GetIndexEmbedding returns the embedding for an index type
func (r *IndexRegistry) GetIndexEmbedding(indexType IndexType) ([]float32, error) <span class="cov0" title="0">{
        r.lock.RLock()
        defer r.lock.RUnlock()

        embedding, exists := r.embeddings[indexType]
        if !exists </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("embedding for index type %s not found", indexType)
        }</span>

        <span class="cov0" title="0">return embedding, nil</span>
}

// GetAllEmbeddings returns all registered embeddings
func (r *IndexRegistry) GetAllEmbeddings() map[IndexType][]float32 <span class="cov0" title="0">{
        r.lock.RLock()
        defer r.lock.RUnlock()

        // Create a copy to avoid race conditions
        result := make(map[IndexType][]float32, len(r.embeddings))
        for k, v := range r.embeddings </span><span class="cov0" title="0">{
                result[k] = v
        }</span>

        <span class="cov0" title="0">return result</span>
}

// cacheEntry represents an entry in the routing cache
type cacheEntry struct {
        decision  RoutingDecision
        timestamp time.Time
}

// SemanticRouter routes queries to the appropriate index based on content
type SemanticRouter struct {
        config         RouterConfig
        registry       *IndexRegistry
        routingIndex   *quiver.Index
        routingCache   map[string]cacheEntry
        cacheLock      sync.RWMutex
        logger         *zap.Logger
        metrics        *RouterMetrics
        learningBuffer []learningExample
        learningLock   sync.Mutex
}

// learningExample represents an example for updating the routing model
type learningExample struct {
        query    []float32
        decision IndexType
        feedback float32 // 0.0-1.0, where 1.0 is positive feedback
}

// RouterMetrics tracks metrics for the router
type RouterMetrics struct {
        TotalRequests       int64
        CacheHits           int64
        CacheMisses         int64
        RoutingErrors       int64
        RoutingTimeouts     int64
        ConfidenceThreshold float32
        AvgRoutingTime      time.Duration
        RoutingDecisions    map[IndexType]int64
        lock                *sync.Mutex
}

// NewSemanticRouter creates a new semantic router
func NewSemanticRouter(config RouterConfig, registry *IndexRegistry, logger *zap.Logger) (*SemanticRouter, error) <span class="cov0" title="0">{
        if registry == nil </span><span class="cov0" title="0">{
                return nil, errors.New("index registry cannot be nil")
        }</span>

        // Create a routing index for storing index type embeddings
        <span class="cov0" title="0">routingConfig := quiver.Config{
                Dimension:       config.RoutingDimension,
                Distance:        quiver.CosineDistance,
                HNSWM:           16,
                HNSWEfConstruct: 200,
                HNSWEfSearch:    100,
        }

        routingIndex, err := quiver.New(routingConfig, logger)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create routing index: %w", err)
        }</span>

        <span class="cov0" title="0">router := &amp;SemanticRouter{
                config:       config,
                registry:     registry,
                routingIndex: routingIndex,
                routingCache: make(map[string]cacheEntry),
                logger:       logger,
                metrics: &amp;RouterMetrics{
                        RoutingDecisions:    make(map[IndexType]int64),
                        ConfidenceThreshold: config.ConfidenceThreshold,
                        lock:                &amp;sync.Mutex{},
                },
                learningBuffer: make([]learningExample, 0, 100),
        }

        // Initialize the routing index with embeddings from the registry
        embeddings := registry.GetAllEmbeddings()
        for indexType, embedding := range embeddings </span><span class="cov0" title="0">{
                // Use the index type as the ID
                id := uint64(fnv1a(string(indexType)))
                meta := map[string]interface{}{
                        "type": string(indexType),
                }

                if err := routingIndex.Add(id, embedding, meta); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to add embedding for index type %s: %w", indexType, err)
                }</span>
        }

        // Start background tasks if needed
        <span class="cov0" title="0">if config.EnableCache </span><span class="cov0" title="0">{
                go router.startCacheCleanup()
        }</span>

        <span class="cov0" title="0">if config.EnableLearning </span><span class="cov0" title="0">{
                go router.startLearningUpdates()
        }</span>

        <span class="cov0" title="0">return router, nil</span>
}

// fnv1a computes a 64-bit FNV-1a hash of the given string
func fnv1a(s string) uint64 <span class="cov0" title="0">{
        const (
                offset64 = 14695981039346656037
                prime64  = 1099511628211
        )
        hash := uint64(offset64)
        for i := 0; i &lt; len(s); i++ </span><span class="cov0" title="0">{
                hash ^= uint64(s[i])
                hash *= prime64
        }</span>
        <span class="cov0" title="0">return hash</span>
}

// startCacheCleanup periodically cleans up expired cache entries
func (r *SemanticRouter) startCacheCleanup() <span class="cov0" title="0">{
        ticker := time.NewTicker(r.config.CacheTTL / 2)
        defer ticker.Stop()

        for range ticker.C </span><span class="cov0" title="0">{
                r.cleanupCache()
        }</span>
}

// cleanupCache removes expired entries from the cache
func (r *SemanticRouter) cleanupCache() <span class="cov0" title="0">{
        r.cacheLock.Lock()
        defer r.cacheLock.Unlock()

        now := time.Now()
        for key, entry := range r.routingCache </span><span class="cov0" title="0">{
                if now.Sub(entry.timestamp) &gt; r.config.CacheTTL </span><span class="cov0" title="0">{
                        delete(r.routingCache, key)
                }</span>
        }
}

// startLearningUpdates periodically updates the routing model based on feedback
func (r *SemanticRouter) startLearningUpdates() <span class="cov0" title="0">{
        ticker := time.NewTicker(time.Minute)
        defer ticker.Stop()

        for range ticker.C </span><span class="cov0" title="0">{
                r.updateRoutingModel()
        }</span>
}

// updateRoutingModel updates the routing model based on collected examples
func (r *SemanticRouter) updateRoutingModel() <span class="cov0" title="0">{
        r.learningLock.Lock()
        examples := r.learningBuffer
        r.learningBuffer = make([]learningExample, 0, 100)
        r.learningLock.Unlock()

        if len(examples) == 0 </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">r.logger.Info("Updating routing model", zap.Int("examples", len(examples)))

        // Group examples by decision
        examplesByDecision := make(map[IndexType][]learningExample)
        for _, ex := range examples </span><span class="cov0" title="0">{
                examplesByDecision[ex.decision] = append(examplesByDecision[ex.decision], ex)
        }</span>

        // Update embeddings for each index type
        <span class="cov0" title="0">for indexType, exs := range examplesByDecision </span><span class="cov0" title="0">{
                // Get current embedding
                currentEmbedding, err := r.registry.GetIndexEmbedding(indexType)
                if err != nil </span><span class="cov0" title="0">{
                        r.logger.Error("Failed to get embedding for index type",
                                zap.String("type", string(indexType)),
                                zap.Error(err))
                        continue</span>
                }

                // Compute average update direction
                <span class="cov0" title="0">update := make([]float32, len(currentEmbedding))
                totalWeight := float32(0)

                for _, ex := range exs </span><span class="cov0" title="0">{
                        weight := ex.feedback
                        totalWeight += weight

                        for i := 0; i &lt; len(update); i++ </span><span class="cov0" title="0">{
                                if i &lt; len(ex.query) </span><span class="cov0" title="0">{
                                        update[i] += weight * (ex.query[i] - currentEmbedding[i])
                                }</span>
                        }
                }

                // Apply update with learning rate
                <span class="cov0" title="0">if totalWeight &gt; 0 </span><span class="cov0" title="0">{
                        for i := 0; i &lt; len(update); i++ </span><span class="cov0" title="0">{
                                update[i] = update[i] / totalWeight
                                currentEmbedding[i] += r.config.LearningRate * update[i]
                        }</span>

                        // Normalize the embedding
                        <span class="cov0" title="0">norm := float32(0)
                        for _, v := range currentEmbedding </span><span class="cov0" title="0">{
                                norm += v * v
                        }</span>
                        <span class="cov0" title="0">norm = float32(math.Sqrt(float64(norm)))

                        if norm &gt; 0 </span><span class="cov0" title="0">{
                                for i := range currentEmbedding </span><span class="cov0" title="0">{
                                        currentEmbedding[i] /= norm
                                }</span>
                        }

                        // Update the embedding in the registry and routing index
                        <span class="cov0" title="0">id := uint64(fnv1a(string(indexType)))
                        meta := map[string]interface{}{
                                "type": string(indexType),
                        }

                        if err := r.routingIndex.DeleteVector(id); err != nil </span><span class="cov0" title="0">{
                                r.logger.Error("Failed to delete old embedding",
                                        zap.String("type", string(indexType)),
                                        zap.Error(err))
                        }</span>

                        <span class="cov0" title="0">if err := r.routingIndex.Add(id, currentEmbedding, meta); err != nil </span><span class="cov0" title="0">{
                                r.logger.Error("Failed to update embedding",
                                        zap.String("type", string(indexType)),
                                        zap.Error(err))
                        }</span>
                }
        }
}

// Route routes a query to the appropriate index
func (r *SemanticRouter) Route(ctx context.Context, query []float32) (RoutingDecision, error) <span class="cov0" title="0">{
        start := time.Now()

        // Create a unique decision ID
        decisionID := uuid.New().String()

        // Update metrics
        r.metrics.lock.Lock()
        r.metrics.TotalRequests++
        r.metrics.lock.Unlock()

        // Check cache if enabled
        if r.config.EnableCache </span><span class="cov0" title="0">{
                cacheKey := computeCacheKey(query)
                cachedDecision, found := r.getCachedDecision(cacheKey)
                if found </span><span class="cov0" title="0">{
                        r.metrics.lock.Lock()
                        r.metrics.CacheHits++
                        r.metrics.lock.Unlock()

                        // Update the decision ID and timestamp
                        cachedDecision.DecisionID = decisionID
                        cachedDecision.Timestamp = time.Now()

                        return cachedDecision, nil
                }</span>

                <span class="cov0" title="0">r.metrics.lock.Lock()
                r.metrics.CacheMisses++
                r.metrics.lock.Unlock()</span>
        }

        // Create a context with timeout if configured
        <span class="cov0" title="0">var routingCtx context.Context
        var cancel context.CancelFunc

        if r.config.RoutingTimeout &gt; 0 </span><span class="cov0" title="0">{
                routingCtx, cancel = context.WithTimeout(ctx, r.config.RoutingTimeout)
                defer cancel()
        }</span> else<span class="cov0" title="0"> {
                routingCtx = ctx
        }</span>

        // Perform the routing decision
        <span class="cov0" title="0">decision, err := r.makeRoutingDecision(routingCtx, query)
        if err != nil </span><span class="cov0" title="0">{
                r.metrics.lock.Lock()
                r.metrics.RoutingErrors++
                r.metrics.lock.Unlock()

                // Check if it's a timeout error
                if errors.Is(err, context.DeadlineExceeded) </span><span class="cov0" title="0">{
                        r.metrics.lock.Lock()
                        r.metrics.RoutingTimeouts++
                        r.metrics.lock.Unlock()

                        r.logger.Warn("Routing decision timed out", zap.Duration("timeout", r.config.RoutingTimeout))

                        // Fallback to default index if configured
                        if r.config.FallbackOnTimeout </span><span class="cov0" title="0">{
                                return RoutingDecision{
                                        TargetIndex:  r.config.DefaultIndex,
                                        Confidence:   0.0,
                                        DecisionTime: time.Since(start),
                                        DecisionID:   decisionID,
                                        Timestamp:    time.Now(),
                                }, nil
                        }</span>
                }

                <span class="cov0" title="0">return RoutingDecision{}, err</span>
        }

        // Set decision metadata
        <span class="cov0" title="0">decision.DecisionTime = time.Since(start)
        decision.DecisionID = decisionID
        decision.Timestamp = time.Now()

        // Update metrics
        r.metrics.lock.Lock()
        r.metrics.RoutingDecisions[decision.TargetIndex]++
        r.metrics.AvgRoutingTime = (r.metrics.AvgRoutingTime*time.Duration(r.metrics.TotalRequests-1) + decision.DecisionTime) / time.Duration(r.metrics.TotalRequests)
        r.metrics.lock.Unlock()

        // Cache the decision if enabled
        if r.config.EnableCache </span><span class="cov0" title="0">{
                cacheKey := computeCacheKey(query)
                r.cacheDecision(cacheKey, decision)
        }</span>

        // Log the decision if enabled
        <span class="cov0" title="0">if r.config.EnableLogging </span><span class="cov0" title="0">{
                r.logger.Info("Routing decision",
                        zap.String("decisionID", decision.DecisionID),
                        zap.String("targetIndex", string(decision.TargetIndex)),
                        zap.Float32("confidence", decision.Confidence),
                        zap.Duration("decisionTime", decision.DecisionTime))
        }</span>

        <span class="cov0" title="0">return decision, nil</span>
}

// makeRoutingDecision performs the actual routing decision
func (r *SemanticRouter) makeRoutingDecision(ctx context.Context, query []float32) (RoutingDecision, error) <span class="cov0" title="0">{
        // Search the routing index for the most similar index types
        results, err := r.routingIndex.Search(query, 5, 0, 0)
        if err != nil </span><span class="cov0" title="0">{
                return RoutingDecision{}, fmt.Errorf("failed to search routing index: %w", err)
        }</span>

        <span class="cov0" title="0">if len(results) == 0 </span><span class="cov0" title="0">{
                return RoutingDecision{
                        TargetIndex: r.config.DefaultIndex,
                        Confidence:  0.0,
                }, nil
        }</span>

        // Convert search results to routing decision
        <span class="cov0" title="0">decision := RoutingDecision{
                AlternativeIndices: make(map[IndexType]float32),
        }

        // The top result is the target index
        topResult := results[0]
        indexType, ok := topResult.Metadata["type"].(string)
        if !ok </span><span class="cov0" title="0">{
                return RoutingDecision{}, errors.New("invalid index type in routing result")
        }</span>

        <span class="cov0" title="0">decision.TargetIndex = IndexType(indexType)
        decision.Confidence = 1.0 - topResult.Distance // Convert distance to confidence

        // Store alternative indices
        for i := 1; i &lt; len(results); i++ </span><span class="cov0" title="0">{
                altType, ok := results[i].Metadata["type"].(string)
                if !ok </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">decision.AlternativeIndices[IndexType(altType)] = 1.0 - results[i].Distance</span>
        }

        // If confidence is below threshold, use default index
        <span class="cov0" title="0">if decision.Confidence &lt; r.config.ConfidenceThreshold </span><span class="cov0" title="0">{
                decision.TargetIndex = r.config.DefaultIndex
                decision.Confidence = 0.0
        }</span>

        <span class="cov0" title="0">return decision, nil</span>
}

// computeCacheKey computes a cache key for a query
func computeCacheKey(query []float32) string <span class="cov0" title="0">{
        // Simple hash-based key for now
        // In production, you might want a more sophisticated approach
        hash := fnv1a(fmt.Sprintf("%v", query))
        return fmt.Sprintf("%d", hash)
}</span>

// getCachedDecision retrieves a cached routing decision
func (r *SemanticRouter) getCachedDecision(key string) (RoutingDecision, bool) <span class="cov0" title="0">{
        r.cacheLock.RLock()
        defer r.cacheLock.RUnlock()

        entry, found := r.routingCache[key]
        if !found </span><span class="cov0" title="0">{
                return RoutingDecision{}, false
        }</span>

        // Check if the entry has expired
        <span class="cov0" title="0">if time.Since(entry.timestamp) &gt; r.config.CacheTTL </span><span class="cov0" title="0">{
                return RoutingDecision{}, false
        }</span>

        <span class="cov0" title="0">return entry.decision, true</span>
}

// cacheDecision caches a routing decision
func (r *SemanticRouter) cacheDecision(key string, decision RoutingDecision) <span class="cov0" title="0">{
        r.cacheLock.Lock()
        defer r.cacheLock.Unlock()

        // Check if cache is full
        if len(r.routingCache) &gt;= r.config.CacheSize </span><span class="cov0" title="0">{
                // Simple eviction strategy: remove a random entry
                // In production, you might want LRU or another strategy
                for k := range r.routingCache </span><span class="cov0" title="0">{
                        delete(r.routingCache, k)
                        break</span>
                }
        }

        <span class="cov0" title="0">r.routingCache[key] = cacheEntry{
                decision:  decision,
                timestamp: time.Now(),
        }</span>
}

// ProvideRoutingFeedback provides feedback on a routing decision
func (r *SemanticRouter) ProvideRoutingFeedback(decisionID string, feedback float32) error <span class="cov0" title="0">{
        if !r.config.EnableLearning </span><span class="cov0" title="0">{
                return errors.New("learning is not enabled")
        }</span>

        // Validate feedback
        <span class="cov0" title="0">if feedback &lt; 0.0 || feedback &gt; 1.0 </span><span class="cov0" title="0">{
                return errors.New("feedback must be between 0.0 and 1.0")
        }</span>

        // Find the decision in the cache
        <span class="cov0" title="0">var decision RoutingDecision
        var query []float32
        found := false

        r.cacheLock.RLock()
        for _, entry := range r.routingCache </span><span class="cov0" title="0">{
                if entry.decision.DecisionID == decisionID </span><span class="cov0" title="0">{
                        decision = entry.decision

                        // Reconstruct the query from the cache key
                        // This is a simplification; in production you might want to store the query
                        found = true
                        break</span>
                }
        }
        <span class="cov0" title="0">r.cacheLock.RUnlock()

        if !found </span><span class="cov0" title="0">{
                return errors.New("decision not found")
        }</span>

        // If we couldn't reconstruct the query, we can't provide feedback
        <span class="cov0" title="0">if query == nil </span><span class="cov0" title="0">{
                return errors.New("could not reconstruct query for feedback")
        }</span>

        // Add to learning buffer
        <span class="cov0" title="0">r.learningLock.Lock()
        r.learningBuffer = append(r.learningBuffer, learningExample{
                query:    query,
                decision: decision.TargetIndex,
                feedback: feedback,
        })
        r.learningLock.Unlock()

        r.logger.Info("Received routing feedback",
                zap.String("decisionID", decisionID),
                zap.Float32("feedback", feedback))

        return nil</span>
}

// GetMetrics returns a copy of the current router metrics
func (r *SemanticRouter) GetMetrics() RouterMetrics <span class="cov0" title="0">{
        r.metrics.lock.Lock()
        defer r.metrics.lock.Unlock()

        // Create a copy to avoid race conditions, but without the lock
        metricsCopy := RouterMetrics{
                TotalRequests:       r.metrics.TotalRequests,
                CacheHits:           r.metrics.CacheHits,
                CacheMisses:         r.metrics.CacheMisses,
                RoutingErrors:       r.metrics.RoutingErrors,
                RoutingTimeouts:     r.metrics.RoutingTimeouts,
                ConfidenceThreshold: r.metrics.ConfidenceThreshold,
                AvgRoutingTime:      r.metrics.AvgRoutingTime,
                RoutingDecisions:    make(map[IndexType]int64),
        }

        for k, v := range r.metrics.RoutingDecisions </span><span class="cov0" title="0">{
                metricsCopy.RoutingDecisions[k] = v
        }</span>

        <span class="cov0" title="0">return metricsCopy</span>
}

// Close closes the router and releases resources
func (r *SemanticRouter) Close() error <span class="cov0" title="0">{
        return r.routingIndex.Close()
}</span>

// GetRegistry returns the underlying index registry
func (r *SemanticRouter) GetRegistry() *IndexRegistry <span class="cov0" title="0">{
        return r.registry
}</span>

// BatchRoute routes multiple queries in parallel
func (r *SemanticRouter) BatchRoute(ctx context.Context, queries [][]float32) ([]RoutingDecision, error) <span class="cov0" title="0">{
        if !r.config.ParallelRouting </span><span class="cov0" title="0">{
                // Sequential routing
                decisions := make([]RoutingDecision, len(queries))
                for i, query := range queries </span><span class="cov0" title="0">{
                        decision, err := r.Route(ctx, query)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("failed to route query %d: %w", i, err)
                        }</span>
                        <span class="cov0" title="0">decisions[i] = decision</span>
                }
                <span class="cov0" title="0">return decisions, nil</span>
        }

        // Parallel routing
        <span class="cov0" title="0">decisions := make([]RoutingDecision, len(queries))
        errors := make([]error, len(queries))
        var wg sync.WaitGroup

        for i, query := range queries </span><span class="cov0" title="0">{
                wg.Add(1)
                go func(idx int, q []float32) </span><span class="cov0" title="0">{
                        defer wg.Done()
                        decision, err := r.Route(ctx, q)
                        if err != nil </span><span class="cov0" title="0">{
                                errors[idx] = err
                                return
                        }</span>
                        <span class="cov0" title="0">decisions[idx] = decision</span>
                }(i, query)
        }

        <span class="cov0" title="0">wg.Wait()

        // Check for errors
        for i, err := range errors </span><span class="cov0" title="0">{
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to route query %d: %w", i, err)
                }</span>
        }

        <span class="cov0" title="0">return decisions, nil</span>
}

// GetTopIndices returns the top N indices for a query
func (r *SemanticRouter) GetTopIndices(ctx context.Context, query []float32, n int) (map[IndexType]float32, error) <span class="cov0" title="0">{
        // Search the routing index for the most similar index types
        results, err := r.routingIndex.Search(query, n, 0, 0)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to search routing index: %w", err)
        }</span>

        <span class="cov0" title="0">indices := make(map[IndexType]float32)
        for _, result := range results </span><span class="cov0" title="0">{
                indexType, ok := result.Metadata["type"].(string)
                if !ok </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">indices[IndexType(indexType)] = 1.0 - result.Distance</span>
        }

        <span class="cov0" title="0">return indices, nil</span>
}

// RoutingStats contains statistics about routing decisions
type RoutingStats struct {
        TotalDecisions      int64
        DecisionsByIndex    map[IndexType]int64
        AvgConfidence       float32
        ConfidenceHistogram map[string]int64 // Buckets: "0.0-0.1", "0.1-0.2", etc.
        AvgDecisionTime     time.Duration
}

// GetRoutingStats returns statistics about routing decisions
func (r *SemanticRouter) GetRoutingStats() RoutingStats <span class="cov0" title="0">{
        r.metrics.lock.Lock()
        defer r.metrics.lock.Unlock()

        stats := RoutingStats{
                TotalDecisions:      r.metrics.TotalRequests,
                DecisionsByIndex:    make(map[IndexType]int64),
                AvgDecisionTime:     r.metrics.AvgRoutingTime,
                ConfidenceHistogram: make(map[string]int64),
        }

        for k, v := range r.metrics.RoutingDecisions </span><span class="cov0" title="0">{
                stats.DecisionsByIndex[k] = v
        }</span>

        // We don't have confidence histogram data in the current implementation
        // This would require additional tracking

        <span class="cov0" title="0">return stats</span>
}

// RegisterEmbeddingProvider registers a function that provides embeddings for queries
type EmbeddingProvider func(query string) ([]float32, error)

// TextRouter is a wrapper around SemanticRouter that handles text queries
type TextRouter struct {
        router            *SemanticRouter
        embeddingProvider EmbeddingProvider
        logger            *zap.Logger
}

// NewTextRouter creates a new text router
func NewTextRouter(router *SemanticRouter, provider EmbeddingProvider, logger *zap.Logger) *TextRouter <span class="cov0" title="0">{
        return &amp;TextRouter{
                router:            router,
                embeddingProvider: provider,
                logger:            logger,
        }
}</span>

// RouteText routes a text query to the appropriate index
func (r *TextRouter) RouteText(ctx context.Context, query string) (RoutingDecision, error) <span class="cov0" title="0">{
        // Get embedding for the query
        embedding, err := r.embeddingProvider(query)
        if err != nil </span><span class="cov0" title="0">{
                return RoutingDecision{}, fmt.Errorf("failed to get embedding for query: %w", err)
        }</span>

        // Route the embedding
        <span class="cov0" title="0">return r.router.Route(ctx, embedding)</span>
}

// BatchRouteText routes multiple text queries in parallel
func (r *TextRouter) BatchRouteText(ctx context.Context, queries []string) ([]RoutingDecision, error) <span class="cov0" title="0">{
        // Get embeddings for all queries
        embeddings := make([][]float32, len(queries))
        errors := make([]error, len(queries))
        var wg sync.WaitGroup

        for i, query := range queries </span><span class="cov0" title="0">{
                wg.Add(1)
                go func(idx int, q string) </span><span class="cov0" title="0">{
                        defer wg.Done()
                        embedding, err := r.embeddingProvider(q)
                        if err != nil </span><span class="cov0" title="0">{
                                errors[idx] = err
                                return
                        }</span>
                        <span class="cov0" title="0">embeddings[idx] = embedding</span>
                }(i, query)
        }

        <span class="cov0" title="0">wg.Wait()

        // Check for errors
        for i, err := range errors </span><span class="cov0" title="0">{
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to get embedding for query %d: %w", i, err)
                }</span>
        }

        // Route all embeddings
        <span class="cov0" title="0">return r.router.BatchRoute(ctx, embeddings)</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
